webpackJsonp([0],[
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	var _componentsGeneratorTable = __webpack_require__(157);

	var _componentsGeneratorTable2 = _interopRequireDefault(_componentsGeneratorTable);

	_react2['default'].render(_react2['default'].createElement(_componentsGeneratorTable2['default'], null), document.getElementById('app-container'));

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(2);


/***/ },
/* 2 */,
/* 3 */,
/* 4 */,
/* 5 */,
/* 6 */,
/* 7 */,
/* 8 */,
/* 9 */,
/* 10 */,
/* 11 */,
/* 12 */,
/* 13 */,
/* 14 */,
/* 15 */,
/* 16 */,
/* 17 */,
/* 18 */,
/* 19 */,
/* 20 */,
/* 21 */,
/* 22 */,
/* 23 */,
/* 24 */,
/* 25 */,
/* 26 */,
/* 27 */,
/* 28 */,
/* 29 */,
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */,
/* 34 */,
/* 35 */,
/* 36 */,
/* 37 */,
/* 38 */,
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */,
/* 44 */,
/* 45 */,
/* 46 */,
/* 47 */,
/* 48 */,
/* 49 */,
/* 50 */,
/* 51 */,
/* 52 */,
/* 53 */,
/* 54 */,
/* 55 */,
/* 56 */,
/* 57 */,
/* 58 */,
/* 59 */,
/* 60 */,
/* 61 */,
/* 62 */,
/* 63 */,
/* 64 */,
/* 65 */,
/* 66 */,
/* 67 */,
/* 68 */,
/* 69 */,
/* 70 */,
/* 71 */,
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */,
/* 76 */,
/* 77 */,
/* 78 */,
/* 79 */,
/* 80 */,
/* 81 */,
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */,
/* 97 */,
/* 98 */,
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */,
/* 107 */,
/* 108 */,
/* 109 */,
/* 110 */,
/* 111 */,
/* 112 */,
/* 113 */,
/* 114 */,
/* 115 */,
/* 116 */,
/* 117 */,
/* 118 */,
/* 119 */,
/* 120 */,
/* 121 */,
/* 122 */,
/* 123 */,
/* 124 */,
/* 125 */,
/* 126 */,
/* 127 */,
/* 128 */,
/* 129 */,
/* 130 */,
/* 131 */,
/* 132 */,
/* 133 */,
/* 134 */,
/* 135 */,
/* 136 */,
/* 137 */,
/* 138 */,
/* 139 */,
/* 140 */,
/* 141 */,
/* 142 */,
/* 143 */,
/* 144 */,
/* 145 */,
/* 146 */,
/* 147 */,
/* 148 */,
/* 149 */,
/* 150 */,
/* 151 */,
/* 152 */,
/* 153 */,
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _createDecoratedClass = (function () { function defineProperties(target, descriptors, initializers) { for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } if (descriptor.initializer !== undefined) { initializers[key] = descriptor; continue; } } Object.defineProperty(target, key, descriptor); } } return function (Constructor, protoProps, staticProps, protoInitializers, staticInitializers) { if (protoProps) defineProperties(Constructor.prototype, protoProps, protoInitializers); if (staticProps) defineProperties(Constructor, staticProps, staticInitializers); return Constructor; }; })();

	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	var _autobindDecorator = __webpack_require__(158);

	var _autobindDecorator2 = _interopRequireDefault(_autobindDecorator);

	var _generatorTableRow = __webpack_require__(159);

	var _generatorTableRow2 = _interopRequireDefault(_generatorTableRow);

	var _rules = __webpack_require__(163);

	var _rules2 = _interopRequireDefault(_rules);

	var GeneratorTable = (function (_React$Component) {
	  function GeneratorTable() {
	    _classCallCheck(this, GeneratorTable);

	    _get(Object.getPrototypeOf(GeneratorTable.prototype), 'constructor', this).apply(this, arguments);

	    this.state = {
	      eslintrc: '',
	      includeDisabled: false,
	      includeDefaultOptions: false
	    };
	  }

	  _inherits(GeneratorTable, _React$Component);

	  _createDecoratedClass(GeneratorTable, [{
	    key: 'renderRows',
	    value: function renderRows() {
	      var currCategory = null;
	      return Object.keys(_rules2['default']).map(function (category) {
	        return [_react2['default'].createElement(
	          'tr',
	          null,
	          _react2['default'].createElement(
	            'td',
	            { colSpan: '7', className: 'separator' },
	            _react2['default'].createElement(
	              'h4',
	              null,
	              category
	            )
	          )
	        )].concat(_rules2['default'][category].map(function (rule) {
	          return _react2['default'].createElement(_generatorTableRow2['default'], { rule: rule, key: rule.name, ref: rule.name });
	        }));
	      });
	    }
	  }, {
	    key: 'eslintrc',
	    value: function eslintrc() {
	      var _this = this;

	      var ruleValues = _.chain(this.refs).keys().reduce(function (acc, ref) {
	        acc[ref] = _this.refs[ref].getValue();
	        return acc;
	      }, {}, this).value();

	      if (!this.state.includeDisabled) {
	        ruleValues = _.reduce(ruleValues, function (acc, val, key) {
	          if (val != 0) {
	            acc[key] = val;
	          }
	          return acc;
	        }, {});
	      }

	      var rulestring = _.map(ruleValues, function (val, key) {
	        return '"' + key + '": ' + JSON.stringify(val);
	      }).join(',\n    ');

	      return '{\n  "rules": {\n    ' + rulestring + '\n  }\n}';
	    }
	  }, {
	    key: 'generateEslintrc',
	    decorators: [_autobindDecorator2['default']],
	    value: function generateEslintrc(e) {
	      e.preventDefault();
	      this.setState({
	        eslintrc: this.eslintrc()
	      });
	    }
	  }, {
	    key: 'updateIncludeDisabled',
	    decorators: [_autobindDecorator2['default']],
	    value: function updateIncludeDisabled(e) {
	      this.setState({
	        includeDisabled: e.target.checked
	      });
	    }
	  }, {
	    key: 'updateIncludeDefaultOptions',
	    decorators: [_autobindDecorator2['default']],
	    value: function updateIncludeDefaultOptions(e) {
	      this.setState({
	        includeDefaultOptions: e.target.checked
	      });
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      return _react2['default'].createElement(
	        'form',
	        { role: 'form', className: 'container', onSubmit: this.generateEslintrc },
	        _react2['default'].createElement(
	          'h1',
	          null,
	          'ESLint Rule Generator'
	        ),
	        _react2['default'].createElement(
	          'table',
	          { className: 'table table-bordered table-hover' },
	          _react2['default'].createElement(
	            'thead',
	            null,
	            _react2['default'].createElement(
	              'tr',
	              null,
	              _react2['default'].createElement(
	                'th',
	                null,
	                'Rule'
	              ),
	              _react2['default'].createElement(
	                'th',
	                null,
	                'Description'
	              ),
	              _react2['default'].createElement(
	                'th',
	                null,
	                'Recommended?'
	              ),
	              _react2['default'].createElement(
	                'th',
	                null,
	                'Warning'
	              ),
	              _react2['default'].createElement(
	                'th',
	                null,
	                'Error'
	              )
	            )
	          ),
	          _react2['default'].createElement(
	            'tbody',
	            null,
	            this.renderRows()
	          )
	        ),
	        _react2['default'].createElement(
	          'div',
	          { className: 'post-form' },
	          _react2['default'].createElement(
	            'p',
	            null,
	            _react2['default'].createElement(
	              'label',
	              null,
	              _react2['default'].createElement('input', { type: 'checkbox', checked: this.state.includeDisabled, onChange: this.updateIncludeDisabled }),
	              ' Include disabled rules'
	            )
	          ),
	          _react2['default'].createElement(
	            'p',
	            null,
	            _react2['default'].createElement(
	              'label',
	              null,
	              _react2['default'].createElement('input', { type: 'checkbox', checked: this.state.includeDefaultOptions, onChange: this.updateIncludeDefaultOptions }),
	              ' Include default options'
	            )
	          ),
	          _react2['default'].createElement(
	            'p',
	            null,
	            _react2['default'].createElement(
	              'button',
	              { className: 'btn btn-primary btn-lg' },
	              'Generate rules'
	            )
	          )
	        ),
	        _react2['default'].createElement(
	          'p',
	          null,
	          _react2['default'].createElement('textarea', { className: 'form-control', rows: '20', value: this.state.eslintrc })
	        )
	      );
	    }
	  }]);

	  return GeneratorTable;
	})(_react2['default'].Component);

	exports['default'] = GeneratorTable;
	module.exports = exports['default'];

/***/ },
/* 158 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	/**
	 * @copyright 2015, Andrey Popp <8mayday@gmail.com>
	 *
	 * The decorator may be used on classes or methods
	 * ```
	 * @autobind
	 * class FullBound {}
	 *
	 * class PartBound {
	 *   @autobind
	 *   method () {}
	 * }
	 * ```
	 */
	exports['default'] = autobind;

	function autobind() {
	  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }

	  if (args.length === 1) {
	    return boundClass.apply(undefined, args);
	  } else {
	    return boundMethod.apply(undefined, args);
	  }
	}

	/**
	 * Use boundMethod to bind all methods on the target.prototype
	 */
	function boundClass(target) {
	  // (Using reflect to get all keys including symbols)
	  Reflect.ownKeys(target.prototype).forEach(function (key) {
	    // Ignore special case target method
	    if (key === 'constructor') {
	      return;
	    }

	    var descriptor = Object.getOwnPropertyDescriptor(target.prototype, key);

	    // Only methods need binding
	    if (typeof descriptor.value === 'function') {
	      Object.defineProperty(target.prototype, key, boundMethod(target, key, descriptor));
	    }
	  });
	  return target;
	}

	/**
	 * Return a descriptor removing the value and returning a getter
	 * The getter will return a .bind version of the function
	 * and memoize the result against a symbol on the instance
	 */
	function boundMethod(target, key, descriptor) {
	  var fn = descriptor.value;

	  if (typeof fn !== 'function') {
	    throw new Error('@autobind decorator can only be applied to methods not: ' + typeof fn);
	  }

	  return {
	    configurable: true,
	    get: function get() {
	      var boundFn = fn.bind(this);
	      Object.defineProperty(this, key, {
	        value: boundFn,
	        configurable: true,
	        writable: true
	      });
	      return boundFn;
	    }
	  };
	}
	module.exports = exports['default'];


/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _createDecoratedClass = (function () { function defineProperties(target, descriptors, initializers) { for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } if (descriptor.initializer !== undefined) { initializers[key] = descriptor; continue; } } Object.defineProperty(target, key, descriptor); } } return function (Constructor, protoProps, staticProps, protoInitializers, staticInitializers) { if (protoProps) defineProperties(Constructor.prototype, protoProps, protoInitializers); if (staticProps) defineProperties(Constructor, staticProps, staticInitializers); return Constructor; }; })();

	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	var _lodash = __webpack_require__(160);

	var _lodash2 = _interopRequireDefault(_lodash);

	var _autobindDecorator = __webpack_require__(158);

	var _autobindDecorator2 = _interopRequireDefault(_autobindDecorator);

	var _optionsRow = __webpack_require__(162);

	var _optionsRow2 = _interopRequireDefault(_optionsRow);

	var GeneratorTableRow = (function (_React$Component) {
	  function GeneratorTableRow() {
	    _classCallCheck(this, GeneratorTableRow);

	    _get(Object.getPrototypeOf(GeneratorTableRow.prototype), 'constructor', this).apply(this, arguments);

	    this.state = {
	      warningChecked: false,
	      errorChecked: false
	    };
	  }

	  _inherits(GeneratorTableRow, _React$Component);

	  _createDecoratedClass(GeneratorTableRow, [{
	    key: 'getValue',
	    value: function getValue() {
	      var value = this.getEnabledValue();
	      var option;

	      if (value != 0 && this.refs.options) {
	        option = this.refs.options.getValue();
	      }

	      return option ? [value].concat(option) : value;
	    }
	  }, {
	    key: 'getEnabledValue',
	    value: function getEnabledValue() {
	      if (this.state.errorChecked) {
	        return 2;
	      } else if (this.state.warningChecked) {
	        return 1;
	      } else {
	        return 0;
	      }
	    }
	  }, {
	    key: 'updateWarning',
	    decorators: [_autobindDecorator2['default']],
	    value: function updateWarning(e) {
	      this.setState({ warningChecked: e.target.checked });
	      if (e.target.checked) {
	        this.setState({ errorChecked: false });
	      }
	    }
	  }, {
	    key: 'updateError',
	    decorators: [_autobindDecorator2['default']],
	    value: function updateError(e) {
	      this.setState({ errorChecked: e.target.checked });
	      if (e.target.checked) {
	        this.setState({ warningChecked: false });
	      }
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var url = 'http://eslint.org/docs/rules/' + this.props.rule.name;
	      var recommended = this.props.rule.recommended ? 'Yes' : '';
	      var warningClass = 'checkbox-container ' + (this.state.warningChecked ? 'bg-info' : '');
	      var errorClass = 'checkbox-container ' + (this.state.errorChecked ? 'bg-info' : '');
	      var optionsRow = null;

	      if (this.props.rule.schema && (this.props.rule.schema.length && this.props.rule.schema.length > 0 || Object.keys(this.props.rule.schema).length > 0) || this.props.rule.manualOption) {
	        optionsRow = _react2['default'].createElement(_optionsRow2['default'], { ref: 'options', rule: this.props.rule, show: this.state.warningChecked || this.state.errorChecked });
	      }

	      return _react2['default'].createElement(
	        'tbody',
	        { style: { borderTop: 'none' } },
	        _react2['default'].createElement(
	          'tr',
	          null,
	          _react2['default'].createElement(
	            'td',
	            null,
	            this.props.rule.name
	          ),
	          _react2['default'].createElement(
	            'td',
	            { className: 'rule-description' },
	            _react2['default'].createElement(
	              'a',
	              { className: 'rule-description', href: url },
	              this.props.rule.description
	            )
	          ),
	          _react2['default'].createElement(
	            'td',
	            null,
	            recommended
	          ),
	          _react2['default'].createElement(
	            'td',
	            { className: warningClass },
	            _react2['default'].createElement(
	              'label',
	              { className: 'stretch' },
	              _react2['default'].createElement('input', { type: 'checkbox', checked: this.state.warningChecked, onChange: this.updateWarning })
	            )
	          ),
	          _react2['default'].createElement(
	            'td',
	            { className: errorClass },
	            _react2['default'].createElement(
	              'label',
	              { className: 'stretch' },
	              _react2['default'].createElement('input', { type: 'checkbox', checked: this.state.errorChecked, onChange: this.updateError })
	            )
	          )
	        ),
	        optionsRow
	      );
	    }
	  }]);

	  return GeneratorTableRow;
	})(_react2['default'].Component);

	exports['default'] = GeneratorTableRow;
	module.exports = exports['default'];

/***/ },
/* 160 */,
/* 161 */,
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	var OptionsRow = (function (_React$Component) {
	  function OptionsRow() {
	    _classCallCheck(this, OptionsRow);

	    _get(Object.getPrototypeOf(OptionsRow.prototype), 'constructor', this).apply(this, arguments);

	    this.state = {
	      manualValue: '',
	      values: {}
	    };
	  }

	  _inherits(OptionsRow, _React$Component);

	  _createClass(OptionsRow, [{
	    key: 'getValueByType',
	    value: function getValueByType(val, key) {
	      if (val.type == 'object') {
	        return _.mapValues(val.properties, this.getValueByType, this);

	        // id-length uses 'number' to declare integers
	      } else if (val.type == 'integer' || val.type == 'number') {
	        return parseInt(this.state.values[key]);
	      } else if (val.type == 'array' && this.state.values[key]) {
	        return this.state.values[key].split(',');
	      } else {
	        return this.state.values[key];
	      }
	    }
	  }, {
	    key: 'getValue',
	    value: function getValue() {
	      if (this.props.rule.manualOption && this.state.manualValue) {
	        try {
	          return JSON.parse(this.state.manualValue.replace(/\s/g, ''));
	        } catch (e) {
	          return 'Error parsing input';
	        }
	      } else if (_.keys(this.state.values).length > 0) {
	        if (_.isArray(this.props.rule.schema)) {
	          return _.map(this.props.rule.schema, this.getValueByType, this);
	        }
	      }
	    }
	  }, {
	    key: 'flattenSchema',
	    value: function flattenSchema(schema) {
	      var args = [_.chain(schema).filter(function (val, i) {
	        return val.type != 'object';
	      }).reduce(function (acc, val, i) {
	        acc[i] = val;
	        return acc;
	      }, {}).value()];

	      var list = _.chain(schema).filter(function (val, i) {
	        return val.type == 'object';
	      }).reduce(function (acc, val, key) {
	        return _.merge(acc, val.properties);
	      }, {}).value();
	      var stuff = _.merge.apply(_, args.concat(list));
	      return stuff;
	    }
	  }, {
	    key: 'renderOptions',
	    value: function renderOptions(key, options) {
	      var _this = this;

	      var optionOptions = [''].concat(options).map(function (option) {
	        return _react2['default'].createElement(
	          'option',
	          { key: option },
	          option
	        );
	      });
	      var update = function update(e) {
	        _this.state.values[key] = e.target.value;
	        _this.forceUpdate();
	      };
	      return _react2['default'].createElement(
	        'td',
	        { key: key },
	        _react2['default'].createElement(
	          'select',
	          { className: 'form-control', value: this.state.values[key], onChange: update },
	          optionOptions
	        )
	      );
	    }
	  }, {
	    key: 'renderBooleans',
	    value: function renderBooleans(options) {
	      var _this2 = this;

	      if (options.length == 0) {
	        return null;
	      }
	      var cboxes = _.map(options, function (option) {
	        var onUpdate = function onUpdate(e) {
	          _this2.state.values[option] = e.target.checked;
	          _this2.forceUpdate();
	        };
	        return _react2['default'].createElement(
	          'div',
	          { key: option },
	          _react2['default'].createElement(
	            'label',
	            null,
	            _react2['default'].createElement('input', { type: 'checkbox', checked: _this2.state.values[option], onChange: onUpdate }),
	            ' ',
	            option
	          )
	        );
	      }, this);
	      return _react2['default'].createElement(
	        'td',
	        { key: 'booleans' },
	        cboxes
	      );
	    }
	  }, {
	    key: 'renderArray',
	    value: function renderArray(key) {
	      var _this3 = this;

	      var update = function update(e) {
	        _this3.state.values[key] = e.target.value;
	        _this3.forceUpdate();
	      };
	      return _react2['default'].createElement(
	        'td',
	        { key: key },
	        _react2['default'].createElement('input', { type: 'text', onChange: update, value: this.state.values[key], placeholder: 'comma separate values', className: 'form-control' })
	      );
	    }
	  }, {
	    key: 'renderText',
	    value: function renderText(key) {
	      var _this4 = this;

	      var update = function update(e) {
	        _this4.state.values[key] = e.target.value;
	        _this4.forceUpdate();
	      };
	      return _react2['default'].createElement(
	        'td',
	        { key: key },
	        _react2['default'].createElement('input', { type: 'text', onChange: update, value: this.state.values[key], className: 'form-control' })
	      );
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _this5 = this;

	      var optionHeaders = [];
	      var optionCells = [];
	      var optionComponents = null;
	      var optionComponent = [];
	      var optionDefaults = null;
	      var className = 'rule-options';
	      var cellClassName = 'rule-options-cell';

	      if (!this.props.show) {
	        className += ' nothing';
	        cellClassName += ' nothing';
	      }

	      if (this.props.rule.manualOption) {
	        var update = function update(e) {
	          _this5.setState({ 'manualValue': e.target.value });
	        };
	        optionComponents = _react2['default'].createElement('textarea', { key: 'manual', onChange: update, defaultValue: this.state.manualValue, className: 'form-control', rows: '5' });
	      } else if (this.props.rule.schema) {

	        var schema = this.flattenSchema(this.props.rule.schema);

	        var booleans = _.pick(schema, function (val, key) {
	          return val.type == 'boolean';
	        });
	        var otherFields = _.pick(schema, function (val, key) {
	          return val.type != 'boolean';
	        });

	        optionHeaders = _.map(_.keys(otherFields), function (val) {
	          var heading = val;
	          if (parseInt(val, 10) == val) {
	            val = parseInt(val, 10) + 1;
	            if (val == 1) {
	              heading = '1st';
	            } else if (val == 2) {
	              heading = '2nd';
	            } else if (val == 3) {
	              heading = '3rd';
	            } else if (val == 4) {
	              heading = '4th';
	            }
	            heading += ' argument';
	          }
	          return _react2['default'].createElement(
	            'td',
	            { className: 'option-header' },
	            heading
	          );
	        });

	        if (_.keys(booleans).length > 0) {
	          optionHeaders.push(_react2['default'].createElement(
	            'td',
	            { className: 'option-header' },
	            'Options'
	          ));
	        }

	        for (var name in otherFields) {
	          if (otherFields[name]['enum']) {
	            optionCells.push(this.renderOptions(name, otherFields[name]['enum']));
	          } else if (otherFields[name].type == 'array') {
	            optionCells.push(this.renderArray(name));
	          } else if (otherFields[name].type == 'integer' || otherFields[name].type == 'string' || otherFields[name].type == 'number') {
	            optionCells.push(this.renderText(name));
	          }
	        }
	        optionCells.push(this.renderBooleans(_.keys(booleans)));

	        if (this.props.rule.defaultValues) {
	          optionDefaults = _.map(this.props.rule.defaultValues, function (value, name) {
	            return name + ': ' + value;
	          }).join(', ');
	          // optionComponents.push(<td>{optionDefaults}</td>);
	        } else {}

	        optionComponents = _react2['default'].createElement(
	          'table',
	          { className: 'options-table' },
	          _react2['default'].createElement(
	            'tr',
	            null,
	            optionHeaders
	          ),
	          _react2['default'].createElement(
	            'tr',
	            null,
	            optionCells
	          )
	        );
	      }

	      return _react2['default'].createElement(
	        'tr',
	        null,
	        _react2['default'].createElement(
	          'td',
	          { colSpan: '7', className: cellClassName },
	          _react2['default'].createElement(
	            'div',
	            { className: className, id: this.props.rule.name + '-options', key: this.props.rule.name + '-options' },
	            optionComponents
	          )
	        )
	      );
	    }
	  }]);

	  return OptionsRow;
	})(_react2['default'].Component);

	exports['default'] = OptionsRow;

	OptionsRow.defaultProps = { show: false };
	module.exports = exports['default'];

	// optionComponents.push(<td></td>);

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _lodash = __webpack_require__(160);

	var _lodash2 = _interopRequireDefault(_lodash);

	var _eslintLibRulesCommaDangle = __webpack_require__(165);

	var _eslintLibRulesCommaDangle2 = _interopRequireDefault(_eslintLibRulesCommaDangle);

	var _eslintLibRulesNoCondAssign = __webpack_require__(166);

	var _eslintLibRulesNoCondAssign2 = _interopRequireDefault(_eslintLibRulesNoCondAssign);

	var _eslintLibRulesNoConsole = __webpack_require__(167);

	var _eslintLibRulesNoConsole2 = _interopRequireDefault(_eslintLibRulesNoConsole);

	var _eslintLibRulesNoConstantCondition = __webpack_require__(168);

	var _eslintLibRulesNoConstantCondition2 = _interopRequireDefault(_eslintLibRulesNoConstantCondition);

	var _eslintLibRulesNoControlRegex = __webpack_require__(169);

	var _eslintLibRulesNoControlRegex2 = _interopRequireDefault(_eslintLibRulesNoControlRegex);

	var _eslintLibRulesNoDebugger = __webpack_require__(170);

	var _eslintLibRulesNoDebugger2 = _interopRequireDefault(_eslintLibRulesNoDebugger);

	var _eslintLibRulesNoDupeArgs = __webpack_require__(171);

	var _eslintLibRulesNoDupeArgs2 = _interopRequireDefault(_eslintLibRulesNoDupeArgs);

	var _eslintLibRulesNoDupeKeys = __webpack_require__(172);

	var _eslintLibRulesNoDupeKeys2 = _interopRequireDefault(_eslintLibRulesNoDupeKeys);

	var _eslintLibRulesNoDuplicateCase = __webpack_require__(173);

	var _eslintLibRulesNoDuplicateCase2 = _interopRequireDefault(_eslintLibRulesNoDuplicateCase);

	var _eslintLibRulesNoEmptyCharacterClass = __webpack_require__(174);

	var _eslintLibRulesNoEmptyCharacterClass2 = _interopRequireDefault(_eslintLibRulesNoEmptyCharacterClass);

	var _eslintLibRulesNoEmpty = __webpack_require__(175);

	var _eslintLibRulesNoEmpty2 = _interopRequireDefault(_eslintLibRulesNoEmpty);

	var _eslintLibRulesNoExAssign = __webpack_require__(176);

	var _eslintLibRulesNoExAssign2 = _interopRequireDefault(_eslintLibRulesNoExAssign);

	var _eslintLibRulesNoExtraBooleanCast = __webpack_require__(178);

	var _eslintLibRulesNoExtraBooleanCast2 = _interopRequireDefault(_eslintLibRulesNoExtraBooleanCast);

	var _eslintLibRulesNoExtraParens = __webpack_require__(179);

	var _eslintLibRulesNoExtraParens2 = _interopRequireDefault(_eslintLibRulesNoExtraParens);

	var _eslintLibRulesNoExtraSemi = __webpack_require__(180);

	var _eslintLibRulesNoExtraSemi2 = _interopRequireDefault(_eslintLibRulesNoExtraSemi);

	var _eslintLibRulesNoFuncAssign = __webpack_require__(181);

	var _eslintLibRulesNoFuncAssign2 = _interopRequireDefault(_eslintLibRulesNoFuncAssign);

	var _eslintLibRulesNoInnerDeclarations = __webpack_require__(182);

	var _eslintLibRulesNoInnerDeclarations2 = _interopRequireDefault(_eslintLibRulesNoInnerDeclarations);

	var _eslintLibRulesNoInvalidRegexp = __webpack_require__(183);

	var _eslintLibRulesNoInvalidRegexp2 = _interopRequireDefault(_eslintLibRulesNoInvalidRegexp);

	var _eslintLibRulesNoIrregularWhitespace = __webpack_require__(195);

	var _eslintLibRulesNoIrregularWhitespace2 = _interopRequireDefault(_eslintLibRulesNoIrregularWhitespace);

	var _eslintLibRulesNoNegatedInLhs = __webpack_require__(196);

	var _eslintLibRulesNoNegatedInLhs2 = _interopRequireDefault(_eslintLibRulesNoNegatedInLhs);

	var _eslintLibRulesNoObjCalls = __webpack_require__(197);

	var _eslintLibRulesNoObjCalls2 = _interopRequireDefault(_eslintLibRulesNoObjCalls);

	var _eslintLibRulesNoRegexSpaces = __webpack_require__(198);

	var _eslintLibRulesNoRegexSpaces2 = _interopRequireDefault(_eslintLibRulesNoRegexSpaces);

	var _eslintLibRulesNoSparseArrays = __webpack_require__(199);

	var _eslintLibRulesNoSparseArrays2 = _interopRequireDefault(_eslintLibRulesNoSparseArrays);

	var _eslintLibRulesNoUnreachable = __webpack_require__(200);

	var _eslintLibRulesNoUnreachable2 = _interopRequireDefault(_eslintLibRulesNoUnreachable);

	var _eslintLibRulesUseIsnan = __webpack_require__(201);

	var _eslintLibRulesUseIsnan2 = _interopRequireDefault(_eslintLibRulesUseIsnan);

	var _eslintLibRulesValidJsdoc = __webpack_require__(202);

	var _eslintLibRulesValidJsdoc2 = _interopRequireDefault(_eslintLibRulesValidJsdoc);

	var _eslintLibRulesValidTypeof = __webpack_require__(216);

	var _eslintLibRulesValidTypeof2 = _interopRequireDefault(_eslintLibRulesValidTypeof);

	var _eslintLibRulesNoUnexpectedMultiline = __webpack_require__(217);

	var _eslintLibRulesNoUnexpectedMultiline2 = _interopRequireDefault(_eslintLibRulesNoUnexpectedMultiline);

	var _eslintLibRulesAccessorPairs = __webpack_require__(218);

	var _eslintLibRulesAccessorPairs2 = _interopRequireDefault(_eslintLibRulesAccessorPairs);

	var _eslintLibRulesBlockScopedVar = __webpack_require__(219);

	var _eslintLibRulesBlockScopedVar2 = _interopRequireDefault(_eslintLibRulesBlockScopedVar);

	var _eslintLibRulesComplexity = __webpack_require__(220);

	var _eslintLibRulesComplexity2 = _interopRequireDefault(_eslintLibRulesComplexity);

	var _eslintLibRulesConsistentReturn = __webpack_require__(221);

	var _eslintLibRulesConsistentReturn2 = _interopRequireDefault(_eslintLibRulesConsistentReturn);

	var _eslintLibRulesCurly = __webpack_require__(222);

	var _eslintLibRulesCurly2 = _interopRequireDefault(_eslintLibRulesCurly);

	var _eslintLibRulesDefaultCase = __webpack_require__(223);

	var _eslintLibRulesDefaultCase2 = _interopRequireDefault(_eslintLibRulesDefaultCase);

	var _eslintLibRulesDotNotation = __webpack_require__(224);

	var _eslintLibRulesDotNotation2 = _interopRequireDefault(_eslintLibRulesDotNotation);

	var _eslintLibRulesDotLocation = __webpack_require__(226);

	var _eslintLibRulesDotLocation2 = _interopRequireDefault(_eslintLibRulesDotLocation);

	var _eslintLibRulesEqeqeq = __webpack_require__(227);

	var _eslintLibRulesEqeqeq2 = _interopRequireDefault(_eslintLibRulesEqeqeq);

	var _eslintLibRulesGuardForIn = __webpack_require__(228);

	var _eslintLibRulesGuardForIn2 = _interopRequireDefault(_eslintLibRulesGuardForIn);

	var _eslintLibRulesNoAlert = __webpack_require__(229);

	var _eslintLibRulesNoAlert2 = _interopRequireDefault(_eslintLibRulesNoAlert);

	var _eslintLibRulesNoCaller = __webpack_require__(230);

	var _eslintLibRulesNoCaller2 = _interopRequireDefault(_eslintLibRulesNoCaller);

	var _eslintLibRulesNoDivRegex = __webpack_require__(231);

	var _eslintLibRulesNoDivRegex2 = _interopRequireDefault(_eslintLibRulesNoDivRegex);

	var _eslintLibRulesNoElseReturn = __webpack_require__(232);

	var _eslintLibRulesNoElseReturn2 = _interopRequireDefault(_eslintLibRulesNoElseReturn);

	var _eslintLibRulesNoEmptyLabel = __webpack_require__(233);

	var _eslintLibRulesNoEmptyLabel2 = _interopRequireDefault(_eslintLibRulesNoEmptyLabel);

	var _eslintLibRulesNoEqNull = __webpack_require__(234);

	var _eslintLibRulesNoEqNull2 = _interopRequireDefault(_eslintLibRulesNoEqNull);

	var _eslintLibRulesNoEval = __webpack_require__(235);

	var _eslintLibRulesNoEval2 = _interopRequireDefault(_eslintLibRulesNoEval);

	var _eslintLibRulesNoExtendNative = __webpack_require__(236);

	var _eslintLibRulesNoExtendNative2 = _interopRequireDefault(_eslintLibRulesNoExtendNative);

	var _eslintLibRulesNoExtraBind = __webpack_require__(239);

	var _eslintLibRulesNoExtraBind2 = _interopRequireDefault(_eslintLibRulesNoExtraBind);

	var _eslintLibRulesNoFallthrough = __webpack_require__(240);

	var _eslintLibRulesNoFallthrough2 = _interopRequireDefault(_eslintLibRulesNoFallthrough);

	var _eslintLibRulesNoFloatingDecimal = __webpack_require__(241);

	var _eslintLibRulesNoFloatingDecimal2 = _interopRequireDefault(_eslintLibRulesNoFloatingDecimal);

	var _eslintLibRulesNoImplicitCoercion = __webpack_require__(242);

	var _eslintLibRulesNoImplicitCoercion2 = _interopRequireDefault(_eslintLibRulesNoImplicitCoercion);

	var _eslintLibRulesNoImpliedEval = __webpack_require__(243);

	var _eslintLibRulesNoImpliedEval2 = _interopRequireDefault(_eslintLibRulesNoImpliedEval);

	var _eslintLibRulesNoInvalidThis = __webpack_require__(244);

	var _eslintLibRulesNoInvalidThis2 = _interopRequireDefault(_eslintLibRulesNoInvalidThis);

	var _eslintLibRulesNoIterator = __webpack_require__(245);

	var _eslintLibRulesNoIterator2 = _interopRequireDefault(_eslintLibRulesNoIterator);

	var _eslintLibRulesNoLabels = __webpack_require__(246);

	var _eslintLibRulesNoLabels2 = _interopRequireDefault(_eslintLibRulesNoLabels);

	var _eslintLibRulesNoLoneBlocks = __webpack_require__(247);

	var _eslintLibRulesNoLoneBlocks2 = _interopRequireDefault(_eslintLibRulesNoLoneBlocks);

	var _eslintLibRulesNoLoopFunc = __webpack_require__(248);

	var _eslintLibRulesNoLoopFunc2 = _interopRequireDefault(_eslintLibRulesNoLoopFunc);

	var _eslintLibRulesNoMultiSpaces = __webpack_require__(249);

	var _eslintLibRulesNoMultiSpaces2 = _interopRequireDefault(_eslintLibRulesNoMultiSpaces);

	var _eslintLibRulesNoMultiStr = __webpack_require__(250);

	var _eslintLibRulesNoMultiStr2 = _interopRequireDefault(_eslintLibRulesNoMultiStr);

	var _eslintLibRulesNoNativeReassign = __webpack_require__(251);

	var _eslintLibRulesNoNativeReassign2 = _interopRequireDefault(_eslintLibRulesNoNativeReassign);

	var _eslintLibRulesNoNewFunc = __webpack_require__(252);

	var _eslintLibRulesNoNewFunc2 = _interopRequireDefault(_eslintLibRulesNoNewFunc);

	var _eslintLibRulesNoNewWrappers = __webpack_require__(253);

	var _eslintLibRulesNoNewWrappers2 = _interopRequireDefault(_eslintLibRulesNoNewWrappers);

	var _eslintLibRulesNoNew = __webpack_require__(254);

	var _eslintLibRulesNoNew2 = _interopRequireDefault(_eslintLibRulesNoNew);

	var _eslintLibRulesNoOctalEscape = __webpack_require__(255);

	var _eslintLibRulesNoOctalEscape2 = _interopRequireDefault(_eslintLibRulesNoOctalEscape);

	var _eslintLibRulesNoOctal = __webpack_require__(256);

	var _eslintLibRulesNoOctal2 = _interopRequireDefault(_eslintLibRulesNoOctal);

	var _eslintLibRulesNoParamReassign = __webpack_require__(257);

	var _eslintLibRulesNoParamReassign2 = _interopRequireDefault(_eslintLibRulesNoParamReassign);

	var _eslintLibRulesNoProcessEnv = __webpack_require__(258);

	var _eslintLibRulesNoProcessEnv2 = _interopRequireDefault(_eslintLibRulesNoProcessEnv);

	var _eslintLibRulesNoProto = __webpack_require__(259);

	var _eslintLibRulesNoProto2 = _interopRequireDefault(_eslintLibRulesNoProto);

	var _eslintLibRulesNoRedeclare = __webpack_require__(260);

	var _eslintLibRulesNoRedeclare2 = _interopRequireDefault(_eslintLibRulesNoRedeclare);

	var _eslintLibRulesNoReturnAssign = __webpack_require__(261);

	var _eslintLibRulesNoReturnAssign2 = _interopRequireDefault(_eslintLibRulesNoReturnAssign);

	var _eslintLibRulesNoScriptUrl = __webpack_require__(262);

	var _eslintLibRulesNoScriptUrl2 = _interopRequireDefault(_eslintLibRulesNoScriptUrl);

	var _eslintLibRulesNoSelfCompare = __webpack_require__(263);

	var _eslintLibRulesNoSelfCompare2 = _interopRequireDefault(_eslintLibRulesNoSelfCompare);

	var _eslintLibRulesNoSequences = __webpack_require__(264);

	var _eslintLibRulesNoSequences2 = _interopRequireDefault(_eslintLibRulesNoSequences);

	var _eslintLibRulesNoThrowLiteral = __webpack_require__(265);

	var _eslintLibRulesNoThrowLiteral2 = _interopRequireDefault(_eslintLibRulesNoThrowLiteral);

	var _eslintLibRulesNoUnusedExpressions = __webpack_require__(266);

	var _eslintLibRulesNoUnusedExpressions2 = _interopRequireDefault(_eslintLibRulesNoUnusedExpressions);

	var _eslintLibRulesNoUselessCall = __webpack_require__(267);

	var _eslintLibRulesNoUselessCall2 = _interopRequireDefault(_eslintLibRulesNoUselessCall);

	var _eslintLibRulesNoVoid = __webpack_require__(268);

	var _eslintLibRulesNoVoid2 = _interopRequireDefault(_eslintLibRulesNoVoid);

	var _eslintLibRulesNoWarningComments = __webpack_require__(269);

	var _eslintLibRulesNoWarningComments2 = _interopRequireDefault(_eslintLibRulesNoWarningComments);

	var _eslintLibRulesNoWith = __webpack_require__(270);

	var _eslintLibRulesNoWith2 = _interopRequireDefault(_eslintLibRulesNoWith);

	var _eslintLibRulesRadix = __webpack_require__(271);

	var _eslintLibRulesRadix2 = _interopRequireDefault(_eslintLibRulesRadix);

	var _eslintLibRulesVarsOnTop = __webpack_require__(272);

	var _eslintLibRulesVarsOnTop2 = _interopRequireDefault(_eslintLibRulesVarsOnTop);

	var _eslintLibRulesWrapIife = __webpack_require__(273);

	var _eslintLibRulesWrapIife2 = _interopRequireDefault(_eslintLibRulesWrapIife);

	var _eslintLibRulesYoda = __webpack_require__(274);

	var _eslintLibRulesYoda2 = _interopRequireDefault(_eslintLibRulesYoda);

	var _eslintLibRulesStrict = __webpack_require__(275);

	var _eslintLibRulesStrict2 = _interopRequireDefault(_eslintLibRulesStrict);

	var _eslintLibRulesInitDeclarations = __webpack_require__(276);

	var _eslintLibRulesInitDeclarations2 = _interopRequireDefault(_eslintLibRulesInitDeclarations);

	var _eslintLibRulesNoCatchShadow = __webpack_require__(277);

	var _eslintLibRulesNoCatchShadow2 = _interopRequireDefault(_eslintLibRulesNoCatchShadow);

	var _eslintLibRulesNoDeleteVar = __webpack_require__(278);

	var _eslintLibRulesNoDeleteVar2 = _interopRequireDefault(_eslintLibRulesNoDeleteVar);

	var _eslintLibRulesNoLabelVar = __webpack_require__(164);

	var _eslintLibRulesNoLabelVar2 = _interopRequireDefault(_eslintLibRulesNoLabelVar);

	var _eslintLibRulesNoShadowRestrictedNames = __webpack_require__(279);

	var _eslintLibRulesNoShadowRestrictedNames2 = _interopRequireDefault(_eslintLibRulesNoShadowRestrictedNames);

	var _eslintLibRulesNoShadow = __webpack_require__(280);

	var _eslintLibRulesNoShadow2 = _interopRequireDefault(_eslintLibRulesNoShadow);

	var _eslintLibRulesNoUndefInit = __webpack_require__(281);

	var _eslintLibRulesNoUndefInit2 = _interopRequireDefault(_eslintLibRulesNoUndefInit);

	var _eslintLibRulesNoUndef = __webpack_require__(282);

	var _eslintLibRulesNoUndef2 = _interopRequireDefault(_eslintLibRulesNoUndef);

	var _eslintLibRulesNoUndefined = __webpack_require__(283);

	var _eslintLibRulesNoUndefined2 = _interopRequireDefault(_eslintLibRulesNoUndefined);

	var _eslintLibRulesNoUnusedVars = __webpack_require__(284);

	var _eslintLibRulesNoUnusedVars2 = _interopRequireDefault(_eslintLibRulesNoUnusedVars);

	var _eslintLibRulesNoUseBeforeDefine = __webpack_require__(285);

	var _eslintLibRulesNoUseBeforeDefine2 = _interopRequireDefault(_eslintLibRulesNoUseBeforeDefine);

	var _eslintLibRulesCallbackReturn = __webpack_require__(286);

	var _eslintLibRulesCallbackReturn2 = _interopRequireDefault(_eslintLibRulesCallbackReturn);

	var _eslintLibRulesHandleCallbackErr = __webpack_require__(287);

	var _eslintLibRulesHandleCallbackErr2 = _interopRequireDefault(_eslintLibRulesHandleCallbackErr);

	var _eslintLibRulesNoMixedRequires = __webpack_require__(288);

	var _eslintLibRulesNoMixedRequires2 = _interopRequireDefault(_eslintLibRulesNoMixedRequires);

	var _eslintLibRulesNoNewRequire = __webpack_require__(289);

	var _eslintLibRulesNoNewRequire2 = _interopRequireDefault(_eslintLibRulesNoNewRequire);

	var _eslintLibRulesNoPathConcat = __webpack_require__(290);

	var _eslintLibRulesNoPathConcat2 = _interopRequireDefault(_eslintLibRulesNoPathConcat);

	var _eslintLibRulesNoProcessExit = __webpack_require__(291);

	var _eslintLibRulesNoProcessExit2 = _interopRequireDefault(_eslintLibRulesNoProcessExit);

	var _eslintLibRulesNoRestrictedModules = __webpack_require__(292);

	var _eslintLibRulesNoRestrictedModules2 = _interopRequireDefault(_eslintLibRulesNoRestrictedModules);

	var _eslintLibRulesNoSync = __webpack_require__(293);

	var _eslintLibRulesNoSync2 = _interopRequireDefault(_eslintLibRulesNoSync);

	var _eslintLibRulesArrayBracketSpacing = __webpack_require__(294);

	var _eslintLibRulesArrayBracketSpacing2 = _interopRequireDefault(_eslintLibRulesArrayBracketSpacing);

	var _eslintLibRulesBraceStyle = __webpack_require__(295);

	var _eslintLibRulesBraceStyle2 = _interopRequireDefault(_eslintLibRulesBraceStyle);

	var _eslintLibRulesCamelcase = __webpack_require__(296);

	var _eslintLibRulesCamelcase2 = _interopRequireDefault(_eslintLibRulesCamelcase);

	var _eslintLibRulesCommaSpacing = __webpack_require__(297);

	var _eslintLibRulesCommaSpacing2 = _interopRequireDefault(_eslintLibRulesCommaSpacing);

	var _eslintLibRulesCommaStyle = __webpack_require__(298);

	var _eslintLibRulesCommaStyle2 = _interopRequireDefault(_eslintLibRulesCommaStyle);

	var _eslintLibRulesComputedPropertySpacing = __webpack_require__(299);

	var _eslintLibRulesComputedPropertySpacing2 = _interopRequireDefault(_eslintLibRulesComputedPropertySpacing);

	var _eslintLibRulesConsistentThis = __webpack_require__(300);

	var _eslintLibRulesConsistentThis2 = _interopRequireDefault(_eslintLibRulesConsistentThis);

	var _eslintLibRulesEolLast = __webpack_require__(301);

	var _eslintLibRulesEolLast2 = _interopRequireDefault(_eslintLibRulesEolLast);

	var _eslintLibRulesFuncNames = __webpack_require__(302);

	var _eslintLibRulesFuncNames2 = _interopRequireDefault(_eslintLibRulesFuncNames);

	var _eslintLibRulesFuncStyle = __webpack_require__(303);

	var _eslintLibRulesFuncStyle2 = _interopRequireDefault(_eslintLibRulesFuncStyle);

	var _eslintLibRulesIdLength = __webpack_require__(304);

	var _eslintLibRulesIdLength2 = _interopRequireDefault(_eslintLibRulesIdLength);

	var _eslintLibRulesIndent = __webpack_require__(305);

	var _eslintLibRulesIndent2 = _interopRequireDefault(_eslintLibRulesIndent);

	var _eslintLibRulesKeySpacing = __webpack_require__(307);

	var _eslintLibRulesKeySpacing2 = _interopRequireDefault(_eslintLibRulesKeySpacing);

	var _eslintLibRulesLinesAroundComment = __webpack_require__(308);

	var _eslintLibRulesLinesAroundComment2 = _interopRequireDefault(_eslintLibRulesLinesAroundComment);

	var _eslintLibRulesLinebreakStyle = __webpack_require__(309);

	var _eslintLibRulesLinebreakStyle2 = _interopRequireDefault(_eslintLibRulesLinebreakStyle);

	var _eslintLibRulesMaxNestedCallbacks = __webpack_require__(310);

	var _eslintLibRulesMaxNestedCallbacks2 = _interopRequireDefault(_eslintLibRulesMaxNestedCallbacks);

	var _eslintLibRulesNewCap = __webpack_require__(311);

	var _eslintLibRulesNewCap2 = _interopRequireDefault(_eslintLibRulesNewCap);

	var _eslintLibRulesNewParens = __webpack_require__(312);

	var _eslintLibRulesNewParens2 = _interopRequireDefault(_eslintLibRulesNewParens);

	var _eslintLibRulesNewlineAfterVar = __webpack_require__(313);

	var _eslintLibRulesNewlineAfterVar2 = _interopRequireDefault(_eslintLibRulesNewlineAfterVar);

	var _eslintLibRulesNoArrayConstructor = __webpack_require__(314);

	var _eslintLibRulesNoArrayConstructor2 = _interopRequireDefault(_eslintLibRulesNoArrayConstructor);

	var _eslintLibRulesNoContinue = __webpack_require__(315);

	var _eslintLibRulesNoContinue2 = _interopRequireDefault(_eslintLibRulesNoContinue);

	var _eslintLibRulesNoInlineComments = __webpack_require__(316);

	var _eslintLibRulesNoInlineComments2 = _interopRequireDefault(_eslintLibRulesNoInlineComments);

	var _eslintLibRulesNoLonelyIf = __webpack_require__(317);

	var _eslintLibRulesNoLonelyIf2 = _interopRequireDefault(_eslintLibRulesNoLonelyIf);

	var _eslintLibRulesNoMixedSpacesAndTabs = __webpack_require__(318);

	var _eslintLibRulesNoMixedSpacesAndTabs2 = _interopRequireDefault(_eslintLibRulesNoMixedSpacesAndTabs);

	var _eslintLibRulesNoMultipleEmptyLines = __webpack_require__(319);

	var _eslintLibRulesNoMultipleEmptyLines2 = _interopRequireDefault(_eslintLibRulesNoMultipleEmptyLines);

	var _eslintLibRulesNoNestedTernary = __webpack_require__(320);

	var _eslintLibRulesNoNestedTernary2 = _interopRequireDefault(_eslintLibRulesNoNestedTernary);

	var _eslintLibRulesNoNewObject = __webpack_require__(321);

	var _eslintLibRulesNoNewObject2 = _interopRequireDefault(_eslintLibRulesNoNewObject);

	var _eslintLibRulesNoSpacedFunc = __webpack_require__(322);

	var _eslintLibRulesNoSpacedFunc2 = _interopRequireDefault(_eslintLibRulesNoSpacedFunc);

	var _eslintLibRulesNoTernary = __webpack_require__(323);

	var _eslintLibRulesNoTernary2 = _interopRequireDefault(_eslintLibRulesNoTernary);

	var _eslintLibRulesNoTrailingSpaces = __webpack_require__(324);

	var _eslintLibRulesNoTrailingSpaces2 = _interopRequireDefault(_eslintLibRulesNoTrailingSpaces);

	var _eslintLibRulesNoUnderscoreDangle = __webpack_require__(325);

	var _eslintLibRulesNoUnderscoreDangle2 = _interopRequireDefault(_eslintLibRulesNoUnderscoreDangle);

	var _eslintLibRulesNoUnneededTernary = __webpack_require__(326);

	var _eslintLibRulesNoUnneededTernary2 = _interopRequireDefault(_eslintLibRulesNoUnneededTernary);

	var _eslintLibRulesObjectCurlySpacing = __webpack_require__(327);

	var _eslintLibRulesObjectCurlySpacing2 = _interopRequireDefault(_eslintLibRulesObjectCurlySpacing);

	var _eslintLibRulesOneVar = __webpack_require__(328);

	var _eslintLibRulesOneVar2 = _interopRequireDefault(_eslintLibRulesOneVar);

	var _eslintLibRulesOperatorAssignment = __webpack_require__(329);

	var _eslintLibRulesOperatorAssignment2 = _interopRequireDefault(_eslintLibRulesOperatorAssignment);

	var _eslintLibRulesOperatorLinebreak = __webpack_require__(330);

	var _eslintLibRulesOperatorLinebreak2 = _interopRequireDefault(_eslintLibRulesOperatorLinebreak);

	var _eslintLibRulesPaddedBlocks = __webpack_require__(331);

	var _eslintLibRulesPaddedBlocks2 = _interopRequireDefault(_eslintLibRulesPaddedBlocks);

	var _eslintLibRulesQuoteProps = __webpack_require__(332);

	var _eslintLibRulesQuoteProps2 = _interopRequireDefault(_eslintLibRulesQuoteProps);

	var _eslintLibRulesQuotes = __webpack_require__(333);

	var _eslintLibRulesQuotes2 = _interopRequireDefault(_eslintLibRulesQuotes);

	var _eslintLibRulesIdMatch = __webpack_require__(334);

	var _eslintLibRulesIdMatch2 = _interopRequireDefault(_eslintLibRulesIdMatch);

	var _eslintLibRulesSemiSpacing = __webpack_require__(335);

	var _eslintLibRulesSemiSpacing2 = _interopRequireDefault(_eslintLibRulesSemiSpacing);

	var _eslintLibRulesSemi = __webpack_require__(336);

	var _eslintLibRulesSemi2 = _interopRequireDefault(_eslintLibRulesSemi);

	var _eslintLibRulesSortVars = __webpack_require__(337);

	var _eslintLibRulesSortVars2 = _interopRequireDefault(_eslintLibRulesSortVars);

	var _eslintLibRulesSpaceAfterKeywords = __webpack_require__(338);

	var _eslintLibRulesSpaceAfterKeywords2 = _interopRequireDefault(_eslintLibRulesSpaceAfterKeywords);

	var _eslintLibRulesSpaceBeforeBlocks = __webpack_require__(339);

	var _eslintLibRulesSpaceBeforeBlocks2 = _interopRequireDefault(_eslintLibRulesSpaceBeforeBlocks);

	var _eslintLibRulesSpaceBeforeFunctionParen = __webpack_require__(340);

	var _eslintLibRulesSpaceBeforeFunctionParen2 = _interopRequireDefault(_eslintLibRulesSpaceBeforeFunctionParen);

	var _eslintLibRulesSpaceInParens = __webpack_require__(341);

	var _eslintLibRulesSpaceInParens2 = _interopRequireDefault(_eslintLibRulesSpaceInParens);

	var _eslintLibRulesSpaceInfixOps = __webpack_require__(342);

	var _eslintLibRulesSpaceInfixOps2 = _interopRequireDefault(_eslintLibRulesSpaceInfixOps);

	var _eslintLibRulesSpaceReturnThrowCase = __webpack_require__(343);

	var _eslintLibRulesSpaceReturnThrowCase2 = _interopRequireDefault(_eslintLibRulesSpaceReturnThrowCase);

	var _eslintLibRulesSpaceUnaryOps = __webpack_require__(344);

	var _eslintLibRulesSpaceUnaryOps2 = _interopRequireDefault(_eslintLibRulesSpaceUnaryOps);

	var _eslintLibRulesSpacedComment = __webpack_require__(345);

	var _eslintLibRulesSpacedComment2 = _interopRequireDefault(_eslintLibRulesSpacedComment);

	var _eslintLibRulesWrapRegex = __webpack_require__(347);

	var _eslintLibRulesWrapRegex2 = _interopRequireDefault(_eslintLibRulesWrapRegex);

	var _eslintLibRulesArrowParens = __webpack_require__(348);

	var _eslintLibRulesArrowParens2 = _interopRequireDefault(_eslintLibRulesArrowParens);

	var _eslintLibRulesArrowSpacing = __webpack_require__(349);

	var _eslintLibRulesArrowSpacing2 = _interopRequireDefault(_eslintLibRulesArrowSpacing);

	var _eslintLibRulesConstructorSuper = __webpack_require__(350);

	var _eslintLibRulesConstructorSuper2 = _interopRequireDefault(_eslintLibRulesConstructorSuper);

	var _eslintLibRulesGeneratorStarSpacing = __webpack_require__(351);

	var _eslintLibRulesGeneratorStarSpacing2 = _interopRequireDefault(_eslintLibRulesGeneratorStarSpacing);

	var _eslintLibRulesNoClassAssign = __webpack_require__(352);

	var _eslintLibRulesNoClassAssign2 = _interopRequireDefault(_eslintLibRulesNoClassAssign);

	var _eslintLibRulesNoConstAssign = __webpack_require__(353);

	var _eslintLibRulesNoConstAssign2 = _interopRequireDefault(_eslintLibRulesNoConstAssign);

	var _eslintLibRulesNoThisBeforeSuper = __webpack_require__(354);

	var _eslintLibRulesNoThisBeforeSuper2 = _interopRequireDefault(_eslintLibRulesNoThisBeforeSuper);

	var _eslintLibRulesNoVar = __webpack_require__(355);

	var _eslintLibRulesNoVar2 = _interopRequireDefault(_eslintLibRulesNoVar);

	var _eslintLibRulesObjectShorthand = __webpack_require__(356);

	var _eslintLibRulesObjectShorthand2 = _interopRequireDefault(_eslintLibRulesObjectShorthand);

	var _eslintLibRulesPreferConst = __webpack_require__(357);

	var _eslintLibRulesPreferConst2 = _interopRequireDefault(_eslintLibRulesPreferConst);

	var _eslintLibRulesPreferSpread = __webpack_require__(358);

	var _eslintLibRulesPreferSpread2 = _interopRequireDefault(_eslintLibRulesPreferSpread);

	var _eslintLibRulesPreferReflect = __webpack_require__(359);

	var _eslintLibRulesPreferReflect2 = _interopRequireDefault(_eslintLibRulesPreferReflect);

	var _eslintLibRulesRequireYield = __webpack_require__(360);

	var _eslintLibRulesRequireYield2 = _interopRequireDefault(_eslintLibRulesRequireYield);

	var _eslintLibRulesMaxDepth = __webpack_require__(361);

	var _eslintLibRulesMaxDepth2 = _interopRequireDefault(_eslintLibRulesMaxDepth);

	var _eslintLibRulesMaxLen = __webpack_require__(362);

	var _eslintLibRulesMaxLen2 = _interopRequireDefault(_eslintLibRulesMaxLen);

	var _eslintLibRulesMaxParams = __webpack_require__(363);

	var _eslintLibRulesMaxParams2 = _interopRequireDefault(_eslintLibRulesMaxParams);

	var _eslintLibRulesMaxStatements = __webpack_require__(364);

	var _eslintLibRulesMaxStatements2 = _interopRequireDefault(_eslintLibRulesMaxStatements);

	var _eslintLibRulesNoBitwise = __webpack_require__(365);

	var _eslintLibRulesNoBitwise2 = _interopRequireDefault(_eslintLibRulesNoBitwise);

	var _eslintLibRulesNoPlusplus = __webpack_require__(366);

	var _eslintLibRulesNoPlusplus2 = _interopRequireDefault(_eslintLibRulesNoPlusplus);

	// some notes:
	// - the rule schemas don't contain any information about defaults (not sure if json schema can actually specify this or not)
	// - the docs are also inconsistent with the options/args, some (func-style) not showing info about defaults
	// - the rules are somewhat inconsistent in the way arguments are passed: some use args, options object or both
	// - args naturally aren't named in the schema, so using index but makes hard for boolean as there's no string value to help identify
	// - 'no-restricted-modules' is an odd rule in that it takes n args and specifies the schema different to others,
	//   including the enabled flag (which is left out by all other rules)
	// - 'func-style' specifies no default in the docs, but looks as though it's 'expression' from the source
	// - 'key-spacing' is missing a default for the 'align' property, looks like 'colon' from the source
	// - 'max-nested-callbacks' has no default at all, required argument
	// - 'new-cap' capIsNewExceptions default is not overridable
	// - 'no-mixed-spaces-and-tabs' has 'smart-tabs', true & false for options
	// - 'no-multiple-empty-lines' no default in docs, specified in code
	// - 'no-trailing-spaces' no default in docs, specified in code
	// - 'object-curly-spacing' bool options needed to be determined from code
	// - 'one-var' uses a complex oneOf schema
	// - 'quote-props' uses anyOf
	// - 'id-match' first argument is required
	// - 'no-multi-spaces' uses regex for object props, and has bools nested under 'exceptions' property
	// - 'comma-style' looks like it has a dynamic schema for the exceptions field of the options object
	// - 'indent' dynamic schema
	// - 'space-before-function-paren' has 'oneOf' in the schema
	// - 'generator-star-spacing' also has a 'oneOf' schema

	var requiredArgs = {
	  'max-nested-callbacks': ['0'],
	  'id-match': ['0'],
	  'max-depth': ['0']
	};

	var defaults = {
	  'comma-dangle': {
	    '0': 'never'
	  },
	  'no-cond-assign': {
	    '0': 'except-parens'
	  },
	  'no-extra-parens': {
	    '0': 'all'
	  },
	  'no-inner-declarations': {
	    '0': 'functions'
	  },
	  'accessor-pairs': {
	    'getWithoutSet': false,
	    'setWithoutGet': true
	  },
	  'curly': {
	    '0': 'all'
	  },
	  'dot-notation': {
	    'allowKeywords': true
	  },
	  'dot-location': {
	    '0': 'object'
	  },
	  'no-implicit-coercion': {
	    'boolean': true,
	    'number': true,
	    'string': true
	  },
	  // 'no-multi-spaces': {
	  // 'Property': true,
	  // 'VariableDeclaration': false,
	  // 'ImportDeclaration': false,
	  // },
	  'no-param-reassign': {
	    'props': false
	  },
	  'no-redeclare': {
	    'builtinGoals': false
	  },
	  'no-return-assign': {
	    '0': 'except-parens'
	  },
	  'wrap-iife': {
	    '0': 'outside'
	  },
	  'yoda': {
	    '0': 'never',
	    'exceptRange': false,
	    'onlyEquality': false
	  },
	  'init-declarations': {
	    '0': 'always'
	  },
	  'no-shadow': {
	    'builtinGlobals': false,
	    'hoist': 'functions'
	  },
	  'no-unused-vars': {
	    'vars': 'all',
	    'args': 'after-used'
	  },
	  'no-mixed-requires': {
	    '0': 'false'
	  },
	  'array-bracket-spacing': {
	    '0': 'never'
	  },
	  'brace-style': {
	    '0': '1tbs',
	    'allowSingleLine': false
	  },
	  'camelcase': {
	    'properties': 'always'
	  },
	  'computed-property-spacing': {
	    '0': 'never'
	  },
	  'id-length': {
	    'min': 2
	  },
	  'no-warning-comments': {
	    'terms': ['todo', 'fixme', 'xxx'],
	    'location': 'start'
	  },
	  'comma-spacing': {
	    'before': false,
	    'after': true
	  },
	  'comma-style': {
	    '0': 'last'
	  },
	  'func-style': {
	    '0': 'expression'
	  },
	  'key-spacing': {
	    'beforeColon': false,
	    'afterColon': true,
	    'align': 'colon'
	  },
	  'lines-around-comment': {
	    'beforeBlockComment': true,
	    'afterBlockComment': false,
	    'beforeLineComment': false,
	    'afterLineComment': false,
	    'allowBlockStart': false,
	    'allowBlockEnd': false
	  },
	  'linebreak-style': {
	    '0': 'unix'
	  },
	  'new-cap': {
	    'newIsCap': true,
	    'capIsNew': true,
	    'capIsNewExceptions': ['Array', 'Boolean', 'Date', 'Error', 'Function', 'Number', 'Object', 'RegExp', 'String', 'Symbol']
	  },
	  'no-mixed-spaces-and-tabs': {
	    '0': false
	  },
	  'no-multiple-empty-lines': {
	    'max': 2
	  },
	  'no-trailing-spaces': {
	    'skipBlankLines': false
	  },
	  'object-curly-spacing': {
	    '0': 'never',
	    'arraysInObjects': false,
	    'objectsInObjects': false
	  },
	  'operator-linebreak': {
	    '0': 'after'
	  },
	  'id-match': {
	    'properties': true
	  },
	  'semi-spacing': {
	    'before': false,
	    'after': true
	  },
	  'semi': {
	    '0': 'always'
	  },
	  'sort-vars': {
	    'ignoreCase': false
	  },
	  'space-in-parens': {
	    '0': 'never'
	  },
	  'space-infix-ops': {
	    'int32Hint': false
	  },
	  'space-unary-ops': {
	    'words': true,
	    'nonwords': false
	  },
	  'arrow-parens': {
	    '0': 'always'
	  },
	  'object-shorthand': {
	    '0': 'always'
	  },
	  'max-len': {
	    '0': 80,
	    '1': 4,
	    'ignoreComments': false,
	    'ignoreUrls': false
	  }
	};

	var rules = {

	  // Possible Errors
	  // The following rules point out areas where you might have made mistakes.
	  'Possible Errors': [{
	    'name': 'comma-dangle',
	    'description': 'disallow or enforce trailing commas',
	    'recommended': true,
	    'schema': _eslintLibRulesCommaDangle2['default'].schema
	  }, {
	    'name': 'no-cond-assign',
	    'description': 'disallow assignment in conditional expressions',
	    'recommended': true,
	    'schema': _eslintLibRulesNoCondAssign2['default'].schema
	  }, {
	    'name': 'no-console',
	    'description': 'disallow use of console in the node environment',
	    'recommended': true,
	    'schema': _eslintLibRulesNoConsole2['default'].schema
	  }, {
	    'name': 'no-constant-condition',
	    'description': 'disallow use of constant expressions in conditions',
	    'recommended': true,
	    'schema': _eslintLibRulesNoConstantCondition2['default'].schema
	  }, {
	    'name': 'no-control-regex',
	    'description': 'disallow control characters in regular expressions',
	    'recommended': true,
	    'schema': _eslintLibRulesNoControlRegex2['default'].schema
	  }, {
	    'name': 'no-debugger',
	    'description': 'disallow use of debugger',
	    'recommended': true,
	    'schema': _eslintLibRulesNoDebugger2['default'].schema
	  }, {
	    'name': 'no-dupe-args',
	    'description': 'disallow duplicate arguments in functions',
	    'recommended': true,
	    'schema': _eslintLibRulesNoDupeArgs2['default'].schema
	  }, {
	    'name': 'no-dupe-keys',
	    'description': 'disallow duplicate keys when creating object literals',
	    'recommended': true,
	    'schema': _eslintLibRulesNoDupeKeys2['default'].schema
	  }, {
	    'name': 'no-duplicate-case',
	    'description': 'disallow a duplicate case label.',
	    'recommended': true,
	    'schema': _eslintLibRulesNoDuplicateCase2['default'].schema
	  }, {
	    'name': 'no-empty-character-class',
	    'description': 'disallow the use of empty character classes in regular expressions',
	    'recommended': true,
	    'schema': _eslintLibRulesNoEmptyCharacterClass2['default'].schema
	  }, {
	    'name': 'no-empty',
	    'description': 'disallow empty statements',
	    'recommended': true,
	    'schema': _eslintLibRulesNoEmpty2['default'].schema
	  }, {
	    'name': 'no-ex-assign',
	    'description': 'disallow assigning to the exception in a catch block',
	    'recommended': true,
	    'schema': _eslintLibRulesNoExAssign2['default'].schema
	  }, {
	    'name': 'no-extra-boolean-cast',
	    'description': 'disallow double-negation boolean casts in a boolean context',
	    'recommended': true,
	    'schema': _eslintLibRulesNoExtraBooleanCast2['default'].schema
	  }, {
	    'name': 'no-extra-parens',
	    'description': 'disallow unnecessary parentheses',
	    'recommended': false,
	    'schema': _eslintLibRulesNoExtraParens2['default'].schema
	  }, {
	    'name': 'no-extra-semi',
	    'description': 'disallow unnecessary semicolons',
	    'recommended': true,
	    'schema': _eslintLibRulesNoExtraSemi2['default'].schema
	  }, {
	    'name': 'no-func-assign',
	    'description': 'disallow overwriting functions written as function declarations',
	    'recommended': true,
	    'schema': _eslintLibRulesNoFuncAssign2['default'].schema
	  }, {
	    'name': 'no-inner-declarations',
	    'description': 'disallow function or variable declarations in nested blocks',
	    'recommended': true,
	    'schema': _eslintLibRulesNoInnerDeclarations2['default'].schema
	  }, {
	    'name': 'no-invalid-regexp',
	    'description': 'disallow invalid regular expression strings in the RegExp constructor',
	    'recommended': true,
	    'schema': _eslintLibRulesNoInvalidRegexp2['default'].schema
	  }, {
	    'name': 'no-irregular-whitespace',
	    'description': 'disallow irregular whitespace outside of strings and comments',
	    'recommended': true,
	    'schema': _eslintLibRulesNoIrregularWhitespace2['default'].schema
	  }, {
	    'name': 'no-negated-in-lhs',
	    'description': 'disallow negation of the left operand of an in expression',
	    'recommended': true,
	    'schema': _eslintLibRulesNoNegatedInLhs2['default'].schema
	  }, {
	    'name': 'no-obj-calls',
	    'description': 'disallow the use of object properties of the global object (Math and JSON) as functions',
	    'recommended': true,
	    'schema': _eslintLibRulesNoObjCalls2['default'].schema
	  }, {
	    'name': 'no-regex-spaces',
	    'description': 'disallow multiple spaces in a regular expression literal',
	    'recommended': true,
	    'schema': _eslintLibRulesNoRegexSpaces2['default'].schema
	  }, {
	    'name': 'no-sparse-arrays',
	    'description': 'disallow sparse arrays',
	    'recommended': true,
	    'schema': _eslintLibRulesNoSparseArrays2['default'].schema
	  }, {
	    'name': 'no-unreachable',
	    'description': 'disallow unreachable statements after a return, throw, continue, or break statement',
	    'recommended': true,
	    'schema': _eslintLibRulesNoUnreachable2['default'].schema
	  }, {
	    'name': 'use-isnan',
	    'description': 'disallow comparisons with the value NaN',
	    'recommended': true,
	    'schema': _eslintLibRulesUseIsnan2['default'].schema
	  }, {
	    'name': 'valid-jsdoc',
	    'description': 'Ensure JSDoc comments are valid',
	    'recommended': false,
	    'manualOption': true,
	    'schema': _eslintLibRulesValidJsdoc2['default'].schema
	  }, // TODO options
	  {
	    'name': 'valid-typeof',
	    'description': 'Ensure that the results of typeof are compared against a valid string',
	    'recommended': true,
	    'schema': _eslintLibRulesValidTypeof2['default'].schema
	  }, {
	    'name': 'no-unexpected-multiline',
	    'description': 'Avoid code that looks like two expressions but is actually one',
	    'recommended': false,
	    'schema': _eslintLibRulesNoUnexpectedMultiline2['default'].schema
	  }],

	  // Best Practices
	  // These are rules designed to prevent you from making mistakes. They either prescribe a better way of doing something or help you avoid footguns.
	  'Best Practices': [{
	    'name': 'accessor-pairs',
	    'description': 'Enforces getter/setter pairs in objects',
	    'recommended': false,
	    'schema': _eslintLibRulesAccessorPairs2['default'].schema
	  }, {
	    'name': 'block-scoped-var',
	    'description': 'treat var statements as if they were block scoped',
	    'recommended': false,
	    'schema': _eslintLibRulesBlockScopedVar2['default'].schema
	  }, {
	    'name': 'complexity',
	    'description': 'specify the maximum cyclomatic complexity allowed in a program',
	    'recommended': false,
	    'schema': _eslintLibRulesComplexity2['default'].schema
	  }, {
	    'name': 'consistent-return',
	    'description': 'require return statements to either always or never specify values',
	    'recommended': false,
	    'schema': _eslintLibRulesConsistentReturn2['default'].schema
	  }, {
	    'name': 'curly',
	    'description': 'specify curly brace conventions for all control statements',
	    'recommended': false,
	    'schema': _eslintLibRulesCurly2['default'].schema
	  }, {
	    'name': 'default-case',
	    'description': 'require default case in switch statements',
	    'recommended': false,
	    'schema': _eslintLibRulesDefaultCase2['default'].schema
	  }, {
	    'name': 'dot-notation',
	    'description': 'encourages use of dot notation whenever possible',
	    'recommended': false,
	    'schema': _eslintLibRulesDotNotation2['default'].schema
	  }, {
	    'name': 'dot-location',
	    'description': 'enforces consistent newlines before or after dots',
	    'recommended': false,
	    'schema': _eslintLibRulesDotLocation2['default'].schema
	  }, {
	    'name': 'eqeqeq',
	    'description': 'require the use of === and !==',
	    'recommended': false,
	    'schema': _eslintLibRulesEqeqeq2['default'].schema
	  }, {
	    'name': 'guard-for-in',
	    'description': 'make sure for-in loops have an if statement',
	    'recommended': false,
	    'schema': _eslintLibRulesGuardForIn2['default'].schema
	  }, {
	    'name': 'no-alert',
	    'description': 'disallow the use of alert, confirm, and prompt',
	    'recommended': false,
	    'schema': _eslintLibRulesNoAlert2['default'].schema
	  }, {
	    'name': 'no-caller',
	    'description': 'disallow use of arguments.caller or arguments.callee',
	    'recommended': false,
	    'schema': _eslintLibRulesNoCaller2['default'].schema
	  }, {
	    'name': 'no-div-regex',
	    'description': 'disallow division operators explicitly at beginning of regular expression',
	    'recommended': false,
	    'schema': _eslintLibRulesNoDivRegex2['default'].schema
	  }, {
	    'name': 'no-else-return',
	    'description': 'disallow else after a return in an if',
	    'recommended': false,
	    'schema': _eslintLibRulesNoElseReturn2['default'].schema
	  }, {
	    'name': 'no-empty-label',
	    'description': 'disallow use of labels for anything other than loops and switches',
	    'recommended': false,
	    'schema': _eslintLibRulesNoEmptyLabel2['default'].schema
	  }, {
	    'name': 'no-eq-null',
	    'description': 'disallow comparisons to null without a type-checking operator',
	    'recommended': false,
	    'schema': _eslintLibRulesNoEqNull2['default'].schema
	  }, {
	    'name': 'no-eval',
	    'description': 'disallow use of eval()',
	    'recommended': false,
	    'schema': _eslintLibRulesNoEval2['default'].schema
	  }, {
	    'name': 'no-extend-native',
	    'description': 'disallow adding to native types',
	    'recommended': false,
	    'manualOption': true,
	    'schema': _eslintLibRulesNoExtendNative2['default'].schema
	  }, {
	    'name': 'no-extra-bind',
	    'description': 'disallow unnecessary function binding',
	    'recommended': false,
	    'schema': _eslintLibRulesNoExtraBind2['default'].schema
	  }, {
	    'name': 'no-fallthrough',
	    'description': 'disallow fallthrough of case statements',
	    'recommended': true,
	    'schema': _eslintLibRulesNoFallthrough2['default'].schema
	  }, {
	    'name': 'no-floating-decimal',
	    'description': 'disallow the use of leading or trailing decimal points in numeric literals',
	    'recommended': false,
	    'schema': _eslintLibRulesNoFloatingDecimal2['default'].schema
	  }, {
	    'name': 'no-implicit-coercion',
	    'description': 'disallow the type conversions with shorter notations',
	    'recommended': false,
	    'schema': _eslintLibRulesNoImplicitCoercion2['default'].schema
	  }, {
	    'name': 'no-implied-eval',
	    'description': 'disallow use of eval()-like methods',
	    'recommended': false,
	    'schema': _eslintLibRulesNoImpliedEval2['default'].schema
	  }, {
	    'name': 'no-invalid-this',
	    'description': 'disallow this keywords outside of classes or class-like objects',
	    'recommended': false,
	    'schema': _eslintLibRulesNoInvalidThis2['default'].schema
	  }, {
	    'name': 'no-iterator',
	    'description': 'disallow usage of __iterator__ property',
	    'recommended': false,
	    'schema': _eslintLibRulesNoIterator2['default'].schema
	  }, {
	    'name': 'no-labels',
	    'description': 'disallow use of labeled statements',
	    'recommended': false,
	    'schema': _eslintLibRulesNoLabels2['default'].schema
	  }, {
	    'name': 'no-lone-blocks',
	    'description': 'disallow unnecessary nested blocks',
	    'recommended': false,
	    'schema': _eslintLibRulesNoLoneBlocks2['default'].schema
	  }, {
	    'name': 'no-loop-func',
	    'description': 'disallow creation of functions within loops',
	    'recommended': false,
	    'schema': _eslintLibRulesNoLoopFunc2['default'].schema
	  }, {
	    'name': 'no-multi-spaces',
	    'description': 'disallow use of multiple spaces',
	    'recommended': false,
	    'manualOption': true
	  }, {
	    'name': 'no-multi-str',
	    'description': 'disallow use of multiline strings',
	    'recommended': false,
	    'schema': _eslintLibRulesNoMultiStr2['default'].schema
	  }, {
	    'name': 'no-native-reassign',
	    'description': 'disallow reassignments of native objects',
	    'recommended': false,
	    'manualOption': true,
	    'schema': _eslintLibRulesNoNativeReassign2['default'].schema
	  }, {
	    'name': 'no-new-func',
	    'description': 'disallow use of new operator for Function object',
	    'recommended': false,
	    'schema': _eslintLibRulesNoNewFunc2['default'].schema
	  }, {
	    'name': 'no-new-wrappers',
	    'description': 'disallows creating new instances of String,Number, and Boolean',
	    'recommended': false,
	    'schema': _eslintLibRulesNoNewWrappers2['default'].schema
	  }, {
	    'name': 'no-new',
	    'description': 'disallow use of the new operator when not part of an assignment or comparison',
	    'recommended': false,
	    'schema': _eslintLibRulesNoNew2['default'].schema
	  }, {
	    'name': 'no-octal-escape',
	    'description': 'disallow use of octal escape sequences in string literals, such as var foo = "Copyright \\251";',
	    'recommended': false,
	    'schema': _eslintLibRulesNoOctalEscape2['default'].schema
	  }, {
	    'name': 'no-octal',
	    'description': 'disallow use of octal literals',
	    'recommended': true,
	    'schema': _eslintLibRulesNoOctal2['default'].schema
	  }, {
	    'name': 'no-param-reassign',
	    'description': 'disallow reassignment of function parameters',
	    'recommended': false,
	    'schema': _eslintLibRulesNoParamReassign2['default'].schema
	  }, {
	    'name': 'no-process-env',
	    'description': 'disallow use of process.env',
	    'recommended': false,
	    'schema': _eslintLibRulesNoProcessEnv2['default'].schema
	  }, {
	    'name': 'no-proto',
	    'description': 'disallow usage of __proto__ property',
	    'recommended': false,
	    'schema': _eslintLibRulesNoProto2['default'].schema
	  }, {
	    'name': 'no-redeclare',
	    'description': 'disallow declaring the same variable more than once',
	    'recommended': true,
	    'schema': _eslintLibRulesNoRedeclare2['default'].schema
	  }, {
	    'name': 'no-return-assign',
	    'description': 'disallow use of assignment in return statement',
	    'recommended': false,
	    'schema': _eslintLibRulesNoReturnAssign2['default'].schema
	  }, {
	    'name': 'no-script-url',
	    'description': 'disallow use of javascript: urls.',
	    'recommended': false,
	    'schema': _eslintLibRulesNoScriptUrl2['default'].schema
	  }, {
	    'name': 'no-self-compare',
	    'description': 'disallow comparisons where both sides are exactly the same',
	    'recommended': false,
	    'schema': _eslintLibRulesNoSelfCompare2['default'].schema
	  }, {
	    'name': 'no-sequences',
	    'description': 'disallow use of the comma operator',
	    'recommended': false,
	    'schema': _eslintLibRulesNoSequences2['default'].schema
	  }, {
	    'name': 'no-throw-literal',
	    'description': 'restrict what can be thrown as an exception',
	    'recommended': false,
	    'schema': _eslintLibRulesNoThrowLiteral2['default'].schema
	  }, {
	    'name': 'no-unused-expressions',
	    'description': 'disallow usage of expressions in statement position',
	    'recommended': false,
	    'schema': _eslintLibRulesNoUnusedExpressions2['default'].schema
	  }, {
	    'name': 'no-useless-call',
	    'description': 'disallow unnecessary .call() and .apply()',
	    'recommended': false,
	    'schema': _eslintLibRulesNoUselessCall2['default'].schema
	  }, {
	    'name': 'no-void',
	    'description': 'disallow use of the void operator',
	    'recommended': false,
	    'schema': _eslintLibRulesNoVoid2['default'].schema
	  }, {
	    'name': 'no-warning-comments',
	    'description': 'disallow usage of configurable warning terms in comments - e.g. TODO or FIXME',
	    'recommended': false,
	    'schema': _eslintLibRulesNoWarningComments2['default'].schema
	  }, {
	    'name': 'no-with',
	    'description': 'disallow use of the with statement',
	    'recommended': false,
	    'schema': _eslintLibRulesNoWith2['default'].schema
	  }, {
	    'name': 'radix',
	    'description': 'require use of the second argument for parseInt()',
	    'recommended': false,
	    'schema': _eslintLibRulesRadix2['default'].schema
	  }, {
	    'name': 'vars-on-top',
	    'description': 'require declaration of all vars at the top of their containing scope',
	    'recommended': false,
	    'schema': _eslintLibRulesVarsOnTop2['default'].schema
	  }, {
	    'name': 'wrap-iife',
	    'description': 'require immediate function invocation to be wrapped in parentheses',
	    'recommended': false,
	    'schema': _eslintLibRulesWrapIife2['default'].schema
	  }, {
	    'name': 'yoda',
	    'description': 'require or disallow Yoda conditions',
	    'recommended': false,
	    'schema': _eslintLibRulesYoda2['default'].schema
	  }],

	  // Strict Mode
	  // These rules relate to using strict mode.
	  'Strict Mode': [{
	    'name': 'strict',
	    'description': 'controls location of Use Strict Directives',
	    'recommended': false,
	    'schema': _eslintLibRulesStrict2['default'].schema
	  }],

	  // Variables
	  // These rules have to do with variable declarations.
	  'Variables': [{
	    'name': 'init-declarations',
	    'description': 'enforce or disallow variable initializations at definition',
	    'recommended': false,
	    'schema': _eslintLibRulesInitDeclarations2['default'].schema
	  }, {
	    'name': 'no-catch-shadow',
	    'description': 'disallow the catch clause parameter name being the same as a variable in the outer scope',
	    'recommended': false,
	    'schema': _eslintLibRulesNoCatchShadow2['default'].schema
	  }, {
	    'name': 'no-delete-var',
	    'description': 'disallow deletion of variables',
	    'recommended': true,
	    'schema': _eslintLibRulesNoDeleteVar2['default'].schema
	  }, {
	    'name': 'no-label-var',
	    'description': 'disallow labels that share a name with a variable',
	    'recommended': false,
	    'schema': _eslintLibRulesNoLabelVar2['default'].schema
	  }, {
	    'name': 'no-shadow-restricted-names',
	    'description': 'disallow shadowing of names such as arguments',
	    'recommended': false,
	    'schema': _eslintLibRulesNoShadowRestrictedNames2['default'].schema
	  }, {
	    'name': 'no-shadow',
	    'description': 'disallow declaration of variables already declared in the outer scope',
	    'recommended': false,
	    'schema': _eslintLibRulesNoShadow2['default'].schema
	  }, {
	    'name': 'no-undef-init',
	    'description': 'disallow use of undefined when initializing variables',
	    'recommended': false,
	    'schema': _eslintLibRulesNoUndefInit2['default'].schema
	  }, {
	    'name': 'no-undef',
	    'description': 'disallow use of undeclared variables unless mentioned in a /*global */ block',
	    'recommended': true,
	    'schema': _eslintLibRulesNoUndef2['default'].schema
	  }, {
	    'name': 'no-undefined',
	    'description': 'disallow use of undefined variable',
	    'recommended': false,
	    'schema': _eslintLibRulesNoUndefined2['default'].schema
	  }, {
	    'name': 'no-unused-vars',
	    'description': 'disallow declaration of variables that are not used in the code',
	    'recommended': true,
	    'schema': _eslintLibRulesNoUnusedVars2['default'].schema
	  }, {
	    'name': 'no-use-before-define',
	    'description': 'disallow use of variables before they are defined',
	    'recommended': false,
	    'schema': _eslintLibRulesNoUseBeforeDefine2['default'].schema
	  }],

	  // Node.js
	  // These rules are specific to JavaScript running on Node.js.
	  'Node.js': [{
	    'name': 'callback-return',
	    'description': 'enforce return after a callback',
	    'recommended': false,
	    'schema': _eslintLibRulesCallbackReturn2['default'].schema
	  }, {
	    'name': 'handle-callback-err',
	    'description': 'enforce error handling in callbacks',
	    'recommended': false,
	    'schema': _eslintLibRulesHandleCallbackErr2['default'].schema
	  }, {
	    'name': 'no-mixed-requires',
	    'description': 'disallow mixing regular variable and require declarations',
	    'recommended': false,
	    'schema': _eslintLibRulesNoMixedRequires2['default'].schema
	  }, {
	    'name': 'no-new-require',
	    'description': 'disallow use of new operator with the require function',
	    'recommended': false,
	    'schema': _eslintLibRulesNoNewRequire2['default'].schema
	  }, {
	    'name': 'no-path-concat',
	    'description': 'disallow string concatenation with __dirname and __filename',
	    'recommended': false,
	    'schema': _eslintLibRulesNoPathConcat2['default'].schema
	  }, {
	    'name': 'no-process-exit',
	    'description': 'disallow process.exit()',
	    'recommended': false,
	    'schema': _eslintLibRulesNoProcessExit2['default'].schema
	  }, {
	    'name': 'no-restricted-modules',
	    'description': 'restrict usage of specified node modules',
	    'recommended': false,
	    'manualOption': true,
	    'schema': _eslintLibRulesNoRestrictedModules2['default'].schema
	  }, // TODO options
	  {
	    'name': 'no-sync',
	    'description': 'disallow use of synchronous methods',
	    'recommended': false,
	    'schema': _eslintLibRulesNoSync2['default'].schema
	  }],

	  // Stylistic Issues
	  // These rules are purely matters of style and are quite subjective.
	  'Stylistic Issues': [{
	    'name': 'array-bracket-spacing',
	    'description': 'enforce spacing inside array brackets',
	    'recommended': false,
	    'schema': _eslintLibRulesArrayBracketSpacing2['default'].schema
	  }, {
	    'name': 'brace-style',
	    'description': 'enforce one true brace style',
	    'recommended': false,
	    'schema': _eslintLibRulesBraceStyle2['default'].schema
	  }, {
	    'name': 'camelcase',
	    'description': 'require camel case names',
	    'recommended': false,
	    'schema': _eslintLibRulesCamelcase2['default'].schema
	  }, {
	    'name': 'comma-spacing',
	    'description': 'enforce spacing before and after comma',
	    'recommended': false,
	    'schema': _eslintLibRulesCommaSpacing2['default'].schema
	  }, {
	    'name': 'comma-style',
	    'description': 'enforce one true comma style',
	    'recommended': false,
	    'manualOption': true,
	    'schema': _eslintLibRulesCommaStyle2['default'].schema
	  }, {
	    'name': 'computed-property-spacing',
	    'description': 'require or disallow padding inside computed properties',
	    'recommended': false,
	    'schema': _eslintLibRulesComputedPropertySpacing2['default'].schema
	  }, {
	    'name': 'consistent-this',
	    'description': 'enforce consistent naming when capturing the current execution context',
	    'recommended': false,
	    'schema': _eslintLibRulesConsistentThis2['default'].schema
	  }, {
	    'name': 'eol-last',
	    'description': 'enforce newline at the end of file, with no multiple empty lines',
	    'recommended': false,
	    'schema': _eslintLibRulesEolLast2['default'].schema
	  }, {
	    'name': 'func-names',
	    'description': 'require function expressions to have a name',
	    'recommended': false,
	    'schema': _eslintLibRulesFuncNames2['default'].schema
	  }, {
	    'name': 'func-style',
	    'description': 'enforce use of function declarations or expressions',
	    'recommended': false,
	    'schema': _eslintLibRulesFuncStyle2['default'].schema
	  }, {
	    'name': 'id-length',
	    'description': 'this option enforces minimum and maximum identifier lengths (variable names, property names etc.) (off by default)',
	    'recommended': false,
	    'schema': _eslintLibRulesIdLength2['default'].schema
	  }, {
	    'name': 'indent',
	    'description': 'specify tab or space width for your code',
	    'recommended': false,
	    'manualOption': true,
	    'schema': _eslintLibRulesIndent2['default'].schema
	  }, {
	    'name': 'key-spacing',
	    'description': 'enforce spacing between keys and values in object literal properties',
	    'recommended': false,
	    'schema': _eslintLibRulesKeySpacing2['default'].schema
	  }, {
	    'name': 'lines-around-comment',
	    'description': 'enforce empty lines around comments',
	    'recommended': false,
	    'schema': _eslintLibRulesLinesAroundComment2['default'].schema
	  }, {
	    'name': 'linebreak-style',
	    'description': 'disallow mixed \'LF\' and \'CRLF\' as linebreaks',
	    'recommended': false,
	    'schema': _eslintLibRulesLinebreakStyle2['default'].schema
	  }, {
	    'name': 'max-nested-callbacks',
	    'description': 'specify the maximum depth callbacks can be nested',
	    'recommended': false,
	    'schema': _eslintLibRulesMaxNestedCallbacks2['default'].schema
	  }, {
	    'name': 'new-cap',
	    'description': 'require a capital letter for constructors',
	    'recommended': false,
	    'schema': _eslintLibRulesNewCap2['default'].schema
	  }, {
	    'name': 'new-parens',
	    'description': 'disallow the omission of parentheses when invoking a constructor with no arguments',
	    'recommended': false,
	    'schema': _eslintLibRulesNewParens2['default'].schema
	  }, {
	    'name': 'newline-after-var',
	    'description': 'require or disallow an empty newline after variable declarations',
	    'recommended': false,
	    'schema': _eslintLibRulesNewlineAfterVar2['default'].schema
	  }, {
	    'name': 'no-array-constructor',
	    'description': 'disallow use of the Array constructor',
	    'recommended': false,
	    'schema': _eslintLibRulesNoArrayConstructor2['default'].schema
	  }, {
	    'name': 'no-continue',
	    'description': 'disallow use of the continue statement',
	    'recommended': false,
	    'schema': _eslintLibRulesNoContinue2['default'].schema
	  }, {
	    'name': 'no-inline-comments',
	    'description': 'disallow comments inline after code',
	    'recommended': false,
	    'schema': _eslintLibRulesNoInlineComments2['default'].schema
	  }, {
	    'name': 'no-lonely-if',
	    'description': 'disallow if as the only statement in an else block',
	    'recommended': false,
	    'schema': _eslintLibRulesNoLonelyIf2['default'].schema
	  }, {
	    'name': 'no-mixed-spaces-and-tabs',
	    'description': 'disallow mixed spaces and tabs for indentation',
	    'recommended': true,
	    'schema': _eslintLibRulesNoMixedSpacesAndTabs2['default'].schema
	  }, {
	    'name': 'no-multiple-empty-lines',
	    'description': 'disallow multiple empty lines',
	    'recommended': false,
	    'schema': _eslintLibRulesNoMultipleEmptyLines2['default'].schema
	  }, {
	    'name': 'no-nested-ternary',
	    'description': 'disallow nested ternary expressions',
	    'recommended': false,
	    'schema': _eslintLibRulesNoNestedTernary2['default'].schema
	  }, {
	    'name': 'no-new-object',
	    'description': 'disallow the use of the Object constructor',
	    'recommended': false,
	    'schema': _eslintLibRulesNoNewObject2['default'].schema
	  }, {
	    'name': 'no-spaced-func',
	    'description': 'disallow space between function identifier and application',
	    'recommended': false,
	    'schema': _eslintLibRulesNoSpacedFunc2['default'].schema
	  }, {
	    'name': 'no-ternary',
	    'description': 'disallow the use of ternary operators',
	    'recommended': false,
	    'schema': _eslintLibRulesNoTernary2['default'].schema
	  }, {
	    'name': 'no-trailing-spaces',
	    'description': 'disallow trailing whitespace at the end of lines',
	    'recommended': false,
	    'schema': _eslintLibRulesNoTrailingSpaces2['default'].schema
	  }, {
	    'name': 'no-underscore-dangle',
	    'description': 'disallow dangling underscores in identifiers',
	    'recommended': false,
	    'schema': _eslintLibRulesNoUnderscoreDangle2['default'].schema
	  }, {
	    'name': 'no-unneeded-ternary',
	    'description': 'disallow the use of Boolean literals in conditional expressions',
	    'recommended': false,
	    'schema': _eslintLibRulesNoUnneededTernary2['default'].schema
	  }, {
	    'name': 'object-curly-spacing',
	    'description': 'require or disallow padding inside curly braces',
	    'recommended': false,
	    'schema': _eslintLibRulesObjectCurlySpacing2['default'].schema
	  }, {
	    'name': 'one-var',
	    'description': 'require or disallow one variable declaration per function',
	    'recommended': false,
	    'schema': _eslintLibRulesOneVar2['default'].schema,
	    'manualOption': true
	  }, // TODO options
	  {
	    'name': 'operator-assignment',
	    'description': 'require assignment operator shorthand where possible or prohibit it entirely',
	    'recommended': false,
	    'schema': _eslintLibRulesOperatorAssignment2['default'].schema
	  }, {
	    'name': 'operator-linebreak',
	    'description': 'enforce operators to be placed before or after line breaks',
	    'recommended': false,
	    'schema': _eslintLibRulesOperatorLinebreak2['default'].schema
	  }, {
	    'name': 'padded-blocks',
	    'description': 'enforce padding within blocks',
	    'recommended': false,
	    'schema': _eslintLibRulesPaddedBlocks2['default'].schema
	  }, {
	    'name': 'quote-props',
	    'description': 'require quotes around object literal property names',
	    'recommended': false,
	    'schema': _eslintLibRulesQuoteProps2['default'].schema,
	    'manualOption': true
	  }, // TODO options
	  {
	    'name': 'quotes',
	    'description': 'specify whether backticks, double or single quotes should be used',
	    'recommended': false,
	    'schema': _eslintLibRulesQuotes2['default'].schema
	  }, {
	    'name': 'id-match',
	    'description': 'require identifiers to match the provided regular expression',
	    'recommended': false,
	    'schema': _eslintLibRulesIdMatch2['default'].schema
	  }, {
	    'name': 'semi-spacing',
	    'description': 'enforce spacing before and after semicolons',
	    'recommended': false,
	    'schema': _eslintLibRulesSemiSpacing2['default'].schema
	  }, {
	    'name': 'semi',
	    'description': 'require or disallow use of semicolons instead of ASI',
	    'recommended': false,
	    'schema': _eslintLibRulesSemi2['default'].schema
	  }, {
	    'name': 'sort-vars',
	    'description': 'sort variables within the same declaration block',
	    'recommended': false,
	    'schema': _eslintLibRulesSortVars2['default'].schema
	  }, {
	    'name': 'space-after-keywords',
	    'description': 'require a space after certain keywords',
	    'recommended': false,
	    'schema': _eslintLibRulesSpaceAfterKeywords2['default'].schema
	  }, {
	    'name': 'space-before-blocks',
	    'description': 'require or disallow a space before blocks',
	    'recommended': false,
	    'schema': _eslintLibRulesSpaceBeforeBlocks2['default'].schema
	  }, {
	    'name': 'space-before-function-paren',
	    'description': 'require or disallow a space before function opening parenthesis',
	    'recommended': false,
	    'manualOption': true,
	    'schema': _eslintLibRulesSpaceBeforeFunctionParen2['default'].schema
	  }, {
	    'name': 'space-in-parens',
	    'description': 'require or disallow spaces inside parentheses',
	    'recommended': false,
	    'schema': _eslintLibRulesSpaceInParens2['default'].schema
	  }, {
	    'name': 'space-infix-ops',
	    'description': 'require spaces around operators',
	    'recommended': false,
	    'schema': _eslintLibRulesSpaceInfixOps2['default'].schema
	  }, {
	    'name': 'space-return-throw-case',
	    'description': 'require a space after return, throw, and case',
	    'recommended': false,
	    'schema': _eslintLibRulesSpaceReturnThrowCase2['default'].schema
	  }, {
	    'name': 'space-unary-ops',
	    'description': 'require or disallow spaces before/after unary operators',
	    'recommended': false,
	    'schema': _eslintLibRulesSpaceUnaryOps2['default'].schema
	  }, {
	    'name': 'spaced-comment',
	    'description': 'require or disallow a space immediately following the // or /* in a comment',
	    'recommended': false,
	    'schema': _eslintLibRulesSpacedComment2['default'].schema
	  }, {
	    'name': 'wrap-regex',
	    'description': 'require regex literals to be wrapped in parentheses',
	    'recommended': false,
	    'schema': _eslintLibRulesWrapRegex2['default'].schema
	  }],

	  // ECMAScript 6
	  // These rules are only relevant to ES6 environments.
	  'ECMAScript 6': [{
	    'name': 'arrow-parens',
	    'description': 'require parens in arrow function arguments',
	    'recommended': false,
	    'schema': _eslintLibRulesArrowParens2['default'].schema
	  }, {
	    'name': 'arrow-spacing',
	    'description': 'require space before/after arrow function\'s arrow',
	    'recommended': false,
	    'schema': _eslintLibRulesArrowSpacing2['default'].schema
	  }, {
	    'name': 'constructor-super',
	    'description': 'verify calls of super() in constructors',
	    'recommended': false,
	    'schema': _eslintLibRulesConstructorSuper2['default'].schema
	  }, {
	    'name': 'generator-star-spacing',
	    'description': 'enforce spacing around the * in generator functions',
	    'recommended': false,
	    'manualOption': true,
	    'schema': _eslintLibRulesGeneratorStarSpacing2['default'].schema
	  }, {
	    'name': 'no-class-assign',
	    'description': 'disallow modifying variables of class declarations',
	    'recommended': false,
	    'schema': _eslintLibRulesNoClassAssign2['default'].schema
	  }, {
	    'name': 'no-const-assign',
	    'description': 'disallow modifying variables that are declared using const',
	    'recommended': false,
	    'schema': _eslintLibRulesNoConstAssign2['default'].schema
	  }, {
	    'name': 'no-this-before-super',
	    'description': 'disallow use of this/super before calling super() in constructors.',
	    'recommended': false,
	    'schema': _eslintLibRulesNoThisBeforeSuper2['default'].schema
	  }, {
	    'name': 'no-var',
	    'description': 'require let or const instead of var',
	    'recommended': false,
	    'schema': _eslintLibRulesNoVar2['default'].schema
	  }, {
	    'name': 'object-shorthand',
	    'description': 'require method and property shorthand syntax for object literals',
	    'recommended': false,
	    'schema': _eslintLibRulesObjectShorthand2['default'].schema
	  }, {
	    'name': 'prefer-const',
	    'description': 'suggest using const declaration for variables that are never modified after declared',
	    'recommended': false,
	    'schema': _eslintLibRulesPreferConst2['default'].schema
	  }, {
	    'name': 'prefer-spread',
	    'description': 'suggest using the spread operator instead of .apply().',
	    'recommended': false,
	    'schema': _eslintLibRulesPreferSpread2['default'].schema
	  }, {
	    'name': 'prefer-reflect',
	    'description': 'suggest using Reflect methods where applicable',
	    'recommended': false,
	    'schema': _eslintLibRulesPreferReflect2['default'].schema
	  }, {
	    'name': 'require-yield',
	    'description': 'disallow generator functions that do not have yield',
	    'recommended': false,
	    'schema': _eslintLibRulesRequireYield2['default'].schema
	  }],

	  // Legacy
	  // The following rules are included for compatibility with JSHint and JSLint. While the names of the rules may not match up with the JSHint/JSLint counterpart, the functionality is the same.
	  'Legacy': [{
	    'name': 'max-depth',
	    'description': 'specify the maximum depth that blocks can be nested',
	    'recommended': false,
	    'schema': _eslintLibRulesMaxDepth2['default'].schema
	  }, {
	    'name': 'max-len',
	    'description': 'specify the maximum length of a line in your program',
	    'recommended': false,
	    'schema': _eslintLibRulesMaxLen2['default'].schema
	  }, {
	    'name': 'max-params',
	    'description': 'limits the number of parameters that can be used in the function declaration.',
	    'recommended': false,
	    'schema': _eslintLibRulesMaxParams2['default'].schema
	  }, {
	    'name': 'max-statements',
	    'description': 'specify the maximum number of statement allowed in a function',
	    'recommended': false,
	    'schema': _eslintLibRulesMaxStatements2['default'].schema
	  }, {
	    'name': 'no-bitwise',
	    'description': 'disallow use of bitwise operators',
	    'recommended': false,
	    'schema': _eslintLibRulesNoBitwise2['default'].schema
	  }, {
	    'name': 'no-plusplus',
	    'description': 'disallow use of unary operators, ++ and --',
	    'recommended': false,
	    'schema': _eslintLibRulesNoPlusplus2['default'].schema
	  }]

	};

	_lodash2['default'].each(defaults, function (defaultValues, name) {
	  _lodash2['default'].each(rules, function (categoryRules, category) {
	    var found = false;
	    var rv = _lodash2['default'].each(categoryRules, function (rule) {
	      if (rule.name == name) {
	        rule.defaultValues = defaultValues;
	        found = true;
	        return false;
	      }
	    });
	    return !found;
	  });
	});

	exports['default'] = rules;
	module.exports = exports['default'];
	// 'args': [{
	// 'type': 'string',
	// 'default': 'never',
	// 'args': ['always', 'always-multiline', 'never'],
	// }],
	// 'args': [{
	//   'type': 'string',
	//   'default': 'except-parens',
	//   'enum': ['except-parens', 'always'],
	// }],
	// 'args': [{
	//   'type': 'string',
	//   'default': 'all',
	//   'enum': ['all', 'functions'],
	// }],
	// 'args': [{
	//   'type': 'string',
	//   'default': 'functions',
	//   'values': ['functions', 'both'],
	// }],
	//'args': {
	//'bools': ['requireReturn', 'requireParamDescription', 'requireParamDescription'],
	//},
	// 'args': [{
	//   'type': 'object',
	//   'properties': {
	//     'getWithoutSet': {
	//       'type': 'boolean',
	//       'default': false,
	//     },
	//     'setWithoutGet': {
	//       'type': 'boolean',
	//       'default': true,
	//     },
	//   },
	// }],
	// 'args': [{
	//   'type': 'string',
	//   'default': 'all',
	//   'enum': ['all', 'multi', 'multi-line', 'multi-or-nest'],
	// }],
	// 'args': [{
	//   'type': 'object',
	//   'properties': {
	//     'allowKeywords': {
	//       'type': 'boolean',
	//       'default': true,
	//     },
	//     'allowPattern': {
	//       'type': 'string', // is there a regex type?
	//     },
	//   },
	// }],
	// 'args': [{
	//   'type': 'string',
	//   'default': 'object',
	//   'enum': ['object', 'property'],
	// }],
	// 'args': [{
	//   'type': 'string',
	//   'values': ['smart', 'allow-null'],
	// }],
	// 'args': {
	//   'type': 'object',
	//   'properties': {
	//     'exceptions': {
	//       'type': 'array',
	//       'items': {
	//         'type': 'string',
	//       },
	//     },
	//   },
	// },
	// 'args': [{
	//   'type': 'object',
	//   'properties': {
	//     'boolean': {
	//       'type': 'boolean',
	//       'default': true,
	//     },
	//     'number': {
	//       'type': 'boolean',
	//       'default': true,
	//     },
	//     'string': {
	//       'type': 'boolean',
	//       'default': true,
	//     },
	//   }
	// }],
	// 'schema': noMultiSpaces.schema,
	// 'args': [{
	//   'type': 'object',
	//   'properties': {
	//     'Property': {
	//       'type': 'boolean',
	//       'default': true,
	//     },
	//     'VariableDeclaration': {
	//       'type': 'boolean',
	//       'default': false,
	//     },
	//     'ImportDeclaration': {
	//       'type': 'boolean',
	//       'default': false,
	//     },
	//   },
	// }],
	// 'args': {
	//   'type': 'object',
	//   'properties': {
	//     'exceptions': {
	//       'type': 'array',
	//       'items': {
	//         'type': 'string',
	//       },
	//     },
	//   },
	// },
	// 'args': [{
	//   'type': 'object',
	//   'properties': {
	//     'props': {
	//       'type': 'boolean',
	//       'default': false,
	//     },
	//   },
	// }],
	// 'args': [{
	//   'type': 'object',
	//   'properties': {
	//     'builtinGlobals': {
	//       'type': 'boolean',
	//       'default': false,
	//     },
	//   },
	// }],
	// 'args': [{
	//   'type': 'string',
	//   'default': 'except-parens',
	//   'enum': ['always', 'except-parens'],
	// }],
	// 'args': [{
	//   'type': 'string',
	//   'default': 'outside',
	//   'enum': ['outside', 'inside', 'any'],
	// }],
	// 'args': [{
	//   'type': 'string',
	//   'enum': ['never', 'always'],
	//   'default': 'never',
	// }, {
	//   'type': 'object',
	//   'properties': {
	//     'exceptRange': {
	//       'type': 'boolean',
	//       'default': false,
	//     },
	//     'onlyEquality': {
	//       'type': 'boolean',
	//       'default': false,
	//     },
	//   },
	// }],
	// 'args': [{
	//   'type': 'string',
	//   'default': 'always',
	//   'enum': ['always', 'never'],
	// }],
	// 'args': [{
	//   'type': 'object',
	//   'properties': {
	//     'builtinGlobals': {
	//       'type': 'boolean',
	//       'default': false,
	//     },
	//     'hoist': {
	//       'type': 'string',
	//       'enum': ['all', 'functions', 'never'],
	//       'default': 'functions',
	//     },
	//   },
	// }],
	// 'args': [{
	//   'type': 'object',
	//   'properties': {
	//     'vars': {
	//       'type': 'string',
	//       'enum': ['all', 'local'],
	//       'default': 'all',
	//     },
	//     'args': {
	//       'type': 'string',
	//       'enum': ['all', 'after-used', 'none'],
	//       'default': 'after-used',
	//     },
	//   },
	// }],
	// 'args': [{
	//   'type': 'array',
	//   'items': {
	//     'type': 'string',
	//   },
	// }],
	// 'args': [{
	//   'type': 'boolean',
	//   'default': false,
	// }],
	// 'args': [{
	//   'type': 'string',
	//   'enum': ['never', 'always'],
	//   'default': 'never',
	// }, {
	//   'type': 'object',
	//   // the defaults here depend on the first setting
	//   'properties': {
	//     'singleValue': {
	//       'type': 'boolean',
	//     },
	//     'objectsInArrays': {
	//       'type': 'boolean',
	//     },
	//     'arraysInArrays': {
	//       'type': 'boolean',
	//     },
	//   },
	// }],
	// 'args': [{
	//   'type': 'string',
	//   'enum': ['1tbs', 'stroustrup'],
	//   'default': '1tbs',
	// }, {
	//   'type': 'object',
	//   'properties': {
	//     'allowSingleLine': {
	//       'type': 'boolean',
	//       'default': false,
	//     },
	//   },
	// }],
	// 'args': [{
	//   'type': 'object',
	//   'properties': {
	//     'properties': {
	//       'enum': ['always', 'never'],
	//       'default': 'always'
	//     },
	//   },
	// }],
	// 'args': [{
	//   'type': 'string',
	//   'enum': ['never', 'always'],
	//   'default': 'never',
	// }],
	// 'args': [{
	//   'type': 'string',
	// }],
	// 'args': [{
	//   'type': 'string',
	//   'enum': ['declaration', 'expression'],
	//   // required?
	// }],
	// 'args': [{
	//   'type': 'object',
	//   'properties': {
	//     'min': {
	//       'type': 'integer',
	//       'default': 2,
	//     },
	//     'max': {
	//       'type': 'integer',
	//     },
	//     'exceptions': {
	//       'type': 'array',
	//       'items': {
	//         'type': 'string',
	//       },
	//     },
	//   },
	// }],
	// 'args': [{
	//   'oneOf': [
	//     {'type': 'string', 'enum': 'tab'},
	//     {'type': 'integer'},
	//   ],
	// }, {
	//   'type': 'object',

	// }]

/***/ },
/* 164 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag labels that are the same as an identifier
	 * @author Ian Christian Myers
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    //--------------------------------------------------------------------------
	    // Helpers
	    //--------------------------------------------------------------------------

	    function findIdentifier(scope, identifier) {
	        var found = false;

	        scope.variables.forEach(function(variable) {
	            if (variable.name === identifier) {
	                found = true;
	            }
	        });

	        scope.references.forEach(function(reference) {
	            if (reference.identifier.name === identifier) {
	                found = true;
	            }
	        });

	        // If we have not found the identifier in this scope, check the parent
	        // scope.
	        if (scope.upper && !found) {
	            return findIdentifier(scope.upper, identifier);
	        }

	        return found;
	    }

	    //--------------------------------------------------------------------------
	    // Public API
	    //--------------------------------------------------------------------------

	    return {

	        "LabeledStatement": function(node) {

	            // Fetch the innermost scope.
	            var scope = context.getScope();

	            // Recursively find the identifier walking up the scope, starting
	            // with the innermost scope.
	            if (findIdentifier(scope, node.label.name)) {
	                context.report(node, "Found identifier with same name as label.");
	            }
	        }

	    };

	};

	module.exports.schema = [];


/***/ },
/* 165 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to forbid or enforce dangling commas.
	 * @author Ian Christian Myers
	 * @copyright 2015 Mathias Schreck
	 * @copyright 2013 Ian Christian Myers
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {
	    var allowDangle = context.options[0];
	    var forbidDangle = allowDangle !== "always-multiline" && allowDangle !== "always";
	    var UNEXPECTED_MESSAGE = "Unexpected trailing comma.";
	    var MISSING_MESSAGE = "Missing trailing comma.";

	    /**
	     * Checks the given node for trailing comma and reports violations.
	     * @param {ASTNode} node The node of an ObjectExpression or ArrayExpression
	     * @returns {void}
	     */
	    function checkForTrailingComma(node) {
	        var items = node.properties || node.elements,
	            length = items.length,
	            lastTokenOnNewLine,
	            lastItem,
	            penultimateToken,
	            hasDanglingComma;

	        if (length) {
	            lastItem = items[length - 1];
	            if (lastItem) {
	                penultimateToken = context.getLastToken(node, 1);
	                hasDanglingComma = penultimateToken.value === ",";

	                if (forbidDangle && hasDanglingComma) {
	                    context.report(lastItem, penultimateToken.loc.start, UNEXPECTED_MESSAGE);
	                } else if (allowDangle === "always-multiline") {
	                    lastTokenOnNewLine = node.loc.end.line !== penultimateToken.loc.end.line;
	                    if (hasDanglingComma && !lastTokenOnNewLine) {
	                        context.report(lastItem, penultimateToken.loc.start, UNEXPECTED_MESSAGE);
	                    } else if (!hasDanglingComma && lastTokenOnNewLine) {
	                        context.report(lastItem, penultimateToken.loc.end, MISSING_MESSAGE);
	                    }
	                } else if (allowDangle === "always" && !hasDanglingComma) {
	                    context.report(lastItem, lastItem.loc.end, MISSING_MESSAGE);
	                }
	            }
	        }
	    }

	    return {
	        "ObjectExpression": checkForTrailingComma,
	        "ObjectPattern": checkForTrailingComma,
	        "ArrayExpression": checkForTrailingComma,
	        "ArrayPattern": checkForTrailingComma
	    };
	};

	module.exports.schema = [
	    {
	        "enum": ["always", "always-multiline", "never"]
	    }
	];


/***/ },
/* 166 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag assignment in a conditional statement's test expression
	 * @author Stephen Murray <spmurrayzzz>
	 */
	"use strict";

	var NODE_DESCRIPTIONS = {
	    "DoWhileStatement": "a 'do...while' statement",
	    "ForStatement": "a 'for' statement",
	    "IfStatement": "an 'if' statement",
	    "WhileStatement": "a 'while' statement"
	};

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var prohibitAssign = (context.options[0] || "except-parens");

	    /**
	     * Check whether an AST node is the test expression for a conditional statement.
	     * @param {!Object} node The node to test.
	     * @returns {boolean} `true` if the node is the text expression for a conditional statement; otherwise, `false`.
	     */
	    function isConditionalTestExpression(node) {
	        return node.parent &&
	            node.parent.test &&
	            node === node.parent.test;
	    }

	    /**
	     * Given an AST node, perform a bottom-up search for the first ancestor that represents a conditional statement.
	     * @param {!Object} node The node to use at the start of the search.
	     * @returns {?Object} The closest ancestor node that represents a conditional statement.
	     */
	    function findConditionalAncestor(node) {
	        var currentAncestor = node;

	        do {
	            if (isConditionalTestExpression(currentAncestor)) {
	                return currentAncestor.parent;
	            }
	        } while ((currentAncestor = currentAncestor.parent));

	        return null;
	    }

	    /**
	     * Check whether the code represented by an AST node is enclosed in parentheses.
	     * @param {!Object} node The node to test.
	     * @returns {boolean} `true` if the code is enclosed in parentheses; otherwise, `false`.
	     */
	    function isParenthesised(node) {
	        var previousToken = context.getTokenBefore(node),
	            nextToken = context.getTokenAfter(node);

	        return previousToken.value === "(" && previousToken.range[1] <= node.range[0] &&
	            nextToken.value === ")" && nextToken.range[0] >= node.range[1];
	    }

	    /**
	     * Check whether the code represented by an AST node is enclosed in two sets of parentheses.
	     * @param {!Object} node The node to test.
	     * @returns {boolean} `true` if the code is enclosed in two sets of parentheses; otherwise, `false`.
	     */
	    function isParenthesisedTwice(node) {
	        var previousToken = context.getTokenBefore(node, 1),
	            nextToken = context.getTokenAfter(node, 1);

	        return isParenthesised(node) &&
	            previousToken.value === "(" && previousToken.range[1] <= node.range[0] &&
	            nextToken.value === ")" && nextToken.range[0] >= node.range[1];
	    }

	    /**
	     * Check a conditional statement's test expression for top-level assignments that are not enclosed in parentheses.
	     * @param {!Object} node The node for the conditional statement.
	     * @returns {void}
	     */
	    function testForAssign(node) {
	        if (node.test && (node.test.type === "AssignmentExpression") && !isParenthesisedTwice(node.test)) {
	            // must match JSHint's error message
	            context.report(node, "Expected a conditional expression and instead saw an assignment.");
	        }
	    }

	    /**
	     * Check whether an assignment expression is descended from a conditional statement's test expression.
	     * @param {!Object} node The node for the assignment expression.
	     * @returns {void}
	     */
	    function testForConditionalAncestor(node) {
	        var ancestor = findConditionalAncestor(node);

	        if (ancestor) {
	            context.report(ancestor, "Unexpected assignment within {{type}}.", {
	                type: NODE_DESCRIPTIONS[ancestor.type] || ancestor.type
	            });
	        }
	    }

	    if (prohibitAssign === "always") {
	        return {
	            "AssignmentExpression": testForConditionalAncestor
	        };
	    }

	    return {
	        "DoWhileStatement": testForAssign,
	        "ForStatement": testForAssign,
	        "IfStatement": testForAssign,
	        "WhileStatement": testForAssign
	    };

	};

	module.exports.schema = [
	    {
	        "enum": ["except-parens", "always"]
	    }
	];


/***/ },
/* 167 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag use of console object
	 * @author Nicholas C. Zakas
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {

	        "MemberExpression": function(node) {

	            if (node.object.name === "console") {
	                context.report(node, "Unexpected console statement.");
	            }

	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 168 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag use constant conditions
	 * @author Christian Schulz <http://rndm.de>
	 * @copyright 2014 Christian Schulz. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    //--------------------------------------------------------------------------
	    // Helpers
	    //--------------------------------------------------------------------------

	    /**
	     * Checks if a node has a constant truthiness value.
	     * @param {ASTNode} node The AST node to check.
	     * @returns {Bool} true when node's truthiness is constant
	     * @private
	     */
	    function isConstant(node) {
	        switch (node.type) {
	            case "Literal":
	            case "ArrowFunctionExpression":
	            case "FunctionExpression":
	            case "ObjectExpression":
	            case "ArrayExpression":
	                return true;
	            case "UnaryExpression":
	                return isConstant(node.argument);
	            case "BinaryExpression":
	            case "LogicalExpression":
	                return isConstant(node.left) && isConstant(node.right);
	            case "AssignmentExpression":
	                return (node.operator === "=") && isConstant(node.right);
	            case "SequenceExpression":
	                return isConstant(node.expressions[node.expressions.length - 1]);
	            // no default
	        }
	        return false;
	    }

	    /**
	     * Reports when the given node contains a constant condition.
	     * @param {ASTNode} node The AST node to check.
	     * @returns {void}
	     * @private
	     */
	    function checkConstantCondition(node) {
	        if (node.test && isConstant(node.test)) {
	            context.report(node, "Unexpected constant condition.");
	        }
	    }

	    //--------------------------------------------------------------------------
	    // Public
	    //--------------------------------------------------------------------------

	    return {
	        "ConditionalExpression": checkConstantCondition,
	        "IfStatement": checkConstantCondition,
	        "WhileStatement": checkConstantCondition,
	        "DoWhileStatement": checkConstantCondition,
	        "ForStatement": checkConstantCondition
	    };

	};

	module.exports.schema = [];


/***/ },
/* 169 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to forbid control charactes from regular expressions.
	 * @author Nicholas C. Zakas
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    function getRegExp(node) {

	        if (node.value instanceof RegExp) {
	            return node.value;
	        } else if (typeof node.value === "string") {

	            var parent = context.getAncestors().pop();
	            if ((parent.type === "NewExpression" || parent.type === "CallExpression") &&
	            parent.callee.type === "Identifier" && parent.callee.name === "RegExp") {

	                // there could be an invalid regular expression string
	                try {
	                    return new RegExp(node.value);
	                } catch (ex) {
	                    return null;
	                }

	            }
	        } else {
	            return null;
	        }

	    }



	    return {

	        "Literal": function(node) {

	            var computedValue,
	                regex = getRegExp(node);

	            if (regex) {
	                computedValue = regex.toString();
	                if (/[\x00-\x1f]/.test(computedValue)) {
	                    context.report(node, "Unexpected control character in regular expression.");
	                }
	            }
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 170 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag use of a debugger statement
	 * @author Nicholas C. Zakas
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {
	        "DebuggerStatement": function(node) {
	            context.report(node, "Unexpected 'debugger' statement.");
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 171 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag duplicate arguments
	 * @author Jamund Ferguson
	 * @copyright 2015 Jamund Ferguson. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    //--------------------------------------------------------------------------
	    // Helpers
	    //--------------------------------------------------------------------------

	    /**
	     * Determines if a given node has duplicate parameters.
	     * @param {ASTNode} node The node to check.
	     * @returns {void}
	     * @private
	     */
	    function checkParams(node) {
	        var params = {},
	            dups = {};


	        /**
	         * Marks a given param as either seen or duplicated.
	         * @param {string} name The name of the param to mark.
	         * @returns {void}
	         * @private
	         */
	        function markParam(name) {
	            if (params.hasOwnProperty(name)) {
	                dups[name] = 1;
	            } else {
	                params[name] = 1;
	            }
	        }

	        // loop through and find each duplicate param
	        node.params.forEach(function(param) {

	            switch (param.type) {
	                case "Identifier":
	                    markParam(param.name);
	                    break;

	                case "ObjectPattern":
	                    param.properties.forEach(function(property) {
	                        markParam(property.key.name);
	                    });
	                    break;

	                case "ArrayPattern":
	                    param.elements.forEach(function(element) {

	                        // Arrays can be sparse (unwanted arguments)
	                        if (element !== null) {
	                            markParam(element.name);
	                        }
	                    });
	                    break;

	                // no default
	            }
	        });

	        // log an error for each duplicate (not 2 for each)
	        Object.keys(dups).forEach(function(currentParam) {
	            context.report(node, "Duplicate param '{{key}}'.", { key: currentParam });
	        });
	    }

	    //--------------------------------------------------------------------------
	    // Public API
	    //--------------------------------------------------------------------------

	    return {
	        "FunctionDeclaration": checkParams,
	        "FunctionExpression": checkParams
	    };

	};

	module.exports.schema = [];


/***/ },
/* 172 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag use of duplicate keys in an object.
	 * @author Ian Christian Myers
	 * @copyright 2013 Ian Christian Myers. All rights reserved.
	 * @copyright 2013 Nicholas C. Zakas. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {

	        "ObjectExpression": function(node) {

	            // Object that will be a map of properties--safe because we will
	            // prefix all of the keys.
	            var nodeProps = Object.create(null);

	            node.properties.forEach(function(property) {

	                if (property.type !== "Property") {
	                    return;
	                }

	                var keyName = property.key.name || property.key.value,
	                    key = property.kind + "-" + keyName,
	                    checkProperty = (!property.computed || property.key.type === "Literal");

	                if (checkProperty) {
	                    if (nodeProps[key]) {
	                        context.report(node, "Duplicate key '{{key}}'.", { key: keyName });
	                    } else {
	                        nodeProps[key] = true;
	                    }
	                }
	            });

	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 173 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to disallow a duplicate case label.
	 * @author Dieter Oberkofler
	 * @copyright 2015 Dieter Oberkofler. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    /**
	     * Get a hash value for the node
	     * @param {ASTNode} node The node.
	     * @returns {string} A hash value for the node.
	     * @private
	     */
	    function getHash(node) {
	        if (node.type === "Literal") {
	            return node.type + typeof node.value + node.value;
	        } else if (node.type === "Identifier") {
	            return node.type + typeof node.name + node.name;
	        } else if (node.type === "MemberExpression") {
	            return node.type + getHash(node.object) + getHash(node.property);
	        } else if (node.type === "CallExpression") {
	            return node.type + getHash(node.callee) + node.arguments.map(getHash).join("");
	        } else if (node.type === "BinaryExpression") {
	            return node.type + getHash(node.left) + node.operator + getHash(node.right);
	        } else if (node.type === "ConditionalExpression") {
	            return node.type + getHash(node.test) + getHash(node.consequent) + getHash(node.alternate);
	        }
	    }

	    var switchStatement = [];

	    return {

	        "SwitchStatement": function(/* node */) {
	            switchStatement.push({});
	        },

	        "SwitchStatement:exit": function(/* node */) {
	            switchStatement.pop();
	        },

	        "SwitchCase": function(node) {
	            var currentSwitch = switchStatement[switchStatement.length - 1],
	                hashValue;

	            if (node.test) {
	                hashValue = getHash(node.test);
	                if (typeof hashValue !== "undefined" && currentSwitch.hasOwnProperty(hashValue)) {
	                    context.report(node, "Duplicate case label.");
	                } else {
	                    currentSwitch[hashValue] = true;
	                }
	            }
	        }

	    };

	};

	module.exports.schema = [];


/***/ },
/* 174 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag the use of empty character classes in regular expressions
	 * @author Ian Christian Myers
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------

	/*
	plain-English description of the following regexp:
	0. `^` fix the match at the beginning of the string
	1. `\/`: the `/` that begins the regexp
	2. `([^\\[]|\\.|\[([^\\\]]|\\.)+\])*`: regexp contents; 0 or more of the following
	  2.0. `[^\\[]`: any character that's not a `\` or a `[` (anything but escape sequences and character classes)
	  2.1. `\\.`: an escape sequence
	  2.2. `\[([^\\\]]|\\.)+\]`: a character class that isn't empty
	3. `\/` the `/` that ends the regexp
	4. `[gimuy]*`: optional regexp flags
	5. `$`: fix the match at the end of the string
	*/
	var regex = /^\/([^\\[]|\\.|\[([^\\\]]|\\.)+\])*\/[gimuy]*$/;

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {

	        "Literal": function(node) {
	            var token = context.getFirstToken(node);
	            if (token.type === "RegularExpression" && !regex.test(token.value)) {
	                context.report(node, "Empty class.");
	            }
	        }

	    };

	};

	module.exports.schema = [];


/***/ },
/* 175 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag use of an empty block statement
	 * @author Nicholas C. Zakas
	 * @copyright Nicholas C. Zakas. All rights reserved.
	 * @copyright 2015 Dieter Oberkofler. All rights reserved.
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {

	        "BlockStatement": function(node) {
	            var parent = node.parent,
	                parentType = parent.type;

	            // if the body is not empty, we can just return immediately
	            if (node.body.length !== 0) {
	                return;
	            }

	            // a function is generally allowed to be empty
	            if (parentType === "FunctionDeclaration" || parentType === "FunctionExpression" || parentType === "ArrowFunctionExpression") {
	                return;
	            }

	            // any other block is only allowed to be empty, if it contains a comment
	            if (context.getComments(node).trailing.length > 0) {
	                return;
	            }

	            context.report(node, "Empty block statement.");
	        },

	        "SwitchStatement": function(node) {

	            if (typeof node.cases === "undefined" || node.cases.length === 0) {
	                context.report(node, "Empty switch statement.");
	            }
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to flag assignment of the exception parameter
	 * @author Stephen Murray <spmurrayzzz>
	 */

	"use strict";

	var astUtils = __webpack_require__(177);

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    /**
	     * Finds and reports references that are non initializer and writable.
	     * @param {Variable} variable - A variable to check.
	     * @returns {void}
	     */
	    function checkVariable(variable) {
	        astUtils.getModifyingReferences(variable.references).forEach(function(reference) {
	            context.report(
	                reference.identifier,
	                "Do not assign to the exception parameter.");
	        });
	    }

	    return {
	        "CatchClause": function(node) {
	            context.getDeclaredVariables(node).forEach(checkVariable);
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 177 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Common utils for AST.
	 * @author Gyandeep Singh
	 * @copyright 2015 Gyandeep Singh. All rights reserved.
	 */

	"use strict";

	/**
	 * Finds a JSDoc comment node in an array of comment nodes.
	 * @param {ASTNode[]} comments The array of comment nodes to search.
	 * @param {int} line Line number to look around
	 * @returns {ASTNode} The node if found, null if not.
	 * @private
	 */
	function findJSDocComment(comments, line) {

	    if (comments) {
	        for (var i = comments.length - 1; i >= 0; i--) {
	            if (comments[i].type === "Block" && comments[i].value.charAt(0) === "*") {

	                if (line - comments[i].loc.end.line <= 1) {
	                    return comments[i];
	                } else {
	                    break;
	                }
	            }
	        }
	    }

	    return null;
	}

	/**
	 * Check to see if its a ES6 export declaration
	 * @param {ASTNode} astNode - any node
	 * @returns {boolean} whether the given node represents a export declaration
	 * @private
	 */
	function looksLikeExport(astNode) {
	    return astNode.type === "ExportDefaultDeclaration" || astNode.type === "ExportNamedDeclaration" ||
	        astNode.type === "ExportAllDeclaration" || astNode.type === "ExportSpecifier";
	}

	/**
	 * Checks reference if is non initializer and writable.
	 * @param {Reference} reference - A reference to check.
	 * @param {int} index - The index of the reference in the references.
	 * @param {Reference[]} references - The array that the reference belongs to.
	 * @returns {boolean} Success/Failure
	 * @private
	 */
	function isModifyingReference(reference, index, references) {
	    var identifier = reference.identifier;

	    return (identifier != null &&
	        reference.init === false &&
	        reference.isWrite() &&
	            // Destructuring assignments can have multiple default value,
	            // so possibly there are multiple writeable references for the same identifier.
	        (index === 0 || references[index - 1].identifier !== identifier)
	    );
	}

	module.exports = {

	    /**
	     * Gets all comments for the given node.
	     * @param {ASTNode} node The AST node to get the comments for.
	     * @returns {Object} The list of comments indexed by their position.
	     * @public
	     */
	    getComments: function(node) {

	        var leadingComments = node.leadingComments || [],
	            trailingComments = node.trailingComments || [];

	        /*
	         * espree adds a "comments" array on Program nodes rather than
	         * leadingComments/trailingComments. Comments are only left in the
	         * Program node comments array if there is no executable code.
	         */
	        if (node.type === "Program") {
	            if (node.body.length === 0) {
	                leadingComments = node.comments;
	            }
	        }

	        return {
	            leading: leadingComments,
	            trailing: trailingComments
	        };
	    },

	    /**
	     * Retrieves the JSDoc comment for a given node.
	     * @param {ASTNode} node The AST node to get the comment for.
	     * @returns {ASTNode} The BlockComment node containing the JSDoc for the
	     *      given node or null if not found.
	     * @public
	     */
	    getJSDocComment: function(node) {

	        var parent = node.parent,
	            line = node.loc.start.line;

	        switch (node.type) {
	            case "FunctionDeclaration":
	                if (looksLikeExport(parent)) {
	                    return findJSDocComment(parent.leadingComments, line);
	                } else {
	                    return findJSDocComment(node.leadingComments, line);
	                }
	                break;

	            case "ArrowFunctionExpression":
	            case "FunctionExpression":

	                if (parent.type !== "CallExpression") {
	                    while (parent && !parent.leadingComments && !/Function/.test(parent.type)) {
	                        parent = parent.parent;
	                    }

	                    return parent && (parent.type !== "FunctionDeclaration") ? findJSDocComment(parent.leadingComments, line) : null;
	                }

	            // falls through

	            default:
	                return null;
	        }
	    },

	    /**
	     * Determines whether two adjacent tokens are have whitespace between them.
	     * @param {Object} left - The left token object.
	     * @param {Object} right - The right token object.
	     * @returns {boolean} Whether or not there is space between the tokens.
	     * @public
	     */
	    isTokenSpaced: function(left, right) {
	        return left.range[1] < right.range[0];
	    },

	    /**
	     * Determines whether two adjacent tokens are on the same line.
	     * @param {Object} left - The left token object.
	     * @param {Object} right - The right token object.
	     * @returns {boolean} Whether or not the tokens are on the same line.
	     * @public
	     */
	    isTokenOnSameLine: function(left, right) {
	        return left.loc.end.line === right.loc.start.line;
	    },

	    /**
	     * Checks whether or not a node is `null` or `undefined`.
	     * @param {ASTNode} node - A node to check.
	     * @returns {boolean} Whether or not the node is a `null` or `undefined`.
	     * @public
	     */
	    isNullOrUndefined: function(node) {
	        return (
	            (node.type === "Literal" && node.value === null) ||
	            (node.type === "Identifier" && node.name === "undefined") ||
	            (node.type === "UnaryExpression" && node.operator === "void")
	        );
	    },

	    /**
	     * Gets references which are non initializer and writable.
	     * @param {Reference[]} references - An array of references.
	     * @returns {Reference[]} An array of only references which are non initializer and writable.
	     * @public
	     */
	    getModifyingReferences: function(references) {
	        return references.filter(isModifyingReference);
	    }
	};


/***/ },
/* 178 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag unnecessary double negation in Boolean contexts
	 * @author Brandon Mills
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {
	        "UnaryExpression": function(node) {
	            var ancestors = context.getAncestors(),
	                parent = ancestors.pop(),
	                grandparent = ancestors.pop();

	            // Exit early if it's guaranteed not to match
	            if (node.operator !== "!" ||
	                    parent.type !== "UnaryExpression" ||
	                    parent.operator !== "!") {
	                return;
	            }

	            // if (<bool>) ...
	            if (grandparent.type === "IfStatement") {
	                context.report(node, "Redundant double negation in an if statement condition.");

	            // do ... while (<bool>)
	            } else if (grandparent.type === "DoWhileStatement") {
	                context.report(node, "Redundant double negation in a do while loop condition.");

	            // while (<bool>) ...
	            } else if (grandparent.type === "WhileStatement") {
	                context.report(node, "Redundant double negation in a while loop condition.");

	            // <bool> ? ... : ...
	            } else if ((grandparent.type === "ConditionalExpression" &&
	                    parent === grandparent.test)) {
	                context.report(node, "Redundant double negation in a ternary condition.");

	            // for (...; <bool>; ...) ...
	            } else if ((grandparent.type === "ForStatement" &&
	                    parent === grandparent.test)) {
	                context.report(node, "Redundant double negation in a for loop condition.");

	            // !<bool>
	            } else if ((grandparent.type === "UnaryExpression" &&
	                    grandparent.operator === "!")) {
	                context.report(node, "Redundant multiple negation.");

	            // Boolean(<bool>)
	            } else if ((grandparent.type === "CallExpression" &&
	                    grandparent.callee.type === "Identifier" &&
	                    grandparent.callee.name === "Boolean")) {
	                context.report(node, "Redundant double negation in call to Boolean().");

	            // new Boolean(<bool>)
	            } else if ((grandparent.type === "NewExpression" &&
	                    grandparent.callee.type === "Identifier" &&
	                    grandparent.callee.name === "Boolean")) {
	                context.report(node, "Redundant double negation in Boolean constructor call.");
	            }
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 179 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Disallow parenthesising higher precedence subexpressions.
	 * @author Michael Ficarra
	 * @copyright 2014 Michael Ficarra. All rights reserved.
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var ALL_NODES = context.options[0] !== "functions";

	    /**
	     * Determines if this rule should be enforced for a node given the current configuration.
	     * @param {ASTNode} node - The node to be checked.
	     * @returns {boolean} True if the rule should be enforced for this node.
	     * @private
	     */
	    function ruleApplies(node) {
	        return ALL_NODES || node.type === "FunctionExpression" || node.type === "ArrowFunctionExpression";
	    }

	    /**
	     * Determines if a node is surrounded by parentheses.
	     * @param {ASTNode} node - The node to be checked.
	     * @returns {boolean} True if the node is parenthesised.
	     * @private
	     */
	    function isParenthesised(node) {
	        var previousToken = context.getTokenBefore(node),
	            nextToken = context.getTokenAfter(node);

	        return previousToken && nextToken &&
	            previousToken.value === "(" && previousToken.range[1] <= node.range[0] &&
	            nextToken.value === ")" && nextToken.range[0] >= node.range[1];
	    }

	    /**
	     * Determines if a node is surrounded by parentheses twice.
	     * @param {ASTNode} node - The node to be checked.
	     * @returns {boolean} True if the node is doubly parenthesised.
	     * @private
	     */
	    function isParenthesisedTwice(node) {
	        var previousToken = context.getTokenBefore(node, 1),
	            nextToken = context.getTokenAfter(node, 1);

	        return isParenthesised(node) && previousToken && nextToken &&
	            previousToken.value === "(" && previousToken.range[1] <= node.range[0] &&
	            nextToken.value === ")" && nextToken.range[0] >= node.range[1];
	    }

	    /**
	     * Determines if a node is surrounded by (potentially) invalid parentheses.
	     * @param {ASTNode} node - The node to be checked.
	     * @returns {boolean} True if the node is incorrectly parenthesised.
	     * @private
	     */
	    function hasExcessParens(node) {
	        return ruleApplies(node) && isParenthesised(node);
	    }

	    /**
	     * Determines if a node that is expected to be parenthesised is surrounded by
	     * (potentially) invalid extra parentheses.
	     * @param {ASTNode} node - The node to be checked.
	     * @returns {boolean} True if the node is has an unexpected extra pair of parentheses.
	     * @private
	     */
	    function hasDoubleExcessParens(node) {
	        return ruleApplies(node) && isParenthesisedTwice(node);
	    }

	    function precedence(node) {

	        switch (node.type) {
	            case "SequenceExpression":
	                return 0;

	            case "AssignmentExpression":
	            case "ArrowFunctionExpression":
	            case "YieldExpression":
	                return 1;

	            case "ConditionalExpression":
	                return 3;

	            case "LogicalExpression":
	                switch (node.operator) {
	                    case "||":
	                        return 4;
	                    case "&&":
	                        return 5;
	                    // no default
	                }

	                /* falls through */
	            case "BinaryExpression":
	                switch (node.operator) {
	                    case "|":
	                        return 6;
	                    case "^":
	                        return 7;
	                    case "&":
	                        return 8;
	                    case "==":
	                    case "!=":
	                    case "===":
	                    case "!==":
	                        return 9;
	                    case "<":
	                    case "<=":
	                    case ">":
	                    case ">=":
	                    case "in":
	                    case "instanceof":
	                        return 10;
	                    case "<<":
	                    case ">>":
	                    case ">>>":
	                        return 11;
	                    case "+":
	                    case "-":
	                        return 12;
	                    case "*":
	                    case "/":
	                    case "%":
	                        return 13;
	                    // no default
	                }
	                /* falls through */
	            case "UnaryExpression":
	                return 14;
	            case "UpdateExpression":
	                return 15;
	            case "CallExpression":
	                // IIFE is allowed to have parens in any position (#655)
	                if (node.callee.type === "FunctionExpression") {
	                    return -1;
	                }
	                return 16;
	            case "NewExpression":
	                return 17;
	            // no default
	        }
	        return 18;
	    }

	    function report(node) {
	        var previousToken = context.getTokenBefore(node);
	        context.report(node, previousToken.loc.start, "Gratuitous parentheses around expression.");
	    }

	    function dryUnaryUpdate(node) {
	        if (hasExcessParens(node.argument) && precedence(node.argument) >= precedence(node)) {
	            report(node.argument);
	        }
	    }

	    function dryCallNew(node) {
	        if (hasExcessParens(node.callee) && precedence(node.callee) >= precedence(node) && !(
	            node.type === "CallExpression" &&
	            node.callee.type === "FunctionExpression" &&
	            // One set of parentheses are allowed for a function expression
	            !hasDoubleExcessParens(node.callee)
	        )) {
	            report(node.callee);
	        }
	        if (node.arguments.length === 1) {
	            if (hasDoubleExcessParens(node.arguments[0]) && precedence(node.arguments[0]) >= precedence({type: "AssignmentExpression"})) {
	                report(node.arguments[0]);
	            }
	        } else {
	            [].forEach.call(node.arguments, function(arg) {
	                if (hasExcessParens(arg) && precedence(arg) >= precedence({type: "AssignmentExpression"})) {
	                    report(arg);
	                }
	            });
	        }
	    }

	    function dryBinaryLogical(node) {
	        var prec = precedence(node);
	        if (hasExcessParens(node.left) && precedence(node.left) >= prec) {
	            report(node.left);
	        }
	        if (hasExcessParens(node.right) && precedence(node.right) > prec) {
	            report(node.right);
	        }
	    }

	    return {
	        "ArrayExpression": function(node) {
	            [].forEach.call(node.elements, function(e) {
	                if (e && hasExcessParens(e) && precedence(e) >= precedence({type: "AssignmentExpression"})) {
	                    report(e);
	                }
	            });
	        },
	        "ArrowFunctionExpression": function(node) {
	            if (node.body.type !== "BlockStatement") {
	                if (node.body.type !== "ObjectExpression" && hasExcessParens(node.body) && precedence(node.body) >= precedence({type: "AssignmentExpression"})) {
	                    report(node.body);
	                    return;
	                }

	                // Object literals *must* be parenthesized
	                if (node.body.type === "ObjectExpression" && hasDoubleExcessParens(node.body)) {
	                    report(node.body);
	                    return;
	                }
	            }
	        },
	        "AssignmentExpression": function(node) {
	            if (hasExcessParens(node.right) && precedence(node.right) >= precedence(node)) {
	                report(node.right);
	            }
	        },
	        "BinaryExpression": dryBinaryLogical,
	        "CallExpression": dryCallNew,
	        "ConditionalExpression": function(node) {
	            if (hasExcessParens(node.test) && precedence(node.test) >= precedence({type: "LogicalExpression", operator: "||"})) {
	                report(node.test);
	            }
	            if (hasExcessParens(node.consequent) && precedence(node.consequent) >= precedence({type: "AssignmentExpression"})) {
	                report(node.consequent);
	            }
	            if (hasExcessParens(node.alternate) && precedence(node.alternate) >= precedence({type: "AssignmentExpression"})) {
	                report(node.alternate);
	            }
	        },
	        "DoWhileStatement": function(node) {
	            if (hasDoubleExcessParens(node.test)) {
	                report(node.test);
	            }
	        },
	        "ExpressionStatement": function(node) {
	            var firstToken;
	            if (hasExcessParens(node.expression) && node.expression.type !== "CallExpression") {
	                firstToken = context.getFirstToken(node.expression);
	                // Pure object literals ({}) do not need parentheses but
	                // member expressions do ({}.toString())
	                if (firstToken.value !== "{" || node.expression.type === "ObjectExpression") {
	                    report(node.expression);
	                }
	            }
	        },
	        "ForInStatement": function(node) {
	            if (hasExcessParens(node.right)) {
	                report(node.right);
	            }
	        },
	        "ForOfStatement": function(node) {
	            if (hasExcessParens(node.right)) {
	                report(node.right);
	            }
	        },
	        "ForStatement": function(node) {
	            if (node.init && hasExcessParens(node.init)) {
	                report(node.init);
	            }

	            if (node.test && hasExcessParens(node.test)) {
	                report(node.test);
	            }

	            if (node.update && hasExcessParens(node.update)) {
	                report(node.update);
	            }
	        },
	        "IfStatement": function(node) {
	            if (hasDoubleExcessParens(node.test)) {
	                report(node.test);
	            }
	        },
	        "LogicalExpression": dryBinaryLogical,
	        "MemberExpression": function(node) {
	            if (
	                hasExcessParens(node.object) &&
	                precedence(node.object) >= precedence(node) &&
	                (
	                    node.computed ||
	                    !(
	                        (node.object.type === "Literal" &&
	                        typeof node.object.value === "number" &&
	                        /^[0-9]+$/.test(context.getFirstToken(node.object).value))
	                        ||
	                        // RegExp literal is allowed to have parens (#1589)
	                        (node.object.type === "Literal" && node.object.regex)
	                    )
	                )
	            ) {
	                report(node.object);
	            }
	            if (node.computed && hasExcessParens(node.property)) {
	                report(node.property);
	            }
	        },
	        "NewExpression": dryCallNew,
	        "ObjectExpression": function(node) {
	            [].forEach.call(node.properties, function(e) {
	                var v = e.value;
	                if (v && hasExcessParens(v) && precedence(v) >= precedence({type: "AssignmentExpression"})) {
	                    report(v);
	                }
	            });
	        },
	        "ReturnStatement": function(node) {
	            if (node.argument && hasExcessParens(node.argument) &&
	                    // RegExp literal is allowed to have parens (#1589)
	                    !(node.argument.type === "Literal" && node.argument.regex)) {
	                report(node.argument);
	            }
	        },
	        "SequenceExpression": function(node) {
	            [].forEach.call(node.expressions, function(e) {
	                if (hasExcessParens(e) && precedence(e) >= precedence(node)) {
	                    report(e);
	                }
	            });
	        },
	        "SwitchCase": function(node) {
	            if (node.test && hasExcessParens(node.test)) {
	                report(node.test);
	            }
	        },
	        "SwitchStatement": function(node) {
	            if (hasDoubleExcessParens(node.discriminant)) {
	                report(node.discriminant);
	            }
	        },
	        "ThrowStatement": function(node) {
	            if (hasExcessParens(node.argument)) {
	                report(node.argument);
	            }
	        },
	        "UnaryExpression": dryUnaryUpdate,
	        "UpdateExpression": dryUnaryUpdate,
	        "VariableDeclarator": function(node) {
	            if (node.init && hasExcessParens(node.init) &&
	                    precedence(node.init) >= precedence({type: "AssignmentExpression"}) &&
	                    // RegExp literal is allowed to have parens (#1589)
	                    !(node.init.type === "Literal" && node.init.regex)) {
	                report(node.init);
	            }
	        },
	        "WhileStatement": function(node) {
	            if (hasDoubleExcessParens(node.test)) {
	                report(node.test);
	            }
	        },
	        "WithStatement": function(node) {
	            if (hasDoubleExcessParens(node.object)) {
	                report(node.object);
	            }
	        }
	    };

	};

	module.exports.schema = [
	    {
	        "enum": ["all", "functions"]
	    }
	];


/***/ },
/* 180 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag use of unnecessary semicolons
	 * @author Nicholas C. Zakas
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    /**
	     * Reports an unnecessary semicolon error.
	     * @param {Node|Token} nodeOrToken - A node or a token to be reported.
	     * @returns {void}
	     */
	    function report(nodeOrToken) {
	        context.report(nodeOrToken, "Unnecessary semicolon.");
	    }

	    /**
	     * Checks for a part of a class body.
	     * This checks tokens from a specified token to a next MethodDefinition or the end of class body.
	     *
	     * @param {Token} firstToken - The first token to check.
	     * @returns {void}
	     */
	    function checkForPartOfClassBody(firstToken) {
	        for (var token = firstToken;
	            token.type === "Punctuator" && token.value !== "}";
	            token = context.getTokenAfter(token)
	        ) {
	            if (token.value === ";") {
	                report(token);
	            }
	        }
	    }

	    return {
	        /**
	         * Reports this empty statement, except if the parent node is a loop.
	         * @param {Node} node - A EmptyStatement node to be reported.
	         * @returns {void}
	         */
	        "EmptyStatement": function(node) {
	            var parent = node.parent,
	                allowedParentTypes = ["ForStatement", "ForInStatement", "ForOfStatement", "WhileStatement", "DoWhileStatement"];

	            if (allowedParentTypes.indexOf(parent.type) === -1) {
	                report(node);
	            }
	        },

	        /**
	         * Checks tokens from the head of this class body to the first MethodDefinition or the end of this class body.
	         * @param {Node} node - A ClassBody node to check.
	         * @returns {void}
	         */
	        "ClassBody": function(node) {
	            checkForPartOfClassBody(context.getFirstToken(node, 1)); // 0 is `{`.
	        },

	        /**
	         * Checks tokens from this MethodDefinition to the next MethodDefinition or the end of this class body.
	         * @param {Node} node - A MethodDefinition node of the start point.
	         * @returns {void}
	         */
	        "MethodDefinition": function(node) {
	            checkForPartOfClassBody(context.getTokenAfter(node));
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to flag use of function declaration identifiers as variables.
	 * @author Ian Christian Myers
	 * @copyright 2013 Ian Christian Myers. All rights reserved.
	 */

	"use strict";

	var astUtils = __webpack_require__(177);

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var unresolved = Object.create(null);

	    /**
	     * Collects unresolved references from the global scope, then creates a map to references from its name.
	     * Usage of the map is explained at `checkVariable(variable)`.
	     * @returns {void}
	     */
	    function collectUnresolvedReferences() {
	        unresolved = Object.create(null);

	        var references = context.getScope().through;
	        for (var i = 0; i < references.length; ++i) {
	            var reference = references[i];
	            var name = reference.identifier.name;

	            if (name in unresolved === false) {
	                unresolved[name] = [];
	            }
	            unresolved[name].push(reference);
	        }
	    }

	    /**
	     * Reports a reference if is non initializer and writable.
	     * @param {References} references - Collection of reference to check.
	     * @returns {void}
	     */
	    function checkReference(references) {
	        astUtils.getModifyingReferences(references).forEach(function(reference) {
	            context.report(
	                reference.identifier,
	                "'{{name}}' is a function.",
	                {name: reference.identifier.name});
	        });
	    }

	    /**
	     * Finds and reports references that are non initializer and writable.
	     * @param {Variable} variable - A variable to check.
	     * @returns {void}
	     */
	    function checkVariable(variable) {
	        if (variable.defs[0].type === "FunctionName") {
	            // If the function is in global scope, its references are not resolved (by escope's design).
	            // So when references of the function are nothing, this checks in unresolved.
	            if (variable.references.length > 0) {
	                checkReference(variable.references);
	            } else if (unresolved[variable.name] != null) {
	                checkReference(unresolved[variable.name]);
	            }
	        }
	    }

	    /**
	     * Checks parameters of a given function node.
	     * @param {ASTNode} node - A function node to check.
	     * @returns {void}
	     */
	    function checkForFunction(node) {
	        context.getDeclaredVariables(node).forEach(checkVariable);
	    }

	    return {
	        "Program": collectUnresolvedReferences,
	        "FunctionDeclaration": checkForFunction,
	        "FunctionExpression": checkForFunction
	    };

	};

	module.exports.schema = [];


/***/ },
/* 182 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to enforce declarations in program or function body root.
	 * @author Brandon Mills
	 * @copyright 2014 Brandon Mills. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    /**
	     * Find the nearest Program or Function ancestor node.
	     * @returns {Object} Ancestor's type and distance from node.
	     */
	    function nearestBody() {
	        var ancestors = context.getAncestors(),
	            ancestor = ancestors.pop(),
	            generation = 1;

	        while (ancestor && ["Program", "FunctionDeclaration",
	                "FunctionExpression", "ArrowFunctionExpression"
	                ].indexOf(ancestor.type) < 0) {
	            generation += 1;
	            ancestor = ancestors.pop();
	        }

	        return {
	            // Type of containing ancestor
	            type: ancestor.type,
	            // Separation between ancestor and node
	            distance: generation
	        };
	    }

	    /**
	     * Ensure that a given node is at a program or function body's root.
	     * @param {ASTNode} node Declaration node to check.
	     * @returns {void}
	     */
	    function check(node) {
	        var body = nearestBody(node),
	            valid = ((body.type === "Program" && body.distance === 1) ||
	                body.distance === 2);

	        if (!valid) {
	            context.report(node, "Move {{type}} declaration to {{body}} root.",
	                {
	                    type: (node.type === "FunctionDeclaration" ?
	                        "function" : "variable"),
	                    body: (body.type === "Program" ?
	                        "program" : "function body")
	                }
	            );
	        }
	    }

	    return {

	        "FunctionDeclaration": check,
	        "VariableDeclaration": function(node) {
	            if (context.options[0] === "both" && node.kind === "var") {
	                check(node);
	            }
	        }

	    };

	};

	module.exports.schema = [
	    {
	        "enum": ["functions", "both"]
	    }
	];


/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Validate strings passed to the RegExp constructor
	 * @author Michael Ficarra
	 * @copyright 2014 Michael Ficarra. All rights reserved.
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------

	var espree = __webpack_require__(184);

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    function isString(node) {
	        return node && node.type === "Literal" && typeof node.value === "string";
	    }

	    function check(node) {
	        if (node.callee.type === "Identifier" && node.callee.name === "RegExp" && isString(node.arguments[0])) {
	            var flags = isString(node.arguments[1]) ? node.arguments[1].value : "";

	            try {
	                void new RegExp(node.arguments[0].value);
	            } catch(e) {
	                context.report(node, e.message);
	            }

	            if (flags) {

	                try {
	                    espree.parse("/./" + flags, { ecmaFeatures: context.ecmaFeatures });
	                } catch (ex) {
	                    context.report(node, "Invalid flags supplied to RegExp constructor '" + flags + "'");
	                }
	            }

	        }
	    }

	    return {
	        "CallExpression": check,
	        "NewExpression": check
	    };

	};

	module.exports.schema = [];


/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	/*
	Copyright (C) 2015 Fred K. Schott <fkschott@gmail.com>
	Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>
	Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>
	Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>
	Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
	Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>
	Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
	Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
	Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>
	Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>
	Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>

	Redistribution and use in source and binary forms, with or without
	modification, are permitted provided that the following conditions are met:

	* Redistributions of source code must retain the above copyright
	  notice, this list of conditions and the following disclaimer.
	* Redistributions in binary form must reproduce the above copyright
	  notice, this list of conditions and the following disclaimer in the
	  documentation and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	/*eslint no-undefined:0, no-use-before-define: 0*/

	"use strict";

	var syntax = __webpack_require__(186),
	    tokenInfo = __webpack_require__(187),
	    astNodeTypes = __webpack_require__(188),
	    astNodeFactory = __webpack_require__(189),
	    defaultFeatures = __webpack_require__(190),
	    Messages = __webpack_require__(185),
	    XHTMLEntities = __webpack_require__(191),
	    StringMap = __webpack_require__(192),
	    commentAttachment = __webpack_require__(193);

	var Token = tokenInfo.Token,
	    TokenName = tokenInfo.TokenName,
	    FnExprTokens = tokenInfo.FnExprTokens,
	    Regex = syntax.Regex,
	    PropertyKind,
	    source,
	    strict,
	    index,
	    lineNumber,
	    lineStart,
	    length,
	    lookahead,
	    state,
	    extra;

	PropertyKind = {
	    Data: 1,
	    Get: 2,
	    Set: 4
	};


	// Ensure the condition is true, otherwise throw an error.
	// This is only to have a better contract semantic, i.e. another safety net
	// to catch a logic error. The condition shall be fulfilled in normal case.
	// Do NOT use this to enforce a certain condition on any user input.

	function assert(condition, message) {
	    /* istanbul ignore if */
	    if (!condition) {
	        throw new Error("ASSERT: " + message);
	    }
	}

	// 7.4 Comments

	function addComment(type, value, start, end, loc) {
	    var comment;

	    assert(typeof start === "number", "Comment must have valid position");

	    // Because the way the actual token is scanned, often the comments
	    // (if any) are skipped twice during the lexical analysis.
	    // Thus, we need to skip adding a comment if the comment array already
	    // handled it.
	    if (state.lastCommentStart >= start) {
	        return;
	    }
	    state.lastCommentStart = start;

	    comment = {
	        type: type,
	        value: value
	    };
	    if (extra.range) {
	        comment.range = [start, end];
	    }
	    if (extra.loc) {
	        comment.loc = loc;
	    }
	    extra.comments.push(comment);

	    if (extra.attachComment) {
	        commentAttachment.addComment(comment);
	    }
	}

	function skipSingleLineComment(offset) {
	    var start, loc, ch, comment;

	    start = index - offset;
	    loc = {
	        start: {
	            line: lineNumber,
	            column: index - lineStart - offset
	        }
	    };

	    while (index < length) {
	        ch = source.charCodeAt(index);
	        ++index;
	        if (syntax.isLineTerminator(ch)) {
	            if (extra.comments) {
	                comment = source.slice(start + offset, index - 1);
	                loc.end = {
	                    line: lineNumber,
	                    column: index - lineStart - 1
	                };
	                addComment("Line", comment, start, index - 1, loc);
	            }
	            if (ch === 13 && source.charCodeAt(index) === 10) {
	                ++index;
	            }
	            ++lineNumber;
	            lineStart = index;
	            return;
	        }
	    }

	    if (extra.comments) {
	        comment = source.slice(start + offset, index);
	        loc.end = {
	            line: lineNumber,
	            column: index - lineStart
	        };
	        addComment("Line", comment, start, index, loc);
	    }
	}

	function skipMultiLineComment() {
	    var start, loc, ch, comment;

	    if (extra.comments) {
	        start = index - 2;
	        loc = {
	            start: {
	                line: lineNumber,
	                column: index - lineStart - 2
	            }
	        };
	    }

	    while (index < length) {
	        ch = source.charCodeAt(index);
	        if (syntax.isLineTerminator(ch)) {
	            if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {
	                ++index;
	            }
	            ++lineNumber;
	            ++index;
	            lineStart = index;
	            if (index >= length) {
	                throwError({}, Messages.UnexpectedToken, "ILLEGAL");
	            }
	        } else if (ch === 0x2A) {
	            // Block comment ends with "*/".
	            if (source.charCodeAt(index + 1) === 0x2F) {
	                ++index;
	                ++index;
	                if (extra.comments) {
	                    comment = source.slice(start + 2, index - 2);
	                    loc.end = {
	                        line: lineNumber,
	                        column: index - lineStart
	                    };
	                    addComment("Block", comment, start, index, loc);
	                }
	                return;
	            }
	            ++index;
	        } else {
	            ++index;
	        }
	    }

	    throwError({}, Messages.UnexpectedToken, "ILLEGAL");
	}

	function skipComment() {
	    var ch, start;

	    start = (index === 0);
	    while (index < length) {
	        ch = source.charCodeAt(index);

	        if (syntax.isWhiteSpace(ch)) {
	            ++index;
	        } else if (syntax.isLineTerminator(ch)) {
	            ++index;
	            if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {
	                ++index;
	            }
	            ++lineNumber;
	            lineStart = index;
	            start = true;
	        } else if (ch === 0x2F) { // U+002F is "/"
	            ch = source.charCodeAt(index + 1);
	            if (ch === 0x2F) {
	                ++index;
	                ++index;
	                skipSingleLineComment(2);
	                start = true;
	            } else if (ch === 0x2A) {  // U+002A is "*"
	                ++index;
	                ++index;
	                skipMultiLineComment();
	            } else {
	                break;
	            }
	        } else if (start && ch === 0x2D) { // U+002D is "-"
	            // U+003E is ">"
	            if ((source.charCodeAt(index + 1) === 0x2D) && (source.charCodeAt(index + 2) === 0x3E)) {
	                // "-->" is a single-line comment
	                index += 3;
	                skipSingleLineComment(3);
	            } else {
	                break;
	            }
	        } else if (ch === 0x3C) { // U+003C is "<"
	            if (source.slice(index + 1, index + 4) === "!--") {
	                ++index; // `<`
	                ++index; // `!`
	                ++index; // `-`
	                ++index; // `-`
	                skipSingleLineComment(4);
	            } else {
	                break;
	            }
	        } else {
	            break;
	        }
	    }
	}

	function scanHexEscape(prefix) {
	    var i, len, ch, code = 0;

	    len = (prefix === "u") ? 4 : 2;
	    for (i = 0; i < len; ++i) {
	        if (index < length && syntax.isHexDigit(source[index])) {
	            ch = source[index++];
	            code = code * 16 + "0123456789abcdef".indexOf(ch.toLowerCase());
	        } else {
	            return "";
	        }
	    }
	    return String.fromCharCode(code);
	}

	/**
	 * Scans an extended unicode code point escape sequence from source. Throws an
	 * error if the sequence is empty or if the code point value is too large.
	 * @returns {string} The string created by the Unicode escape sequence.
	 * @private
	 */
	function scanUnicodeCodePointEscape() {
	    var ch, code, cu1, cu2;

	    ch = source[index];
	    code = 0;

	    // At least one hex digit is required.
	    if (ch === "}") {
	        throwError({}, Messages.UnexpectedToken, "ILLEGAL");
	    }

	    while (index < length) {
	        ch = source[index++];
	        if (!syntax.isHexDigit(ch)) {
	            break;
	        }
	        code = code * 16 + "0123456789abcdef".indexOf(ch.toLowerCase());
	    }

	    if (code > 0x10FFFF || ch !== "}") {
	        throwError({}, Messages.UnexpectedToken, "ILLEGAL");
	    }

	    // UTF-16 Encoding
	    if (code <= 0xFFFF) {
	        return String.fromCharCode(code);
	    }
	    cu1 = ((code - 0x10000) >> 10) + 0xD800;
	    cu2 = ((code - 0x10000) & 1023) + 0xDC00;
	    return String.fromCharCode(cu1, cu2);
	}

	function getEscapedIdentifier() {
	    var ch, id;

	    ch = source.charCodeAt(index++);
	    id = String.fromCharCode(ch);

	    // "\u" (U+005C, U+0075) denotes an escaped character.
	    if (ch === 0x5C) {
	        if (source.charCodeAt(index) !== 0x75) {
	            throwError({}, Messages.UnexpectedToken, "ILLEGAL");
	        }
	        ++index;
	        ch = scanHexEscape("u");
	        if (!ch || ch === "\\" || !syntax.isIdentifierStart(ch.charCodeAt(0))) {
	            throwError({}, Messages.UnexpectedToken, "ILLEGAL");
	        }
	        id = ch;
	    }

	    while (index < length) {
	        ch = source.charCodeAt(index);
	        if (!syntax.isIdentifierPart(ch)) {
	            break;
	        }
	        ++index;
	        id += String.fromCharCode(ch);

	        // "\u" (U+005C, U+0075) denotes an escaped character.
	        if (ch === 0x5C) {
	            id = id.substr(0, id.length - 1);
	            if (source.charCodeAt(index) !== 0x75) {
	                throwError({}, Messages.UnexpectedToken, "ILLEGAL");
	            }
	            ++index;
	            ch = scanHexEscape("u");
	            if (!ch || ch === "\\" || !syntax.isIdentifierPart(ch.charCodeAt(0))) {
	                throwError({}, Messages.UnexpectedToken, "ILLEGAL");
	            }
	            id += ch;
	        }
	    }

	    return id;
	}

	function getIdentifier() {
	    var start, ch;

	    start = index++;
	    while (index < length) {
	        ch = source.charCodeAt(index);
	        if (ch === 0x5C) {
	            // Blackslash (U+005C) marks Unicode escape sequence.
	            index = start;
	            return getEscapedIdentifier();
	        }
	        if (syntax.isIdentifierPart(ch)) {
	            ++index;
	        } else {
	            break;
	        }
	    }

	    return source.slice(start, index);
	}

	function scanIdentifier() {
	    var start, id, type;

	    start = index;

	    // Backslash (U+005C) starts an escaped character.
	    id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();

	    // There is no keyword or literal with only one character.
	    // Thus, it must be an identifier.
	    if (id.length === 1) {
	        type = Token.Identifier;
	    } else if (syntax.isKeyword(id, strict, extra.ecmaFeatures)) {
	        type = Token.Keyword;
	    } else if (id === "null") {
	        type = Token.NullLiteral;
	    } else if (id === "true" || id === "false") {
	        type = Token.BooleanLiteral;
	    } else {
	        type = Token.Identifier;
	    }

	    return {
	        type: type,
	        value: id,
	        lineNumber: lineNumber,
	        lineStart: lineStart,
	        range: [start, index]
	    };
	}


	// 7.7 Punctuators

	function scanPunctuator() {
	    var start = index,
	        code = source.charCodeAt(index),
	        code2,
	        ch1 = source[index],
	        ch2,
	        ch3,
	        ch4;

	    switch (code) {
	        // Check for most common single-character punctuators.
	        case 40:   // ( open bracket
	        case 41:   // ) close bracket
	        case 59:   // ; semicolon
	        case 44:   // , comma
	        case 91:   // [
	        case 93:   // ]
	        case 58:   // :
	        case 63:   // ?
	        case 126:  // ~
	            ++index;

	            if (extra.tokenize && code === 40) {
	                extra.openParenToken = extra.tokens.length;
	            }

	            return {
	                type: Token.Punctuator,
	                value: String.fromCharCode(code),
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                range: [start, index]
	            };

	        case 123:  // { open curly brace
	        case 125:  // } close curly brace
	            ++index;

	            if (extra.tokenize && code === 123) {
	                extra.openCurlyToken = extra.tokens.length;
	            }

	            // lookahead2 function can cause tokens to be scanned twice and in doing so
	            // would wreck the curly stack by pushing the same token onto the stack twice.
	            // curlyLastIndex ensures each token is pushed or popped exactly once
	            if (index > state.curlyLastIndex) {
	                state.curlyLastIndex = index;
	                if (code === 123) {
	                    state.curlyStack.push("{");
	                } else {
	                    state.curlyStack.pop();
	                }
	            }

	            return {
	                type: Token.Punctuator,
	                value: String.fromCharCode(code),
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                range: [start, index]
	            };

	        default:
	            code2 = source.charCodeAt(index + 1);

	            // "=" (char #61) marks an assignment or comparison operator.
	            if (code2 === 61) {
	                switch (code) {
	                    case 37:  // %
	                    case 38:  // &
	                    case 42:  // *:
	                    case 43:  // +
	                    case 45:  // -
	                    case 47:  // /
	                    case 60:  // <
	                    case 62:  // >
	                    case 94:  // ^
	                    case 124: // |
	                        index += 2;
	                        return {
	                            type: Token.Punctuator,
	                            value: String.fromCharCode(code) + String.fromCharCode(code2),
	                            lineNumber: lineNumber,
	                            lineStart: lineStart,
	                            range: [start, index]
	                        };

	                    case 33: // !
	                    case 61: // =
	                        index += 2;

	                        // !== and ===
	                        if (source.charCodeAt(index) === 61) {
	                            ++index;
	                        }
	                        return {
	                            type: Token.Punctuator,
	                            value: source.slice(start, index),
	                            lineNumber: lineNumber,
	                            lineStart: lineStart,
	                            range: [start, index]
	                        };
	                    default:
	                        break;
	                }
	            }
	            break;
	    }

	    // Peek more characters.

	    ch2 = source[index + 1];
	    ch3 = source[index + 2];
	    ch4 = source[index + 3];

	    // 4-character punctuator: >>>=

	    if (ch1 === ">" && ch2 === ">" && ch3 === ">") {
	        if (ch4 === "=") {
	            index += 4;
	            return {
	                type: Token.Punctuator,
	                value: ">>>=",
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                range: [start, index]
	            };
	        }
	    }

	    // 3-character punctuators: === !== >>> <<= >>=

	    if (ch1 === ">" && ch2 === ">" && ch3 === ">") {
	        index += 3;
	        return {
	            type: Token.Punctuator,
	            value: ">>>",
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            range: [start, index]
	        };
	    }

	    if (ch1 === "<" && ch2 === "<" && ch3 === "=") {
	        index += 3;
	        return {
	            type: Token.Punctuator,
	            value: "<<=",
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            range: [start, index]
	        };
	    }

	    if (ch1 === ">" && ch2 === ">" && ch3 === "=") {
	        index += 3;
	        return {
	            type: Token.Punctuator,
	            value: ">>=",
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            range: [start, index]
	        };
	    }

	    // The ... operator (spread, restParams, JSX, etc.)
	    if (extra.ecmaFeatures.spread ||
	        extra.ecmaFeatures.restParams ||
	        extra.ecmaFeatures.experimentalObjectRestSpread ||
	        (extra.ecmaFeatures.jsx && state.inJSXSpreadAttribute)
	    ) {
	        if (ch1 === "." && ch2 === "." && ch3 === ".") {
	            index += 3;
	            return {
	                type: Token.Punctuator,
	                value: "...",
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                range: [start, index]
	            };
	        }
	    }

	    // Other 2-character punctuators: ++ -- << >> && ||
	    if (ch1 === ch2 && ("+-<>&|".indexOf(ch1) >= 0)) {
	        index += 2;
	        return {
	            type: Token.Punctuator,
	            value: ch1 + ch2,
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            range: [start, index]
	        };
	    }

	    // the => for arrow functions
	    if (extra.ecmaFeatures.arrowFunctions) {
	        if (ch1 === "=" && ch2 === ">") {
	            index += 2;
	            return {
	                type: Token.Punctuator,
	                value: "=>",
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                range: [start, index]
	            };
	        }
	    }

	    if ("<>=!+-*%&|^/".indexOf(ch1) >= 0) {
	        ++index;
	        return {
	            type: Token.Punctuator,
	            value: ch1,
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            range: [start, index]
	        };
	    }

	    if (ch1 === ".") {
	        ++index;
	        return {
	            type: Token.Punctuator,
	            value: ch1,
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            range: [start, index]
	        };
	    }

	    throwError({}, Messages.UnexpectedToken, "ILLEGAL");
	}

	// 7.8.3 Numeric Literals

	function scanHexLiteral(start) {
	    var number = "";

	    while (index < length) {
	        if (!syntax.isHexDigit(source[index])) {
	            break;
	        }
	        number += source[index++];
	    }

	    if (number.length === 0) {
	        throwError({}, Messages.UnexpectedToken, "ILLEGAL");
	    }

	    if (syntax.isIdentifierStart(source.charCodeAt(index))) {
	        throwError({}, Messages.UnexpectedToken, "ILLEGAL");
	    }

	    return {
	        type: Token.NumericLiteral,
	        value: parseInt("0x" + number, 16),
	        lineNumber: lineNumber,
	        lineStart: lineStart,
	        range: [start, index]
	    };
	}

	function scanBinaryLiteral(start) {
	    var ch, number = "";

	    while (index < length) {
	        ch = source[index];
	        if (ch !== "0" && ch !== "1") {
	            break;
	        }
	        number += source[index++];
	    }

	    if (number.length === 0) {
	        // only 0b or 0B
	        throwError({}, Messages.UnexpectedToken, "ILLEGAL");
	    }


	    if (index < length) {
	        ch = source.charCodeAt(index);
	        /* istanbul ignore else */
	        if (syntax.isIdentifierStart(ch) || syntax.isDecimalDigit(ch)) {
	            throwError({}, Messages.UnexpectedToken, "ILLEGAL");
	        }
	    }

	    return {
	        type: Token.NumericLiteral,
	        value: parseInt(number, 2),
	        lineNumber: lineNumber,
	        lineStart: lineStart,
	        range: [start, index]
	    };
	}

	function scanOctalLiteral(prefix, start) {
	    var number, octal;

	    if (syntax.isOctalDigit(prefix)) {
	        octal = true;
	        number = "0" + source[index++];
	    } else {
	        octal = false;
	        ++index;
	        number = "";
	    }

	    while (index < length) {
	        if (!syntax.isOctalDigit(source[index])) {
	            break;
	        }
	        number += source[index++];
	    }

	    if (!octal && number.length === 0) {
	        // only 0o or 0O
	        throwError({}, Messages.UnexpectedToken, "ILLEGAL");
	    }

	    if (syntax.isIdentifierStart(source.charCodeAt(index)) || syntax.isDecimalDigit(source.charCodeAt(index))) {
	        throwError({}, Messages.UnexpectedToken, "ILLEGAL");
	    }

	    return {
	        type: Token.NumericLiteral,
	        value: parseInt(number, 8),
	        octal: octal,
	        lineNumber: lineNumber,
	        lineStart: lineStart,
	        range: [start, index]
	    };
	}

	function scanNumericLiteral() {
	    var number, start, ch;

	    ch = source[index];
	    assert(syntax.isDecimalDigit(ch.charCodeAt(0)) || (ch === "."),
	        "Numeric literal must start with a decimal digit or a decimal point");

	    start = index;
	    number = "";
	    if (ch !== ".") {
	        number = source[index++];
	        ch = source[index];

	        // Hex number starts with "0x".
	        // Octal number starts with "0".
	        if (number === "0") {
	            if (ch === "x" || ch === "X") {
	                ++index;
	                return scanHexLiteral(start);
	            }

	            // Binary number in ES6 starts with '0b'
	            if (extra.ecmaFeatures.binaryLiterals) {
	                if (ch === "b" || ch === "B") {
	                    ++index;
	                    return scanBinaryLiteral(start);
	                }
	            }

	            if ((extra.ecmaFeatures.octalLiterals && (ch === "o" || ch === "O")) || syntax.isOctalDigit(ch)) {
	                return scanOctalLiteral(ch, start);
	            }

	            // decimal number starts with "0" such as "09" is illegal.
	            if (ch && syntax.isDecimalDigit(ch.charCodeAt(0))) {
	                throwError({}, Messages.UnexpectedToken, "ILLEGAL");
	            }
	        }

	        while (syntax.isDecimalDigit(source.charCodeAt(index))) {
	            number += source[index++];
	        }
	        ch = source[index];
	    }

	    if (ch === ".") {
	        number += source[index++];
	        while (syntax.isDecimalDigit(source.charCodeAt(index))) {
	            number += source[index++];
	        }
	        ch = source[index];
	    }

	    if (ch === "e" || ch === "E") {
	        number += source[index++];

	        ch = source[index];
	        if (ch === "+" || ch === "-") {
	            number += source[index++];
	        }
	        if (syntax.isDecimalDigit(source.charCodeAt(index))) {
	            while (syntax.isDecimalDigit(source.charCodeAt(index))) {
	                number += source[index++];
	            }
	        } else {
	            throwError({}, Messages.UnexpectedToken, "ILLEGAL");
	        }
	    }

	    if (syntax.isIdentifierStart(source.charCodeAt(index))) {
	        throwError({}, Messages.UnexpectedToken, "ILLEGAL");
	    }

	    return {
	        type: Token.NumericLiteral,
	        value: parseFloat(number),
	        lineNumber: lineNumber,
	        lineStart: lineStart,
	        range: [start, index]
	    };
	}

	/**
	 * Scan a string escape sequence and return its special character.
	 * @param {string} ch The starting character of the given sequence.
	 * @returns {Object} An object containing the character and a flag
	 * if the escape sequence was an octal.
	 * @private
	 */
	function scanEscapeSequence(ch) {
	    var code,
	        unescaped,
	        restore,
	        escapedCh,
	        octal = false;

	    // An escape sequence cannot be empty
	    if (!ch) {
	        throwError({}, Messages.UnexpectedToken, "ILLEGAL");
	    }

	    if (syntax.isLineTerminator(ch.charCodeAt(0))) {
	        ++lineNumber;
	        if (ch === "\r" && source[index] === "\n") {
	            ++index;
	        }
	        lineStart = index;
	        escapedCh = "";
	    } else if (ch === "u" && source[index] === "{") {
	        // Handle ES6 extended unicode code point escape sequences.
	        if (extra.ecmaFeatures.unicodeCodePointEscapes) {
	            ++index;
	            escapedCh = scanUnicodeCodePointEscape();
	        } else {
	            throwError({}, Messages.UnexpectedToken, "ILLEGAL");
	        }
	    } else if (ch === "u" || ch === "x") {
	        // Handle other unicode and hex codes normally
	        restore = index;
	        unescaped = scanHexEscape(ch);
	        if (unescaped) {
	            escapedCh = unescaped;
	        } else {
	            index = restore;
	            escapedCh = ch;
	        }
	    } else if (ch === "n") {
	        escapedCh = "\n";
	    } else if (ch === "r") {
	        escapedCh = "\r";
	    } else if (ch === "t") {
	        escapedCh = "\t";
	    } else if (ch === "b") {
	        escapedCh = "\b";
	    } else if (ch === "f") {
	        escapedCh = "\f";
	    } else if (ch === "v") {
	        escapedCh = "\v";
	    } else if (syntax.isOctalDigit(ch)) {
	        code = "01234567".indexOf(ch);

	        // \0 is not octal escape sequence
	        if (code !== 0) {
	            octal = true;
	        }

	        if (index < length && syntax.isOctalDigit(source[index])) {
	            octal = true;
	            code = code * 8 + "01234567".indexOf(source[index++]);

	            // 3 digits are only allowed when string starts with 0, 1, 2, 3
	            if ("0123".indexOf(ch) >= 0 &&
	                    index < length &&
	                    syntax.isOctalDigit(source[index])) {
	                code = code * 8 + "01234567".indexOf(source[index++]);
	            }
	        }
	        escapedCh = String.fromCharCode(code);
	    } else {
	        escapedCh = ch;
	    }

	    return {
	        ch: escapedCh,
	        octal: octal
	    };
	}

	function scanStringLiteral() {
	    var str = "",
	        ch,
	        escapedSequence,
	        octal = false,
	        start = index,
	        startLineNumber = lineNumber,
	        startLineStart = lineStart,
	        quote = source[index];

	    assert((quote === "'" || quote === "\""),
	        "String literal must starts with a quote");

	    ++index;

	    while (index < length) {
	        ch = source[index++];

	        if (syntax.isLineTerminator(ch.charCodeAt(0))) {
	            break;
	        } else if (ch === quote) {
	            quote = "";
	            break;
	        } else if (ch === "\\") {
	            ch = source[index++];
	            escapedSequence = scanEscapeSequence(ch);
	            str += escapedSequence.ch;
	            octal = escapedSequence.octal || octal;
	        } else {
	            str += ch;
	        }
	    }

	    if (quote !== "") {
	        throwError({}, Messages.UnexpectedToken, "ILLEGAL");
	    }

	    return {
	        type: Token.StringLiteral,
	        value: str,
	        octal: octal,
	        startLineNumber: startLineNumber,
	        startLineStart: startLineStart,
	        lineNumber: lineNumber,
	        lineStart: lineStart,
	        range: [start, index]
	    };
	}

	/**
	 * Scan a template string and return a token. This scans both the first and
	 * subsequent pieces of a template string and assumes that the first backtick
	 * or the closing } have already been scanned.
	 * @returns {Token} The template string token.
	 * @private
	 */
	function scanTemplate() {
	    var cooked = "",
	        ch,
	        escapedSequence,
	        start = index,
	        terminated = false,
	        tail = false,
	        head = (source[index] === "`");

	    ++index;

	    while (index < length) {
	        ch = source[index++];

	        if (ch === "`") {
	            tail = true;
	            terminated = true;
	            break;
	        } else if (ch === "$") {
	            if (source[index] === "{") {
	                ++index;
	                terminated = true;
	                break;
	            }
	            cooked += ch;
	        } else if (ch === "\\") {
	            ch = source[index++];
	            escapedSequence = scanEscapeSequence(ch);

	            if (escapedSequence.octal) {
	                throwError({}, Messages.TemplateOctalLiteral);
	            }

	            cooked += escapedSequence.ch;

	        } else if (syntax.isLineTerminator(ch.charCodeAt(0))) {
	            ++lineNumber;
	            if (ch === "\r" && source[index] === "\n") {
	                ++index;
	            }
	            lineStart = index;
	            cooked += "\n";
	        } else {
	            cooked += ch;
	        }
	    }

	    if (!terminated) {
	        throwError({}, Messages.UnexpectedToken, "ILLEGAL");
	    }

	    if (index > state.curlyLastIndex) {
	        state.curlyLastIndex = index;

	        if (!tail) {
	            state.curlyStack.push("template");
	        }

	        if (!head) {
	            state.curlyStack.pop();
	        }
	    }

	    return {
	        type: Token.Template,
	        value: {
	            cooked: cooked,
	            raw: source.slice(start + 1, index - ((tail) ? 1 : 2))
	        },
	        head: head,
	        tail: tail,
	        lineNumber: lineNumber,
	        lineStart: lineStart,
	        range: [start, index]
	    };
	}

	function testRegExp(pattern, flags) {
	    var tmp = pattern,
	        validFlags = "gmsi";

	    if (extra.ecmaFeatures.regexYFlag) {
	        validFlags += "y";
	    }

	    if (extra.ecmaFeatures.regexUFlag) {
	        validFlags += "u";
	    }

	    if (!RegExp("^[" + validFlags + "]*$").test(flags)) {
	        throwError({}, Messages.InvalidRegExpFlag);
	    }


	    if (flags.indexOf("u") >= 0) {
	        // Replace each astral symbol and every Unicode code point
	        // escape sequence with a single ASCII symbol to avoid throwing on
	        // regular expressions that are only valid in combination with the
	        // `/u` flag.
	        // Note: replacing with the ASCII symbol `x` might cause false
	        // negatives in unlikely scenarios. For example, `[\u{61}-b]` is a
	        // perfectly valid pattern that is equivalent to `[a-b]`, but it
	        // would be replaced by `[x-b]` which throws an error.
	        tmp = tmp
	            .replace(/\\u\{([0-9a-fA-F]+)\}/g, function ($0, $1) {
	                if (parseInt($1, 16) <= 0x10FFFF) {
	                    return "x";
	                }
	                throwError({}, Messages.InvalidRegExp);
	            })
	            .replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x");
	    }

	    // First, detect invalid regular expressions.
	    try {
	        RegExp(tmp);
	    } catch (e) {
	        throwError({}, Messages.InvalidRegExp);
	    }

	    // Return a regular expression object for this pattern-flag pair, or
	    // `null` in case the current environment doesn't support the flags it
	    // uses.
	    try {
	        return new RegExp(pattern, flags);
	    } catch (exception) {
	        return null;
	    }
	}

	function scanRegExpBody() {
	    var ch, str, classMarker, terminated, body;

	    ch = source[index];
	    assert(ch === "/", "Regular expression literal must start with a slash");
	    str = source[index++];

	    classMarker = false;
	    terminated = false;
	    while (index < length) {
	        ch = source[index++];
	        str += ch;
	        if (ch === "\\") {
	            ch = source[index++];
	            // ECMA-262 7.8.5
	            if (syntax.isLineTerminator(ch.charCodeAt(0))) {
	                throwError({}, Messages.UnterminatedRegExp);
	            }
	            str += ch;
	        } else if (syntax.isLineTerminator(ch.charCodeAt(0))) {
	            throwError({}, Messages.UnterminatedRegExp);
	        } else if (classMarker) {
	            if (ch === "]") {
	                classMarker = false;
	            }
	        } else {
	            if (ch === "/") {
	                terminated = true;
	                break;
	            } else if (ch === "[") {
	                classMarker = true;
	            }
	        }
	    }

	    if (!terminated) {
	        throwError({}, Messages.UnterminatedRegExp);
	    }

	    // Exclude leading and trailing slash.
	    body = str.substr(1, str.length - 2);
	    return {
	        value: body,
	        literal: str
	    };
	}

	function scanRegExpFlags() {
	    var ch, str, flags, restore;

	    str = "";
	    flags = "";
	    while (index < length) {
	        ch = source[index];
	        if (!syntax.isIdentifierPart(ch.charCodeAt(0))) {
	            break;
	        }

	        ++index;
	        if (ch === "\\" && index < length) {
	            ch = source[index];
	            if (ch === "u") {
	                ++index;
	                restore = index;
	                ch = scanHexEscape("u");
	                if (ch) {
	                    flags += ch;
	                    for (str += "\\u"; restore < index; ++restore) {
	                        str += source[restore];
	                    }
	                } else {
	                    index = restore;
	                    flags += "u";
	                    str += "\\u";
	                }
	                throwErrorTolerant({}, Messages.UnexpectedToken, "ILLEGAL");
	            } else {
	                str += "\\";
	                throwErrorTolerant({}, Messages.UnexpectedToken, "ILLEGAL");
	            }
	        } else {
	            flags += ch;
	            str += ch;
	        }
	    }

	    return {
	        value: flags,
	        literal: str
	    };
	}

	function scanRegExp() {
	    var start, body, flags, value;

	    lookahead = null;
	    skipComment();
	    start = index;

	    body = scanRegExpBody();
	    flags = scanRegExpFlags();
	    value = testRegExp(body.value, flags.value);

	    if (extra.tokenize) {
	        return {
	            type: Token.RegularExpression,
	            value: value,
	            regex: {
	                pattern: body.value,
	                flags: flags.value
	            },
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            range: [start, index]
	        };
	    }

	    return {
	        literal: body.literal + flags.literal,
	        value: value,
	        regex: {
	            pattern: body.value,
	            flags: flags.value
	        },
	        range: [start, index]
	    };
	}

	function collectRegex() {
	    var pos, loc, regex, token;

	    skipComment();

	    pos = index;
	    loc = {
	        start: {
	            line: lineNumber,
	            column: index - lineStart
	        }
	    };

	    regex = scanRegExp();
	    loc.end = {
	        line: lineNumber,
	        column: index - lineStart
	    };

	    /* istanbul ignore next */
	    if (!extra.tokenize) {
	        // Pop the previous token, which is likely "/" or "/="
	        if (extra.tokens.length > 0) {
	            token = extra.tokens[extra.tokens.length - 1];
	            if (token.range[0] === pos && token.type === "Punctuator") {
	                if (token.value === "/" || token.value === "/=") {
	                    extra.tokens.pop();
	                }
	            }
	        }

	        extra.tokens.push({
	            type: "RegularExpression",
	            value: regex.literal,
	            regex: regex.regex,
	            range: [pos, index],
	            loc: loc
	        });
	    }

	    return regex;
	}

	function isIdentifierName(token) {
	    return token.type === Token.Identifier ||
	        token.type === Token.Keyword ||
	        token.type === Token.BooleanLiteral ||
	        token.type === Token.NullLiteral;
	}

	function advanceSlash() {
	    var prevToken,
	        checkToken;
	    // Using the following algorithm:
	    // https://github.com/mozilla/sweet.js/wiki/design
	    prevToken = extra.tokens[extra.tokens.length - 1];
	    if (!prevToken) {
	        // Nothing before that: it cannot be a division.
	        return collectRegex();
	    }
	    if (prevToken.type === "Punctuator") {
	        if (prevToken.value === "]") {
	            return scanPunctuator();
	        }
	        if (prevToken.value === ")") {
	            checkToken = extra.tokens[extra.openParenToken - 1];
	            if (checkToken &&
	                    checkToken.type === "Keyword" &&
	                    (checkToken.value === "if" ||
	                     checkToken.value === "while" ||
	                     checkToken.value === "for" ||
	                     checkToken.value === "with")) {
	                return collectRegex();
	            }
	            return scanPunctuator();
	        }
	        if (prevToken.value === "}") {
	            // Dividing a function by anything makes little sense,
	            // but we have to check for that.
	            if (extra.tokens[extra.openCurlyToken - 3] &&
	                    extra.tokens[extra.openCurlyToken - 3].type === "Keyword") {
	                // Anonymous function.
	                checkToken = extra.tokens[extra.openCurlyToken - 4];
	                if (!checkToken) {
	                    return scanPunctuator();
	                }
	            } else if (extra.tokens[extra.openCurlyToken - 4] &&
	                    extra.tokens[extra.openCurlyToken - 4].type === "Keyword") {
	                // Named function.
	                checkToken = extra.tokens[extra.openCurlyToken - 5];
	                if (!checkToken) {
	                    return collectRegex();
	                }
	            } else {
	                return scanPunctuator();
	            }
	            // checkToken determines whether the function is
	            // a declaration or an expression.
	            if (FnExprTokens.indexOf(checkToken.value) >= 0) {
	                // It is an expression.
	                return scanPunctuator();
	            }
	            // It is a declaration.
	            return collectRegex();
	        }
	        return collectRegex();
	    }
	    if (prevToken.type === "Keyword") {
	        return collectRegex();
	    }
	    return scanPunctuator();
	}

	function advance() {
	    var ch,
	        allowJSX = extra.ecmaFeatures.jsx,
	        allowTemplateStrings = extra.ecmaFeatures.templateStrings;

	    /*
	     * If JSX isn't allowed or JSX is allowed and we're not inside an JSX child,
	     * then skip any comments.
	     */
	    if (!allowJSX || !state.inJSXChild) {
	        skipComment();
	    }

	    if (index >= length) {
	        return {
	            type: Token.EOF,
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            range: [index, index]
	        };
	    }

	    // if inside an JSX child, then abort regular tokenization
	    if (allowJSX && state.inJSXChild) {
	        return advanceJSXChild();
	    }

	    ch = source.charCodeAt(index);

	    // Very common: ( and ) and ;
	    if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {
	        return scanPunctuator();
	    }

	    // String literal starts with single quote (U+0027) or double quote (U+0022).
	    if (ch === 0x27 || ch === 0x22) {
	        if (allowJSX && state.inJSXTag) {
	            return scanJSXStringLiteral();
	        }

	        return scanStringLiteral();
	    }

	    if (allowJSX && state.inJSXTag && syntax.isJSXIdentifierStart(ch)) {
	        return scanJSXIdentifier();
	    }

	    // Template strings start with backtick (U+0096) or closing curly brace (125) and backtick.
	    if (allowTemplateStrings) {

	        // template strings start with backtick (96) or open curly (125) but only if the open
	        // curly closes a previously opened curly from a template.
	        if (ch === 96 || (ch === 125 && state.curlyStack[state.curlyStack.length - 1] === "template")) {
	            return scanTemplate();
	        }
	    }

	    if (syntax.isIdentifierStart(ch)) {
	        return scanIdentifier();
	    }

	    // Dot (.) U+002E can also start a floating-point number, hence the need
	    // to check the next character.
	    if (ch === 0x2E) {
	        if (syntax.isDecimalDigit(source.charCodeAt(index + 1))) {
	            return scanNumericLiteral();
	        }
	        return scanPunctuator();
	    }

	    if (syntax.isDecimalDigit(ch)) {
	        return scanNumericLiteral();
	    }

	    // Slash (/) U+002F can also start a regex.
	    if (extra.tokenize && ch === 0x2F) {
	        return advanceSlash();
	    }

	    return scanPunctuator();
	}

	function collectToken() {
	    var loc, token, range, value, entry,
	        allowJSX = extra.ecmaFeatures.jsx;

	    /* istanbul ignore else */
	    if (!allowJSX || !state.inJSXChild) {
	        skipComment();
	    }

	    loc = {
	        start: {
	            line: lineNumber,
	            column: index - lineStart
	        }
	    };

	    token = advance();
	    loc.end = {
	        line: lineNumber,
	        column: index - lineStart
	    };

	    if (token.type !== Token.EOF) {
	        range = [token.range[0], token.range[1]];
	        value = source.slice(token.range[0], token.range[1]);
	        entry = {
	            type: TokenName[token.type],
	            value: value,
	            range: range,
	            loc: loc
	        };
	        if (token.regex) {
	            entry.regex = {
	                pattern: token.regex.pattern,
	                flags: token.regex.flags
	            };
	        }
	        extra.tokens.push(entry);
	    }

	    return token;
	}

	function lex() {
	    var token;

	    token = lookahead;
	    index = token.range[1];
	    lineNumber = token.lineNumber;
	    lineStart = token.lineStart;

	    lookahead = (typeof extra.tokens !== "undefined") ? collectToken() : advance();

	    index = token.range[1];
	    lineNumber = token.lineNumber;
	    lineStart = token.lineStart;

	    return token;
	}

	function peek() {
	    var pos,
	        line,
	        start;

	    pos = index;
	    line = lineNumber;
	    start = lineStart;

	    lookahead = (typeof extra.tokens !== "undefined") ? collectToken() : advance();

	    index = pos;
	    lineNumber = line;
	    lineStart = start;
	}

	function lookahead2() {
	    var adv, pos, line, start, result;

	    // If we are collecting the tokens, don't grab the next one yet.
	    /* istanbul ignore next */
	    adv = (typeof extra.advance === "function") ? extra.advance : advance;

	    pos = index;
	    line = lineNumber;
	    start = lineStart;

	    // Scan for the next immediate token.
	    /* istanbul ignore if */
	    if (lookahead === null) {
	        lookahead = adv();
	    }
	    index = lookahead.range[1];
	    lineNumber = lookahead.lineNumber;
	    lineStart = lookahead.lineStart;

	    // Grab the token right after.
	    result = adv();
	    index = pos;
	    lineNumber = line;
	    lineStart = start;

	    return result;
	}


	//------------------------------------------------------------------------------
	// JSX
	//------------------------------------------------------------------------------

	function getQualifiedJSXName(object) {
	    if (object.type === astNodeTypes.JSXIdentifier) {
	        return object.name;
	    }
	    if (object.type === astNodeTypes.JSXNamespacedName) {
	        return object.namespace.name + ":" + object.name.name;
	    }
	    /* istanbul ignore else */
	    if (object.type === astNodeTypes.JSXMemberExpression) {
	        return (
	            getQualifiedJSXName(object.object) + "." +
	            getQualifiedJSXName(object.property)
	        );
	    }
	    /* istanbul ignore next */
	    throwUnexpected(object);
	}

	function scanJSXIdentifier() {
	    var ch, start, value = "";

	    start = index;
	    while (index < length) {
	        ch = source.charCodeAt(index);
	        if (!syntax.isJSXIdentifierPart(ch)) {
	            break;
	        }
	        value += source[index++];
	    }

	    return {
	        type: Token.JSXIdentifier,
	        value: value,
	        lineNumber: lineNumber,
	        lineStart: lineStart,
	        range: [start, index]
	    };
	}

	function scanJSXEntity() {
	    var ch, str = "", start = index, count = 0, code;
	    ch = source[index];
	    assert(ch === "&", "Entity must start with an ampersand");
	    index++;
	    while (index < length && count++ < 10) {
	        ch = source[index++];
	        if (ch === ";") {
	            break;
	        }
	        str += ch;
	    }

	    // Well-formed entity (ending was found).
	    if (ch === ";") {
	        // Numeric entity.
	        if (str[0] === "#") {
	            if (str[1] === "x") {
	                code = +("0" + str.substr(1));
	            } else {
	                // Removing leading zeros in order to avoid treating as octal in old browsers.
	                code = +str.substr(1).replace(Regex.LeadingZeros, "");
	            }

	            if (!isNaN(code)) {
	                return String.fromCharCode(code);
	            }
	        /* istanbul ignore else */
	        } else if (XHTMLEntities[str]) {
	            return XHTMLEntities[str];
	        }
	    }

	    // Treat non-entity sequences as regular text.
	    index = start + 1;
	    return "&";
	}

	function scanJSXText(stopChars) {
	    var ch, str = "", start;
	    start = index;
	    while (index < length) {
	        ch = source[index];
	        if (stopChars.indexOf(ch) !== -1) {
	            break;
	        }
	        if (ch === "&") {
	            str += scanJSXEntity();
	        } else {
	            index++;
	            if (ch === "\r" && source[index] === "\n") {
	                str += ch;
	                ch = source[index];
	                index++;
	            }
	            if (syntax.isLineTerminator(ch.charCodeAt(0))) {
	                ++lineNumber;
	                lineStart = index;
	            }
	            str += ch;
	        }
	    }
	    return {
	        type: Token.JSXText,
	        value: str,
	        lineNumber: lineNumber,
	        lineStart: lineStart,
	        range: [start, index]
	    };
	}

	function scanJSXStringLiteral() {
	    var innerToken, quote, start;

	    quote = source[index];
	    assert((quote === "\"" || quote === "'"),
	        "String literal must starts with a quote");

	    start = index;
	    ++index;

	    innerToken = scanJSXText([quote]);

	    if (quote !== source[index]) {
	        throwError({}, Messages.UnexpectedToken, "ILLEGAL");
	    }

	    ++index;

	    innerToken.range = [start, index];

	    return innerToken;
	}

	/*
	 * Between JSX opening and closing tags (e.g. <foo>HERE</foo>), anything that
	 * is not another JSX tag and is not an expression wrapped by {} is text.
	 */
	function advanceJSXChild() {
	    var ch = source.charCodeAt(index);

	    // { (123) and < (60)
	    if (ch !== 123 && ch !== 60) {
	        return scanJSXText(["<", "{"]);
	    }

	    return scanPunctuator();
	}

	function parseJSXIdentifier() {
	    var token, marker = markerCreate();

	    if (lookahead.type !== Token.JSXIdentifier) {
	        throwUnexpected(lookahead);
	    }

	    token = lex();
	    return markerApply(marker, astNodeFactory.createJSXIdentifier(token.value));
	}

	function parseJSXNamespacedName() {
	    var namespace, name, marker = markerCreate();

	    namespace = parseJSXIdentifier();
	    expect(":");
	    name = parseJSXIdentifier();

	    return markerApply(marker, astNodeFactory.createJSXNamespacedName(namespace, name));
	}

	function parseJSXMemberExpression() {
	    var marker = markerCreate(),
	        expr = parseJSXIdentifier();

	    while (match(".")) {
	        lex();
	        expr = markerApply(marker, astNodeFactory.createJSXMemberExpression(expr, parseJSXIdentifier()));
	    }

	    return expr;
	}

	function parseJSXElementName() {
	    if (lookahead2().value === ":") {
	        return parseJSXNamespacedName();
	    }
	    if (lookahead2().value === ".") {
	        return parseJSXMemberExpression();
	    }

	    return parseJSXIdentifier();
	}

	function parseJSXAttributeName() {
	    if (lookahead2().value === ":") {
	        return parseJSXNamespacedName();
	    }

	    return parseJSXIdentifier();
	}

	function parseJSXAttributeValue() {
	    var value, marker;
	    if (match("{")) {
	        value = parseJSXExpressionContainer();
	        if (value.expression.type === astNodeTypes.JSXEmptyExpression) {
	            throwError(
	                value,
	                "JSX attributes must only be assigned a non-empty " +
	                    "expression"
	            );
	        }
	    } else if (match("<")) {
	        value = parseJSXElement();
	    } else if (lookahead.type === Token.JSXText) {
	        marker = markerCreate();
	        value = markerApply(marker, astNodeFactory.createLiteralFromSource(lex(), source));
	    } else {
	        throwError({}, Messages.InvalidJSXAttributeValue);
	    }
	    return value;
	}

	function parseJSXEmptyExpression() {
	    var marker = markerCreatePreserveWhitespace();
	    while (source.charAt(index) !== "}") {
	        index++;
	    }
	    return markerApply(marker, astNodeFactory.createJSXEmptyExpression());
	}

	function parseJSXExpressionContainer() {
	    var expression, origInJSXChild, origInJSXTag, marker = markerCreate();

	    origInJSXChild = state.inJSXChild;
	    origInJSXTag = state.inJSXTag;
	    state.inJSXChild = false;
	    state.inJSXTag = false;

	    expect("{");

	    if (match("}")) {
	        expression = parseJSXEmptyExpression();
	    } else {
	        expression = parseExpression();
	    }

	    state.inJSXChild = origInJSXChild;
	    state.inJSXTag = origInJSXTag;

	    expect("}");

	    return markerApply(marker, astNodeFactory.createJSXExpressionContainer(expression));
	}

	function parseJSXSpreadAttribute() {
	    var expression, origInJSXChild, origInJSXTag, marker = markerCreate();

	    origInJSXChild = state.inJSXChild;
	    origInJSXTag = state.inJSXTag;
	    state.inJSXChild = false;
	    state.inJSXTag = false;
	    state.inJSXSpreadAttribute = true;

	    expect("{");
	    expect("...");

	    state.inJSXSpreadAttribute = false;

	    expression = parseAssignmentExpression();

	    state.inJSXChild = origInJSXChild;
	    state.inJSXTag = origInJSXTag;

	    expect("}");

	    return markerApply(marker, astNodeFactory.createJSXSpreadAttribute(expression));
	}

	function parseJSXAttribute() {
	    var name, marker;

	    if (match("{")) {
	        return parseJSXSpreadAttribute();
	    }

	    marker = markerCreate();

	    name = parseJSXAttributeName();

	    // HTML empty attribute
	    if (match("=")) {
	        lex();
	        return markerApply(marker, astNodeFactory.createJSXAttribute(name, parseJSXAttributeValue()));
	    }

	    return markerApply(marker, astNodeFactory.createJSXAttribute(name));
	}

	function parseJSXChild() {
	    var token, marker;
	    if (match("{")) {
	        token = parseJSXExpressionContainer();
	    } else if (lookahead.type === Token.JSXText) {
	        marker = markerCreatePreserveWhitespace();
	        token = markerApply(marker, astNodeFactory.createLiteralFromSource(lex(), source));
	    } else {
	        token = parseJSXElement();
	    }
	    return token;
	}

	function parseJSXClosingElement() {
	    var name, origInJSXChild, origInJSXTag, marker = markerCreate();
	    origInJSXChild = state.inJSXChild;
	    origInJSXTag = state.inJSXTag;
	    state.inJSXChild = false;
	    state.inJSXTag = true;
	    expect("<");
	    expect("/");
	    name = parseJSXElementName();
	    // Because advance() (called by lex() called by expect()) expects there
	    // to be a valid token after >, it needs to know whether to look for a
	    // standard JS token or an JSX text node
	    state.inJSXChild = origInJSXChild;
	    state.inJSXTag = origInJSXTag;
	    expect(">");
	    return markerApply(marker, astNodeFactory.createJSXClosingElement(name));
	}

	function parseJSXOpeningElement() {
	    var name, attributes = [], selfClosing = false, origInJSXChild,
	        origInJSXTag, marker = markerCreate();

	    origInJSXChild = state.inJSXChild;
	    origInJSXTag = state.inJSXTag;
	    state.inJSXChild = false;
	    state.inJSXTag = true;

	    expect("<");

	    name = parseJSXElementName();

	    while (index < length &&
	            lookahead.value !== "/" &&
	            lookahead.value !== ">") {
	        attributes.push(parseJSXAttribute());
	    }

	    state.inJSXTag = origInJSXTag;

	    if (lookahead.value === "/") {
	        expect("/");
	        // Because advance() (called by lex() called by expect()) expects
	        // there to be a valid token after >, it needs to know whether to
	        // look for a standard JS token or an JSX text node
	        state.inJSXChild = origInJSXChild;
	        expect(">");
	        selfClosing = true;
	    } else {
	        state.inJSXChild = true;
	        expect(">");
	    }
	    return markerApply(marker, astNodeFactory.createJSXOpeningElement(name, attributes, selfClosing));
	}

	function parseJSXElement() {
	    var openingElement, closingElement = null, children = [], origInJSXChild, origInJSXTag, marker = markerCreate();

	    origInJSXChild = state.inJSXChild;
	    origInJSXTag = state.inJSXTag;
	    openingElement = parseJSXOpeningElement();

	    if (!openingElement.selfClosing) {
	        while (index < length) {
	            state.inJSXChild = false; // Call lookahead2() with inJSXChild = false because </ should not be considered in the child
	            if (lookahead.value === "<" && lookahead2().value === "/") {
	                break;
	            }
	            state.inJSXChild = true;
	            children.push(parseJSXChild());
	        }
	        state.inJSXChild = origInJSXChild;
	        state.inJSXTag = origInJSXTag;
	        closingElement = parseJSXClosingElement();
	        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
	            throwError({}, Messages.ExpectedJSXClosingTag, getQualifiedJSXName(openingElement.name));
	        }
	    }

	    /*
	     * When (erroneously) writing two adjacent tags like
	     *
	     *     var x = <div>one</div><div>two</div>;
	     *
	     * the default error message is a bit incomprehensible. Since it"s
	     * rarely (never?) useful to write a less-than sign after an JSX
	     * element, we disallow it here in the parser in order to provide a
	     * better error message. (In the rare case that the less-than operator
	     * was intended, the left tag can be wrapped in parentheses.)
	     */
	    if (!origInJSXChild && match("<")) {
	        throwError(lookahead, Messages.AdjacentJSXElements);
	    }

	    return markerApply(marker, astNodeFactory.createJSXElement(openingElement, closingElement, children));
	}

	//------------------------------------------------------------------------------
	// Location markers
	//------------------------------------------------------------------------------

	/**
	 * Applies location information to the given node by using the given marker.
	 * The marker indicates the point at which the node is said to have to begun
	 * in the source code.
	 * @param {Object} marker The marker to use for the node.
	 * @param {ASTNode} node The AST node to apply location information to.
	 * @returns {ASTNode} The node that was passed in.
	 * @private
	 */
	function markerApply(marker, node) {

	    // add range information to the node if present
	    if (extra.range) {
	        node.range = [marker.offset, index];
	    }

	    // add location information the node if present
	    if (extra.loc) {
	        node.loc = {
	            start: {
	                line: marker.line,
	                column: marker.col
	            },
	            end: {
	                line: lineNumber,
	                column: index - lineStart
	            }
	        };
	        // Attach extra.source information to the location, if present
	        if (extra.source) {
	            node.loc.source = extra.source;
	        }
	    }

	    // attach leading and trailing comments if requested
	    if (extra.attachComment) {
	        commentAttachment.processComment(node);
	    }

	    return node;
	}

	/**
	 * Creates a location marker in the source code. Location markers are used for
	 * tracking where tokens and nodes appear in the source code.
	 * @returns {Object} A marker object or undefined if the parser doesn't have
	 *      any location information.
	 * @private
	 */
	function markerCreate() {

	    if (!extra.loc && !extra.range) {
	        return undefined;
	    }

	    skipComment();

	    return {
	        offset: index,
	        line: lineNumber,
	        col: index - lineStart
	    };
	}

	/**
	 * Creates a location marker in the source code. Location markers are used for
	 * tracking where tokens and nodes appear in the source code. This method
	 * doesn't skip comments or extra whitespace which is important for JSX.
	 * @returns {Object} A marker object or undefined if the parser doesn't have
	 *      any location information.
	 * @private
	 */
	function markerCreatePreserveWhitespace() {

	    if (!extra.loc && !extra.range) {
	        return undefined;
	    }

	    return {
	        offset: index,
	        line: lineNumber,
	        col: index - lineStart
	    };
	}


	//------------------------------------------------------------------------------
	// Syntax Tree Delegate
	//------------------------------------------------------------------------------

	// Return true if there is a line terminator before the next token.

	function peekLineTerminator() {
	    var pos, line, start, found;

	    pos = index;
	    line = lineNumber;
	    start = lineStart;
	    skipComment();
	    found = lineNumber !== line;
	    index = pos;
	    lineNumber = line;
	    lineStart = start;

	    return found;
	}

	// Throw an exception

	function throwError(token, messageFormat) {

	    var error,
	        args = Array.prototype.slice.call(arguments, 2),
	        msg = messageFormat.replace(
	            /%(\d)/g,
	            function (whole, index) {
	                assert(index < args.length, "Message reference must be in range");
	                return args[index];
	            }
	        );

	    if (typeof token.lineNumber === "number") {
	        error = new Error("Line " + token.lineNumber + ": " + msg);
	        error.index = token.range[0];
	        error.lineNumber = token.lineNumber;
	        error.column = token.range[0] - token.lineStart + 1;
	    } else {
	        error = new Error("Line " + lineNumber + ": " + msg);
	        error.index = index;
	        error.lineNumber = lineNumber;
	        error.column = index - lineStart + 1;
	    }

	    error.description = msg;
	    throw error;
	}

	function throwErrorTolerant() {
	    try {
	        throwError.apply(null, arguments);
	    } catch (e) {
	        if (extra.errors) {
	            extra.errors.push(e);
	        } else {
	            throw e;
	        }
	    }
	}


	// Throw an exception because of the token.

	function throwUnexpected(token) {

	    if (token.type === Token.EOF) {
	        throwError(token, Messages.UnexpectedEOS);
	    }

	    if (token.type === Token.NumericLiteral) {
	        throwError(token, Messages.UnexpectedNumber);
	    }

	    if (token.type === Token.StringLiteral || token.type === Token.JSXText) {
	        throwError(token, Messages.UnexpectedString);
	    }

	    if (token.type === Token.Identifier) {
	        throwError(token, Messages.UnexpectedIdentifier);
	    }

	    if (token.type === Token.Keyword) {
	        if (syntax.isFutureReservedWord(token.value)) {
	            throwError(token, Messages.UnexpectedReserved);
	        } else if (strict && syntax.isStrictModeReservedWord(token.value, extra.ecmaFeatures)) {
	            throwErrorTolerant(token, Messages.StrictReservedWord);
	            return;
	        }
	        throwError(token, Messages.UnexpectedToken, token.value);
	    }

	    if (token.type === Token.Template) {
	        throwError(token, Messages.UnexpectedTemplate, token.value.raw);
	    }

	    // BooleanLiteral, NullLiteral, or Punctuator.
	    throwError(token, Messages.UnexpectedToken, token.value);
	}

	// Expect the next token to match the specified punctuator.
	// If not, an exception will be thrown.

	function expect(value) {
	    var token = lex();
	    if (token.type !== Token.Punctuator || token.value !== value) {
	        throwUnexpected(token);
	    }
	}

	// Expect the next token to match the specified keyword.
	// If not, an exception will be thrown.

	function expectKeyword(keyword) {
	    var token = lex();
	    if (token.type !== Token.Keyword || token.value !== keyword) {
	        throwUnexpected(token);
	    }
	}

	// Return true if the next token matches the specified punctuator.

	function match(value) {
	    return lookahead.type === Token.Punctuator && lookahead.value === value;
	}

	// Return true if the next token matches the specified keyword

	function matchKeyword(keyword) {
	    return lookahead.type === Token.Keyword && lookahead.value === keyword;
	}

	// Return true if the next token matches the specified contextual keyword
	// (where an identifier is sometimes a keyword depending on the context)

	function matchContextualKeyword(keyword) {
	    return lookahead.type === Token.Identifier && lookahead.value === keyword;
	}

	// Return true if the next token is an assignment operator

	function matchAssign() {
	    var op;

	    if (lookahead.type !== Token.Punctuator) {
	        return false;
	    }
	    op = lookahead.value;
	    return op === "=" ||
	        op === "*=" ||
	        op === "/=" ||
	        op === "%=" ||
	        op === "+=" ||
	        op === "-=" ||
	        op === "<<=" ||
	        op === ">>=" ||
	        op === ">>>=" ||
	        op === "&=" ||
	        op === "^=" ||
	        op === "|=";
	}

	function consumeSemicolon() {
	    var line;

	    // Catch the very common case first: immediately a semicolon (U+003B).
	    if (source.charCodeAt(index) === 0x3B || match(";")) {
	        lex();
	        return;
	    }

	    line = lineNumber;
	    skipComment();
	    if (lineNumber !== line) {
	        return;
	    }

	    if (lookahead.type !== Token.EOF && !match("}")) {
	        throwUnexpected(lookahead);
	    }
	}

	// Return true if provided expression is LeftHandSideExpression

	function isLeftHandSide(expr) {
	    return expr.type === astNodeTypes.Identifier || expr.type === astNodeTypes.MemberExpression;
	}

	// 11.1.4 Array Initialiser

	function parseArrayInitialiser() {
	    var elements = [],
	        marker = markerCreate(),
	        tmp;

	    expect("[");

	    while (!match("]")) {
	        if (match(",")) {
	            lex(); // only get here when you have [a,,] or similar
	            elements.push(null);
	        } else {
	            tmp = parseSpreadOrAssignmentExpression();
	            elements.push(tmp);
	            if (!(match("]"))) {
	                expect(","); // handles the common case of comma-separated values
	            }
	        }
	    }

	    expect("]");

	    return markerApply(marker, astNodeFactory.createArrayExpression(elements));
	}

	// 11.1.5 Object Initialiser

	function parsePropertyFunction(paramInfo, options) {
	    var previousStrict = strict,
	        previousYieldAllowed = state.yieldAllowed,
	        generator = options ? options.generator : false,
	        body;

	    state.yieldAllowed = generator;

	    /*
	     * Esprima uses parseConciseBody() here, which is incorrect. Object literal
	     * methods must have braces.
	     */
	    body = parseFunctionSourceElements();

	    if (strict && paramInfo.firstRestricted) {
	        throwErrorTolerant(paramInfo.firstRestricted, Messages.StrictParamName);
	    }

	    if (strict && paramInfo.stricted) {
	        throwErrorTolerant(paramInfo.stricted, paramInfo.message);
	    }

	    strict = previousStrict;
	    state.yieldAllowed = previousYieldAllowed;

	    return markerApply(options.marker, astNodeFactory.createFunctionExpression(
	        null,
	        paramInfo.params,
	        body,
	        generator,
	        body.type !== astNodeTypes.BlockStatement
	    ));
	}

	function parsePropertyMethodFunction(options) {
	    var previousStrict = strict,
	        marker = markerCreate(),
	        params,
	        method;

	    strict = true;

	    params = parseParams();

	    if (params.stricted) {
	        throwErrorTolerant(params.stricted, params.message);
	    }

	    method = parsePropertyFunction(params, {
	        generator: options ? options.generator : false,
	        marker: marker
	    });

	    strict = previousStrict;

	    return method;
	}

	function parseObjectPropertyKey() {
	    var marker = markerCreate(),
	        token = lex(),
	        allowObjectLiteralComputed = extra.ecmaFeatures.objectLiteralComputedProperties,
	        expr,
	        result;

	    // Note: This function is called only from parseObjectProperty(), where
	    // EOF and Punctuator tokens are already filtered out.

	    switch (token.type) {
	        case Token.StringLiteral:
	        case Token.NumericLiteral:
	            if (strict && token.octal) {
	                throwErrorTolerant(token, Messages.StrictOctalLiteral);
	            }
	            return markerApply(marker, astNodeFactory.createLiteralFromSource(token, source));

	        case Token.Identifier:
	        case Token.BooleanLiteral:
	        case Token.NullLiteral:
	        case Token.Keyword:
	            return markerApply(marker, astNodeFactory.createIdentifier(token.value));

	        case Token.Punctuator:
	            if ((!state.inObjectLiteral || allowObjectLiteralComputed) &&
	                    token.value === "[") {
	                // For computed properties we should skip the [ and ], and
	                // capture in marker only the assignment expression itself.
	                marker = markerCreate();
	                expr = parseAssignmentExpression();
	                result = markerApply(marker, expr);
	                expect("]");
	                return result;
	            }

	        // no default
	    }

	    throwUnexpected(token);
	}

	function lookaheadPropertyName() {
	    switch (lookahead.type) {
	        case Token.Identifier:
	        case Token.StringLiteral:
	        case Token.BooleanLiteral:
	        case Token.NullLiteral:
	        case Token.NumericLiteral:
	        case Token.Keyword:
	            return true;
	        case Token.Punctuator:
	            return lookahead.value === "[";
	        // no default
	    }
	    return false;
	}

	// This function is to try to parse a MethodDefinition as defined in 14.3. But in the case of object literals,
	// it might be called at a position where there is in fact a short hand identifier pattern or a data property.
	// This can only be determined after we consumed up to the left parentheses.
	// In order to avoid back tracking, it returns `null` if the position is not a MethodDefinition and the caller
	// is responsible to visit other options.
	function tryParseMethodDefinition(token, key, computed, marker) {
	    var value, options, methodMarker;

	    if (token.type === Token.Identifier) {
	        // check for `get` and `set`;

	        if (token.value === "get" && lookaheadPropertyName()) {

	            computed = match("[");
	            key = parseObjectPropertyKey();
	            methodMarker = markerCreate();
	            expect("(");
	            expect(")");

	            value = parsePropertyFunction({
	                params: [],
	                stricted: null,
	                firstRestricted: null,
	                message: null
	            }, {
	                marker: methodMarker
	            });

	            return markerApply(marker, astNodeFactory.createProperty("get", key, value, false, false, computed));

	        } else if (token.value === "set" && lookaheadPropertyName()) {
	            computed = match("[");
	            key = parseObjectPropertyKey();
	            methodMarker = markerCreate();
	            expect("(");

	            options = {
	                params: [],
	                defaultCount: 0,
	                stricted: null,
	                firstRestricted: null,
	                paramSet: new StringMap()
	            };
	            if (match(")")) {
	                throwErrorTolerant(lookahead, Messages.UnexpectedToken, lookahead.value);
	            } else {
	                parseParam(options);
	            }
	            expect(")");

	            value = parsePropertyFunction(options, { marker: methodMarker });
	            return markerApply(marker, astNodeFactory.createProperty("set", key, value, false, false, computed));
	        }
	    }

	    if (match("(")) {
	        value = parsePropertyMethodFunction();
	        return markerApply(marker, astNodeFactory.createProperty("init", key, value, true, false, computed));
	    }

	    // Not a MethodDefinition.
	    return null;
	}

	/**
	 * Parses Generator Properties
	 * @param {ASTNode} key The property key (usually an identifier).
	 * @param {Object} marker The marker to use for the node.
	 * @returns {ASTNode} The generator property node.
	 */
	function parseGeneratorProperty(key, marker) {

	    var computed = (lookahead.type === Token.Punctuator && lookahead.value === "[");

	    if (!match("(")) {
	        throwUnexpected(lex());
	    }

	    return markerApply(
	        marker,
	        astNodeFactory.createProperty(
	            "init",
	            key,
	            parsePropertyMethodFunction({ generator: true }),
	            true,
	            false,
	            computed
	        )
	    );
	}

	// TODO(nzakas): Update to match Esprima
	function parseObjectProperty() {
	    var token, key, id, computed, methodMarker, options;
	    var allowComputed = extra.ecmaFeatures.objectLiteralComputedProperties,
	        allowMethod = extra.ecmaFeatures.objectLiteralShorthandMethods,
	        allowShorthand = extra.ecmaFeatures.objectLiteralShorthandProperties,
	        allowGenerators = extra.ecmaFeatures.generators,
	        allowDestructuring = extra.ecmaFeatures.destructuring,
	        allowSpread = extra.ecmaFeatures.experimentalObjectRestSpread,
	        marker = markerCreate();

	    token = lookahead;
	    computed = (token.value === "[" && token.type === Token.Punctuator);

	    if (token.type === Token.Identifier || (allowComputed && computed)) {

	        id = parseObjectPropertyKey();

	        /*
	         * Check for getters and setters. Be careful! "get" and "set" are legal
	         * method names. It's only a getter or setter if followed by a space.
	         */
	        if (token.value === "get" &&
	                !(match(":") || match("(") || match(",") || match("}"))) {
	            computed = (lookahead.value === "[");
	            key = parseObjectPropertyKey();
	            methodMarker = markerCreate();
	            expect("(");
	            expect(")");

	            return markerApply(
	                marker,
	                astNodeFactory.createProperty(
	                    "get",
	                    key,
	                    parsePropertyFunction({
	                        generator: false
	                    }, {
	                        marker: methodMarker
	                    }),
	                    false,
	                    false,
	                    computed
	                )
	            );
	        }

	        if (token.value === "set" &&
	                !(match(":") || match("(") || match(",") || match("}"))) {
	            computed = (lookahead.value === "[");
	            key = parseObjectPropertyKey();
	            methodMarker = markerCreate();
	            expect("(");

	            options = {
	                params: [],
	                defaultCount: 0,
	                stricted: null,
	                firstRestricted: null,
	                paramSet: new StringMap()
	            };

	            if (match(")")) {
	                throwErrorTolerant(lookahead, Messages.UnexpectedToken, lookahead.value);
	            } else {
	                parseParam(options);
	            }

	            expect(")");

	            return markerApply(
	                marker,
	                astNodeFactory.createProperty(
	                    "set",
	                    key,
	                    parsePropertyFunction(options, {
	                        marker: methodMarker
	                    }),
	                    false,
	                    false,
	                    computed
	                )
	            );
	        }

	        // normal property (key:value)
	        if (match(":")) {
	            lex();
	            return markerApply(
	                marker,
	                astNodeFactory.createProperty(
	                    "init",
	                    id,
	                    parseAssignmentExpression(),
	                    false,
	                    false,
	                    computed
	                )
	            );
	        }

	        // method shorthand (key(){...})
	        if (allowMethod && match("(")) {
	            return markerApply(
	                marker,
	                astNodeFactory.createProperty(
	                    "init",
	                    id,
	                    parsePropertyMethodFunction({ generator: false }),
	                    true,
	                    false,
	                    computed
	                )
	            );
	        }

	        // destructuring defaults (shorthand syntax)
	        if (allowDestructuring && match("=")) {
	            lex();
	            var value = parseAssignmentExpression();
	            var prop = markerApply(marker, astNodeFactory.createAssignmentExpression("=", id, value));
	            prop.type = astNodeTypes.AssignmentPattern;
	            var fullProperty = astNodeFactory.createProperty(
	                "init",
	                id,
	                prop,
	                false,
	                true, // shorthand
	                computed
	            );
	            return markerApply(marker, fullProperty);
	        }

	        /*
	         * Only other possibility is that this is a shorthand property. Computed
	         * properties cannot use shorthand notation, so that's a syntax error.
	         * If shorthand properties aren't allow, then this is an automatic
	         * syntax error. Destructuring is another case with a similar shorthand syntax.
	         */
	        if (computed || (!allowShorthand && !allowDestructuring)) {
	            throwUnexpected(lookahead);
	        }

	        // shorthand property
	        return markerApply(
	            marker,
	            astNodeFactory.createProperty(
	                "init",
	                id,
	                id,
	                false,
	                true,
	                false
	            )
	        );
	    }

	    // object spread property
	    if (allowSpread && match("...")) {
	        lex();
	        return markerApply(marker, astNodeFactory.createExperimentalSpreadProperty(parseAssignmentExpression()));
	    }

	    // only possibility in this branch is a shorthand generator
	    if (token.type === Token.EOF || token.type === Token.Punctuator) {
	        if (!allowGenerators || !match("*") || !allowMethod) {
	            throwUnexpected(token);
	        }

	        lex();

	        id = parseObjectPropertyKey();

	        return parseGeneratorProperty(id, marker);

	    }

	    /*
	     * If we've made it here, then that means the property name is represented
	     * by a string (i.e, { "foo": 2}). The only options here are normal
	     * property with a colon or a method.
	     */
	    key = parseObjectPropertyKey();

	    // check for property value
	    if (match(":")) {
	        lex();
	        return markerApply(
	            marker,
	            astNodeFactory.createProperty(
	                "init",
	                key,
	                parseAssignmentExpression(),
	                false,
	                false,
	                false
	            )
	        );
	    }

	    // check for method
	    if (allowMethod && match("(")) {
	        return markerApply(
	            marker,
	            astNodeFactory.createProperty(
	                "init",
	                key,
	                parsePropertyMethodFunction(),
	                true,
	                false,
	                false
	            )
	        );
	    }

	    // no other options, this is bad
	    throwUnexpected(lex());
	}

	function getFieldName(key) {
	    var toString = String;
	    if (key.type === astNodeTypes.Identifier) {
	        return key.name;
	    }
	    return toString(key.value);
	}

	function parseObjectInitialiser() {
	    var marker = markerCreate(),
	        allowDuplicates = extra.ecmaFeatures.objectLiteralDuplicateProperties,
	        properties = [],
	        property,
	        name,
	        propertyFn,
	        kind,
	        storedKind,
	        previousInObjectLiteral = state.inObjectLiteral,
	        kindMap = new StringMap();

	    state.inObjectLiteral = true;

	    expect("{");

	    while (!match("}")) {

	        property = parseObjectProperty();

	        if (!property.computed && property.type.indexOf("Experimental") === -1) {

	            name = getFieldName(property.key);
	            propertyFn = (property.kind === "get") ? PropertyKind.Get : PropertyKind.Set;
	            kind = (property.kind === "init") ? PropertyKind.Data : propertyFn;

	            if (kindMap.has(name)) {
	                storedKind = kindMap.get(name);
	                if (storedKind === PropertyKind.Data) {
	                    if (kind === PropertyKind.Data && name === "__proto__" && allowDuplicates) {
	                        // Duplicate '__proto__' literal properties are forbidden in ES 6
	                        throwErrorTolerant({}, Messages.DuplicatePrototypeProperty);
	                    } else if (strict && kind === PropertyKind.Data && !allowDuplicates) {
	                        // Duplicate literal properties are only forbidden in ES 5 strict mode
	                        throwErrorTolerant({}, Messages.StrictDuplicateProperty);
	                    } else if (kind !== PropertyKind.Data) {
	                        throwErrorTolerant({}, Messages.AccessorDataProperty);
	                    }
	                } else {
	                    if (kind === PropertyKind.Data) {
	                        throwErrorTolerant({}, Messages.AccessorDataProperty);
	                    } else if (storedKind & kind) {
	                        throwErrorTolerant({}, Messages.AccessorGetSet);
	                    }
	                }
	                kindMap.set(name, storedKind | kind);
	            } else {
	                kindMap.set(name, kind);
	            }
	        }

	        properties.push(property);

	        if (!match("}")) {
	            expect(",");
	        }
	    }

	    expect("}");

	    state.inObjectLiteral = previousInObjectLiteral;

	    return markerApply(marker, astNodeFactory.createObjectExpression(properties));
	}

	/**
	 * Parse a template string element and return its ASTNode representation
	 * @param {Object} option Parsing & scanning options
	 * @param {Object} option.head True if this element is the first in the
	 *                               template string, false otherwise.
	 * @returns {ASTNode} The template element node with marker info applied
	 * @private
	 */
	function parseTemplateElement(option) {
	    var marker, token;

	    if (lookahead.type !== Token.Template || (option.head && !lookahead.head)) {
	        throwError({}, Messages.UnexpectedToken, "ILLEGAL");
	    }

	    marker = markerCreate();
	    token = lex();

	    return markerApply(
	        marker,
	        astNodeFactory.createTemplateElement(
	            {
	                raw: token.value.raw,
	                cooked: token.value.cooked
	            },
	            token.tail
	        )
	    );
	}

	/**
	 * Parse a template string literal and return its ASTNode representation
	 * @returns {ASTNode} The template literal node with marker info applied
	 * @private
	 */
	function parseTemplateLiteral() {
	    var quasi, quasis, expressions, marker = markerCreate();

	    quasi = parseTemplateElement({ head: true });
	    quasis = [ quasi ];
	    expressions = [];

	    while (!quasi.tail) {
	        expressions.push(parseExpression());
	        quasi = parseTemplateElement({ head: false });
	        quasis.push(quasi);
	    }

	    return markerApply(marker, astNodeFactory.createTemplateLiteral(quasis, expressions));
	}

	// 11.1.6 The Grouping Operator

	function parseGroupExpression() {
	    var expr;

	    expect("(");

	    ++state.parenthesisCount;

	    expr = parseExpression();

	    expect(")");

	    return expr;
	}


	// 11.1 Primary Expressions

	function parsePrimaryExpression() {
	    var type, token, expr,
	        marker,
	        allowJSX = extra.ecmaFeatures.jsx,
	        allowClasses = extra.ecmaFeatures.classes,
	        allowSuper = allowClasses || extra.ecmaFeatures.superInFunctions;

	    if (match("(")) {
	        return parseGroupExpression();
	    }

	    if (match("[")) {
	        return parseArrayInitialiser();
	    }

	    if (match("{")) {
	        return parseObjectInitialiser();
	    }

	    if (allowJSX && match("<")) {
	        return parseJSXElement();
	    }

	    type = lookahead.type;
	    marker = markerCreate();

	    if (type === Token.Identifier) {
	        expr = astNodeFactory.createIdentifier(lex().value);
	    } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {
	        if (strict && lookahead.octal) {
	            throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);
	        }
	        expr = astNodeFactory.createLiteralFromSource(lex(), source);
	    } else if (type === Token.Keyword) {
	        if (matchKeyword("function")) {
	            return parseFunctionExpression();
	        }

	        if (allowSuper && matchKeyword("super") && state.inFunctionBody) {
	            marker = markerCreate();
	            lex();
	            return markerApply(marker, astNodeFactory.createSuper());
	        }

	        if (matchKeyword("this")) {
	            marker = markerCreate();
	            lex();
	            return markerApply(marker, astNodeFactory.createThisExpression());
	        }

	        if (allowClasses && matchKeyword("class")) {
	            return parseClassExpression();
	        }

	        throwUnexpected(lex());
	    } else if (type === Token.BooleanLiteral) {
	        token = lex();
	        token.value = (token.value === "true");
	        expr = astNodeFactory.createLiteralFromSource(token, source);
	    } else if (type === Token.NullLiteral) {
	        token = lex();
	        token.value = null;
	        expr = astNodeFactory.createLiteralFromSource(token, source);
	    } else if (match("/") || match("/=")) {
	        if (typeof extra.tokens !== "undefined") {
	            expr = astNodeFactory.createLiteralFromSource(collectRegex(), source);
	        } else {
	            expr = astNodeFactory.createLiteralFromSource(scanRegExp(), source);
	        }
	        peek();
	    } else if (type === Token.Template) {
	        return parseTemplateLiteral();
	    } else {
	       throwUnexpected(lex());
	    }

	    return markerApply(marker, expr);
	}

	// 11.2 Left-Hand-Side Expressions

	function parseArguments() {
	    var args = [], arg;

	    expect("(");
	    if (!match(")")) {
	        while (index < length) {
	            arg = parseSpreadOrAssignmentExpression();
	            args.push(arg);

	            if (match(")")) {
	                break;
	            }

	            expect(",");
	        }
	    }

	    expect(")");

	    return args;
	}

	function parseSpreadOrAssignmentExpression() {
	    if (match("...")) {
	        var marker = markerCreate();
	        lex();
	        return markerApply(marker, astNodeFactory.createSpreadElement(parseAssignmentExpression()));
	    }
	    return parseAssignmentExpression();
	}

	function parseNonComputedProperty() {
	    var token,
	        marker = markerCreate();

	    token = lex();

	    if (!isIdentifierName(token)) {
	        throwUnexpected(token);
	    }

	    return markerApply(marker, astNodeFactory.createIdentifier(token.value));
	}

	function parseNonComputedMember() {
	    expect(".");

	    return parseNonComputedProperty();
	}

	function parseComputedMember() {
	    var expr;

	    expect("[");

	    expr = parseExpression();

	    expect("]");

	    return expr;
	}

	function parseNewExpression() {
	    var callee, args,
	        marker = markerCreate();

	    expectKeyword("new");

	    if (extra.ecmaFeatures.newTarget && match(".")) {
	        lex();
	        if (lookahead.type === Token.Identifier && lookahead.value === "target") {
	            if (state.inFunctionBody) {
	                lex();
	                return markerApply(marker, astNodeFactory.createMetaProperty("new", "target"));
	            }
	        }

	        throwUnexpected(lookahead);
	    }

	    callee = parseLeftHandSideExpression();
	    args = match("(") ? parseArguments() : [];

	    return markerApply(marker, astNodeFactory.createNewExpression(callee, args));
	}

	function parseLeftHandSideExpressionAllowCall() {
	    var expr, args,
	        previousAllowIn = state.allowIn,
	        marker = markerCreate();

	    state.allowIn = true;
	    expr = matchKeyword("new") ? parseNewExpression() : parsePrimaryExpression();
	    state.allowIn = previousAllowIn;

	    // only start parsing template literal if the lookahead is a head (beginning with `)
	    while (match(".") || match("[") || match("(") || (lookahead.type === Token.Template && lookahead.head)) {
	        if (match("(")) {
	            args = parseArguments();
	            expr = markerApply(marker, astNodeFactory.createCallExpression(expr, args));
	        } else if (match("[")) {
	            expr = markerApply(marker, astNodeFactory.createMemberExpression("[", expr, parseComputedMember()));
	        } else if (match(".")) {
	            expr = markerApply(marker, astNodeFactory.createMemberExpression(".", expr, parseNonComputedMember()));
	        } else {
	            expr = markerApply(marker, astNodeFactory.createTaggedTemplateExpression(expr, parseTemplateLiteral()));
	        }
	    }

	    return expr;
	}

	function parseLeftHandSideExpression() {
	    var expr,
	        previousAllowIn = state.allowIn,
	        marker = markerCreate();

	    expr = matchKeyword("new") ? parseNewExpression() : parsePrimaryExpression();
	    state.allowIn = previousAllowIn;

	    // only start parsing template literal if the lookahead is a head (beginning with `)
	    while (match(".") || match("[") || (lookahead.type === Token.Template && lookahead.head)) {
	        if (match("[")) {
	            expr = markerApply(marker, astNodeFactory.createMemberExpression("[", expr, parseComputedMember()));
	        } else if (match(".")) {
	            expr = markerApply(marker, astNodeFactory.createMemberExpression(".", expr, parseNonComputedMember()));
	        } else {
	            expr = markerApply(marker, astNodeFactory.createTaggedTemplateExpression(expr, parseTemplateLiteral()));
	        }
	    }

	    return expr;
	}


	// 11.3 Postfix Expressions

	function parsePostfixExpression() {
	    var expr, token,
	        marker = markerCreate();

	    expr = parseLeftHandSideExpressionAllowCall();

	    if (lookahead.type === Token.Punctuator) {
	        if ((match("++") || match("--")) && !peekLineTerminator()) {
	            // 11.3.1, 11.3.2
	            if (strict && expr.type === astNodeTypes.Identifier && syntax.isRestrictedWord(expr.name)) {
	                throwErrorTolerant({}, Messages.StrictLHSPostfix);
	            }

	            if (!isLeftHandSide(expr)) {
	                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
	            }

	            token = lex();
	            expr = markerApply(marker, astNodeFactory.createPostfixExpression(token.value, expr));
	        }
	    }

	    return expr;
	}

	// 11.4 Unary Operators

	function parseUnaryExpression() {
	    var token, expr,
	        marker;

	    if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
	        expr = parsePostfixExpression();
	    } else if (match("++") || match("--")) {
	        marker = markerCreate();
	        token = lex();
	        expr = parseUnaryExpression();
	        // 11.4.4, 11.4.5
	        if (strict && expr.type === astNodeTypes.Identifier && syntax.isRestrictedWord(expr.name)) {
	            throwErrorTolerant({}, Messages.StrictLHSPrefix);
	        }

	        if (!isLeftHandSide(expr)) {
	            throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
	        }

	        expr = astNodeFactory.createUnaryExpression(token.value, expr);
	        expr = markerApply(marker, expr);
	    } else if (match("+") || match("-") || match("~") || match("!")) {
	        marker = markerCreate();
	        token = lex();
	        expr = parseUnaryExpression();
	        expr = astNodeFactory.createUnaryExpression(token.value, expr);
	        expr = markerApply(marker, expr);
	    } else if (matchKeyword("delete") || matchKeyword("void") || matchKeyword("typeof")) {
	        marker = markerCreate();
	        token = lex();
	        expr = parseUnaryExpression();
	        expr = astNodeFactory.createUnaryExpression(token.value, expr);
	        expr = markerApply(marker, expr);
	        if (strict && expr.operator === "delete" && expr.argument.type === astNodeTypes.Identifier) {
	            throwErrorTolerant({}, Messages.StrictDelete);
	        }
	    } else {
	        expr = parsePostfixExpression();
	    }

	    return expr;
	}

	function binaryPrecedence(token, allowIn) {
	    var prec = 0;

	    if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
	        return 0;
	    }

	    switch (token.value) {
	    case "||":
	        prec = 1;
	        break;

	    case "&&":
	        prec = 2;
	        break;

	    case "|":
	        prec = 3;
	        break;

	    case "^":
	        prec = 4;
	        break;

	    case "&":
	        prec = 5;
	        break;

	    case "==":
	    case "!=":
	    case "===":
	    case "!==":
	        prec = 6;
	        break;

	    case "<":
	    case ">":
	    case "<=":
	    case ">=":
	    case "instanceof":
	        prec = 7;
	        break;

	    case "in":
	        prec = allowIn ? 7 : 0;
	        break;

	    case "<<":
	    case ">>":
	    case ">>>":
	        prec = 8;
	        break;

	    case "+":
	    case "-":
	        prec = 9;
	        break;

	    case "*":
	    case "/":
	    case "%":
	        prec = 11;
	        break;

	    default:
	        break;
	    }

	    return prec;
	}

	// 11.5 Multiplicative Operators
	// 11.6 Additive Operators
	// 11.7 Bitwise Shift Operators
	// 11.8 Relational Operators
	// 11.9 Equality Operators
	// 11.10 Binary Bitwise Operators
	// 11.11 Binary Logical Operators
	function parseBinaryExpression() {
	    var expr, token, prec, previousAllowIn, stack, right, operator, left, i,
	        marker, markers;

	    previousAllowIn = state.allowIn;
	    state.allowIn = true;

	    marker = markerCreate();
	    left = parseUnaryExpression();

	    token = lookahead;
	    prec = binaryPrecedence(token, previousAllowIn);
	    if (prec === 0) {
	        return left;
	    }
	    token.prec = prec;
	    lex();

	    markers = [marker, markerCreate()];
	    right = parseUnaryExpression();

	    stack = [left, token, right];

	    while ((prec = binaryPrecedence(lookahead, previousAllowIn)) > 0) {

	        // Reduce: make a binary expression from the three topmost entries.
	        while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
	            right = stack.pop();
	            operator = stack.pop().value;
	            left = stack.pop();
	            expr = astNodeFactory.createBinaryExpression(operator, left, right);
	            markers.pop();
	            marker = markers.pop();
	            markerApply(marker, expr);
	            stack.push(expr);
	            markers.push(marker);
	        }

	        // Shift.
	        token = lex();
	        token.prec = prec;
	        stack.push(token);
	        markers.push(markerCreate());
	        expr = parseUnaryExpression();
	        stack.push(expr);
	    }

	    state.allowIn = previousAllowIn;

	    // Final reduce to clean-up the stack.
	    i = stack.length - 1;
	    expr = stack[i];
	    markers.pop();
	    while (i > 1) {
	        expr = astNodeFactory.createBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
	        i -= 2;
	        marker = markers.pop();
	        markerApply(marker, expr);
	    }

	    return expr;
	}

	// 11.12 Conditional Operator

	function parseConditionalExpression() {
	    var expr, previousAllowIn, consequent, alternate,
	        marker = markerCreate();

	    expr = parseBinaryExpression();

	    if (match("?")) {
	        lex();
	        previousAllowIn = state.allowIn;
	        state.allowIn = true;
	        consequent = parseAssignmentExpression();
	        state.allowIn = previousAllowIn;
	        expect(":");
	        alternate = parseAssignmentExpression();

	        expr = astNodeFactory.createConditionalExpression(expr, consequent, alternate);
	        markerApply(marker, expr);
	    }

	    return expr;
	}

	// [ES6] 14.2 Arrow Function

	function parseConciseBody() {
	    if (match("{")) {
	        return parseFunctionSourceElements();
	    }
	    return parseAssignmentExpression();
	}

	function reinterpretAsCoverFormalsList(expressions) {
	    var i, len, param, params, options,
	        allowRestParams = extra.ecmaFeatures.restParams;

	    params = [];
	    options = {
	        paramSet: new StringMap()
	    };

	    for (i = 0, len = expressions.length; i < len; i += 1) {
	        param = expressions[i];
	        if (param.type === astNodeTypes.Identifier) {
	            params.push(param);
	            validateParam(options, param, param.name);
	        }  else if (param.type === astNodeTypes.ObjectExpression || param.type === astNodeTypes.ArrayExpression) {
	            reinterpretAsDestructuredParameter(options, param);
	            params.push(param);
	        } else if (param.type === astNodeTypes.SpreadElement) {
	            assert(i === len - 1, "It is guaranteed that SpreadElement is last element by parseExpression");
	            if (param.argument.type !== astNodeTypes.Identifier) {
	                throwError({}, Messages.UnexpectedToken, "[");
	            }

	            if (!allowRestParams) {
	                // can't get correct line/column here :(
	                throwError({}, Messages.UnexpectedToken, ".");
	            }

	            reinterpretAsDestructuredParameter(options, param.argument);
	            param.type = astNodeTypes.RestElement;
	            params.push(param);
	        } else if (param.type === astNodeTypes.RestElement) {
	            params.push(param);
	            validateParam(options, param.argument, param.argument.name);
	        } else if (param.type === astNodeTypes.AssignmentExpression) {

	            // TODO: Find a less hacky way of doing this
	            param.type = astNodeTypes.AssignmentPattern;
	            delete param.operator;

	            if (param.right.type === astNodeTypes.YieldExpression) {
	                if (param.right.argument) {
	                    throwUnexpected(lookahead);
	                }

	                param.right.type = astNodeTypes.Identifier;
	                param.right.name = "yield";
	                delete param.right.argument;
	                delete param.right.delegate;
	            }

	            params.push(param);
	            validateParam(options, param.left, param.left.name);
	        } else {
	            return null;
	        }
	    }

	    if (options.message === Messages.StrictParamDupe) {
	        throwError(
	            strict ? options.stricted : options.firstRestricted,
	            options.message
	        );
	    }

	    return {
	        params: params,
	        stricted: options.stricted,
	        firstRestricted: options.firstRestricted,
	        message: options.message
	    };
	}

	function parseArrowFunctionExpression(options, marker) {
	    var previousStrict, body;

	    expect("=>");
	    previousStrict = strict;

	    body = parseConciseBody();

	    if (strict && options.firstRestricted) {
	        throwError(options.firstRestricted, options.message);
	    }
	    if (strict && options.stricted) {
	        throwErrorTolerant(options.stricted, options.message);
	    }

	    strict = previousStrict;
	    return markerApply(marker, astNodeFactory.createArrowFunctionExpression(
	        options.params,
	        body,
	        body.type !== astNodeTypes.BlockStatement
	    ));
	}

	// 11.13 Assignment Operators

	// 12.14.5 AssignmentPattern

	function reinterpretAsAssignmentBindingPattern(expr) {
	    var i, len, property, element,
	        allowDestructuring = extra.ecmaFeatures.destructuring,
	        allowRest = extra.ecmaFeatures.experimentalObjectRestSpread;

	    if (!allowDestructuring) {
	        throwUnexpected(lex());
	    }

	    if (expr.type === astNodeTypes.ObjectExpression) {
	        expr.type = astNodeTypes.ObjectPattern;
	        for (i = 0, len = expr.properties.length; i < len; i += 1) {
	            property = expr.properties[i];

	            if (allowRest && property.type === astNodeTypes.ExperimentalSpreadProperty) {

	                // only allow identifiers
	                if (property.argument.type !== astNodeTypes.Identifier) {
	                    throwErrorTolerant({}, "Invalid object rest.");
	                }

	                property.type = astNodeTypes.ExperimentalRestProperty;
	                return;
	            }

	            if (property.kind !== "init") {
	                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
	            }
	            reinterpretAsAssignmentBindingPattern(property.value);
	        }
	    } else if (expr.type === astNodeTypes.ArrayExpression) {
	        expr.type = astNodeTypes.ArrayPattern;
	        for (i = 0, len = expr.elements.length; i < len; i += 1) {
	            element = expr.elements[i];
	            /* istanbul ignore else */
	            if (element) {
	                reinterpretAsAssignmentBindingPattern(element);
	            }
	        }
	    } else if (expr.type === astNodeTypes.Identifier) {
	        if (syntax.isRestrictedWord(expr.name)) {
	            throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
	        }
	    } else if (expr.type === astNodeTypes.SpreadElement) {
	        reinterpretAsAssignmentBindingPattern(expr.argument);
	        if (expr.argument.type === astNodeTypes.ObjectPattern) {
	            throwErrorTolerant({}, Messages.ObjectPatternAsSpread);
	        }
	    } else if (expr.type === "AssignmentExpression" && expr.operator === "=") {
	        expr.type = astNodeTypes.AssignmentPattern;
	    } else {
	        /* istanbul ignore else */
	        if (expr.type !== astNodeTypes.MemberExpression &&
	            expr.type !== astNodeTypes.CallExpression &&
	            expr.type !== astNodeTypes.NewExpression &&
	            expr.type !== astNodeTypes.AssignmentPattern
	        ) {
	            throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
	        }
	    }
	}

	// 13.2.3 BindingPattern

	function reinterpretAsDestructuredParameter(options, expr) {
	    var i, len, property, element,
	        allowDestructuring = extra.ecmaFeatures.destructuring;

	    if (!allowDestructuring) {
	        throwUnexpected(lex());
	    }

	    if (expr.type === astNodeTypes.ObjectExpression) {
	        expr.type = astNodeTypes.ObjectPattern;
	        for (i = 0, len = expr.properties.length; i < len; i += 1) {
	            property = expr.properties[i];
	            if (property.kind !== "init") {
	                throwErrorTolerant({}, Messages.InvalidLHSInFormalsList);
	            }
	            reinterpretAsDestructuredParameter(options, property.value);
	        }
	    } else if (expr.type === astNodeTypes.ArrayExpression) {
	        expr.type = astNodeTypes.ArrayPattern;
	        for (i = 0, len = expr.elements.length; i < len; i += 1) {
	            element = expr.elements[i];
	            if (element) {
	                reinterpretAsDestructuredParameter(options, element);
	            }
	        }
	    } else if (expr.type === astNodeTypes.Identifier) {
	        validateParam(options, expr, expr.name);
	    } else if (expr.type === astNodeTypes.SpreadElement) {
	        // BindingRestElement only allows BindingIdentifier
	        if (expr.argument.type !== astNodeTypes.Identifier) {
	            throwErrorTolerant({}, Messages.InvalidLHSInFormalsList);
	        }
	        validateParam(options, expr.argument, expr.argument.name);
	    } else if (expr.type === astNodeTypes.AssignmentExpression && expr.operator === "=") {
	        expr.type = astNodeTypes.AssignmentPattern;
	    } else if (expr.type !== astNodeTypes.AssignmentPattern) {
	        throwError({}, Messages.InvalidLHSInFormalsList);
	    }
	}

	function parseAssignmentExpression() {
	    var token, left, right, node, params,
	        marker,
	        startsWithParen = false,
	        oldParenthesisCount = state.parenthesisCount,
	        allowGenerators = extra.ecmaFeatures.generators;

	    // Note that 'yield' is treated as a keyword in strict mode, but a
	    // contextual keyword (identifier) in non-strict mode, so we need
	    // to use matchKeyword and matchContextualKeyword appropriately.
	    if (allowGenerators && ((state.yieldAllowed && matchContextualKeyword("yield")) || (strict && matchKeyword("yield")))) {
	        return parseYieldExpression();
	    }

	    marker = markerCreate();

	    if (match("(")) {
	        token = lookahead2();
	        if ((token.value === ")" && token.type === Token.Punctuator) || token.value === "...") {
	            params = parseParams();
	            if (!match("=>")) {
	                throwUnexpected(lex());
	            }
	            return parseArrowFunctionExpression(params, marker);
	        }
	        startsWithParen = true;
	    }

	    // revert to the previous lookahead style object
	    token = lookahead;
	    node = left = parseConditionalExpression();

	    if (match("=>") &&
	            (state.parenthesisCount === oldParenthesisCount ||
	            state.parenthesisCount === (oldParenthesisCount + 1))) {

	        if (node.type === astNodeTypes.Identifier) {
	            params = reinterpretAsCoverFormalsList([ node ]);
	        } else if (node.type === astNodeTypes.AssignmentExpression ||
	            node.type === astNodeTypes.ArrayExpression ||
	            node.type === astNodeTypes.ObjectExpression) {
	            if (!startsWithParen) {
	                throwUnexpected(lex());
	            }
	            params = reinterpretAsCoverFormalsList([ node ]);
	        } else if (node.type === astNodeTypes.SequenceExpression) {
	            params = reinterpretAsCoverFormalsList(node.expressions);
	        }

	        if (params) {
	            return parseArrowFunctionExpression(params, marker);
	        }
	    }

	    if (matchAssign()) {

	        // 11.13.1
	        if (strict && left.type === astNodeTypes.Identifier && syntax.isRestrictedWord(left.name)) {
	            throwErrorTolerant(token, Messages.StrictLHSAssignment);
	        }

	        // ES.next draf 11.13 Runtime Semantics step 1
	        if (match("=") && (node.type === astNodeTypes.ObjectExpression || node.type === astNodeTypes.ArrayExpression)) {
	            reinterpretAsAssignmentBindingPattern(node);
	        } else if (!isLeftHandSide(node)) {
	            throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
	        }

	        token = lex();
	        right = parseAssignmentExpression();
	        node = markerApply(marker, astNodeFactory.createAssignmentExpression(token.value, left, right));
	    }

	    return node;
	}

	// 11.14 Comma Operator

	function parseExpression() {
	    var marker = markerCreate(),
	        expr = parseAssignmentExpression(),
	        expressions = [ expr ],
	        sequence, spreadFound;

	    if (match(",")) {
	        while (index < length) {
	            if (!match(",")) {
	                break;
	            }
	            lex();
	            expr = parseSpreadOrAssignmentExpression();
	            expressions.push(expr);

	            if (expr.type === astNodeTypes.SpreadElement) {
	                spreadFound = true;
	                if (!match(")")) {
	                    throwError({}, Messages.ElementAfterSpreadElement);
	                }
	                break;
	            }
	        }

	        sequence = markerApply(marker, astNodeFactory.createSequenceExpression(expressions));
	    }

	    if (spreadFound && lookahead2().value !== "=>") {
	        throwError({}, Messages.IllegalSpread);
	    }

	    return sequence || expr;
	}

	// 12.1 Block

	function parseStatementList() {
	    var list = [],
	        statement;

	    while (index < length) {
	        if (match("}")) {
	            break;
	        }
	        statement = parseSourceElement();
	        if (typeof statement === "undefined") {
	            break;
	        }
	        list.push(statement);
	    }

	    return list;
	}

	function parseBlock() {
	    var block,
	        marker = markerCreate();

	    expect("{");

	    block = parseStatementList();

	    expect("}");

	    return markerApply(marker, astNodeFactory.createBlockStatement(block));
	}

	// 12.2 Variable Statement

	function parseVariableIdentifier() {
	    var token,
	        marker = markerCreate();

	    token = lex();

	    if (token.type !== Token.Identifier) {
	        if (strict && token.type === Token.Keyword && syntax.isStrictModeReservedWord(token.value, extra.ecmaFeatures)) {
	            throwErrorTolerant(token, Messages.StrictReservedWord);
	        } else {
	            throwUnexpected(token);
	        }
	    }

	    return markerApply(marker, astNodeFactory.createIdentifier(token.value));
	}

	function parseVariableDeclaration(kind) {
	    var id,
	        marker = markerCreate(),
	        init = null;
	    if (match("{")) {
	        id = parseObjectInitialiser();
	        reinterpretAsAssignmentBindingPattern(id);
	    } else if (match("[")) {
	        id = parseArrayInitialiser();
	        reinterpretAsAssignmentBindingPattern(id);
	    } else {
	        /* istanbul ignore next */
	        id = state.allowKeyword ? parseNonComputedProperty() : parseVariableIdentifier();
	        // 12.2.1
	        if (strict && syntax.isRestrictedWord(id.name)) {
	            throwErrorTolerant({}, Messages.StrictVarName);
	        }
	    }

	    // TODO: Verify against feature flags
	    if (kind === "const") {
	        if (!match("=")) {
	            throwError({}, Messages.NoUnintializedConst);
	        }
	        expect("=");
	        init = parseAssignmentExpression();
	    } else if (match("=")) {
	        lex();
	        init = parseAssignmentExpression();
	    }

	    return markerApply(marker, astNodeFactory.createVariableDeclarator(id, init));
	}

	function parseVariableDeclarationList(kind) {
	    var list = [];

	    do {
	        list.push(parseVariableDeclaration(kind));
	        if (!match(",")) {
	            break;
	        }
	        lex();
	    } while (index < length);

	    return list;
	}

	function parseVariableStatement() {
	    var declarations;

	    expectKeyword("var");

	    declarations = parseVariableDeclarationList();

	    consumeSemicolon();

	    return astNodeFactory.createVariableDeclaration(declarations, "var");
	}

	// kind may be `const` or `let`
	// Both are experimental and not in the specification yet.
	// see http://wiki.ecmascript.org/doku.php?id=harmony:const
	// and http://wiki.ecmascript.org/doku.php?id=harmony:let
	function parseConstLetDeclaration(kind) {
	    var declarations,
	        marker = markerCreate();

	    expectKeyword(kind);

	    declarations = parseVariableDeclarationList(kind);

	    consumeSemicolon();

	    return markerApply(marker, astNodeFactory.createVariableDeclaration(declarations, kind));
	}


	function parseRestElement() {
	    var param,
	        marker = markerCreate();

	    lex();

	    if (match("{")) {
	        throwError(lookahead, Messages.ObjectPatternAsRestParameter);
	    }

	    param = parseVariableIdentifier();

	    if (match("=")) {
	        throwError(lookahead, Messages.DefaultRestParameter);
	    }

	    if (!match(")")) {
	        throwError(lookahead, Messages.ParameterAfterRestParameter);
	    }

	    return markerApply(marker, astNodeFactory.createRestElement(param));
	}

	// 12.3 Empty Statement

	function parseEmptyStatement() {
	    expect(";");
	    return astNodeFactory.createEmptyStatement();
	}

	// 12.4 Expression Statement

	function parseExpressionStatement() {
	    var expr = parseExpression();
	    consumeSemicolon();
	    return astNodeFactory.createExpressionStatement(expr);
	}

	// 12.5 If statement

	function parseIfStatement() {
	    var test, consequent, alternate;

	    expectKeyword("if");

	    expect("(");

	    test = parseExpression();

	    expect(")");

	    consequent = parseStatement();

	    if (matchKeyword("else")) {
	        lex();
	        alternate = parseStatement();
	    } else {
	        alternate = null;
	    }

	    return astNodeFactory.createIfStatement(test, consequent, alternate);
	}

	// 12.6 Iteration Statements

	function parseDoWhileStatement() {
	    var body, test, oldInIteration;

	    expectKeyword("do");

	    oldInIteration = state.inIteration;
	    state.inIteration = true;

	    body = parseStatement();

	    state.inIteration = oldInIteration;

	    expectKeyword("while");

	    expect("(");

	    test = parseExpression();

	    expect(")");

	    if (match(";")) {
	        lex();
	    }

	    return astNodeFactory.createDoWhileStatement(test, body);
	}

	function parseWhileStatement() {
	    var test, body, oldInIteration;

	    expectKeyword("while");

	    expect("(");

	    test = parseExpression();

	    expect(")");

	    oldInIteration = state.inIteration;
	    state.inIteration = true;

	    body = parseStatement();

	    state.inIteration = oldInIteration;

	    return astNodeFactory.createWhileStatement(test, body);
	}

	function parseForVariableDeclaration() {
	    var token, declarations,
	        marker = markerCreate();

	    token = lex();
	    declarations = parseVariableDeclarationList();

	    return markerApply(marker, astNodeFactory.createVariableDeclaration(declarations, token.value));
	}

	function parseForStatement(opts) {
	    var init, test, update, left, right, body, operator, oldInIteration;
	    var allowForOf = extra.ecmaFeatures.forOf,
	        allowBlockBindings = extra.ecmaFeatures.blockBindings;

	    init = test = update = null;

	    expectKeyword("for");

	    expect("(");

	    if (match(";")) {
	        lex();
	    } else {

	        if (matchKeyword("var") ||
	            (allowBlockBindings && (matchKeyword("let") || matchKeyword("const")))
	        ) {
	            state.allowIn = false;
	            init = parseForVariableDeclaration();
	            state.allowIn = true;

	            if (init.declarations.length === 1) {
	                if (matchKeyword("in") || (allowForOf && matchContextualKeyword("of"))) {
	                    operator = lookahead;

	                    // TODO: is "var" check here really needed? wasn"t in 1.2.2
	                    if (!((operator.value === "in" || init.kind !== "var") && init.declarations[0].init)) {
	                        lex();
	                        left = init;
	                        right = parseExpression();
	                        init = null;
	                    }
	                }
	            }

	        } else {
	            state.allowIn = false;
	            init = parseExpression();
	            state.allowIn = true;

	            if (allowForOf && matchContextualKeyword("of")) {
	                operator = lex();
	                left = init;
	                right = parseExpression();
	                init = null;
	            } else if (matchKeyword("in")) {
	                // LeftHandSideExpression
	                if (!isLeftHandSide(init)) {
	                    throwErrorTolerant({}, Messages.InvalidLHSInForIn);
	                }

	                operator = lex();
	                left = init;
	                right = parseExpression();
	                init = null;
	            }
	        }

	        if (typeof left === "undefined") {
	            expect(";");
	        }
	    }

	    if (typeof left === "undefined") {

	        if (!match(";")) {
	            test = parseExpression();
	        }
	        expect(";");

	        if (!match(")")) {
	            update = parseExpression();
	        }
	    }

	    expect(")");

	    oldInIteration = state.inIteration;
	    state.inIteration = true;

	    if (!(opts !== undefined && opts.ignoreBody)) {
	        body = parseStatement();
	    }

	    state.inIteration = oldInIteration;

	    if (typeof left === "undefined") {
	        return astNodeFactory.createForStatement(init, test, update, body);
	    }

	    if (extra.ecmaFeatures.forOf && operator.value === "of") {
	        return astNodeFactory.createForOfStatement(left, right, body);
	    }

	    return astNodeFactory.createForInStatement(left, right, body);
	}

	// 12.7 The continue statement

	function parseContinueStatement() {
	    var label = null;

	    expectKeyword("continue");

	    // Optimize the most common form: "continue;".
	    if (source.charCodeAt(index) === 0x3B) {
	        lex();

	        if (!state.inIteration) {
	            throwError({}, Messages.IllegalContinue);
	        }

	        return astNodeFactory.createContinueStatement(null);
	    }

	    if (peekLineTerminator()) {
	        if (!state.inIteration) {
	            throwError({}, Messages.IllegalContinue);
	        }

	        return astNodeFactory.createContinueStatement(null);
	    }

	    if (lookahead.type === Token.Identifier) {
	        label = parseVariableIdentifier();

	        if (!state.labelSet.has(label.name)) {
	            throwError({}, Messages.UnknownLabel, label.name);
	        }
	    }

	    consumeSemicolon();

	    if (label === null && !state.inIteration) {
	        throwError({}, Messages.IllegalContinue);
	    }

	    return astNodeFactory.createContinueStatement(label);
	}

	// 12.8 The break statement

	function parseBreakStatement() {
	    var label = null;

	    expectKeyword("break");

	    // Catch the very common case first: immediately a semicolon (U+003B).
	    if (source.charCodeAt(index) === 0x3B) {
	        lex();

	        if (!(state.inIteration || state.inSwitch)) {
	            throwError({}, Messages.IllegalBreak);
	        }

	        return astNodeFactory.createBreakStatement(null);
	    }

	    if (peekLineTerminator()) {
	        if (!(state.inIteration || state.inSwitch)) {
	            throwError({}, Messages.IllegalBreak);
	        }

	        return astNodeFactory.createBreakStatement(null);
	    }

	    if (lookahead.type === Token.Identifier) {
	        label = parseVariableIdentifier();

	        if (!state.labelSet.has(label.name)) {
	            throwError({}, Messages.UnknownLabel, label.name);
	        }
	    }

	    consumeSemicolon();

	    if (label === null && !(state.inIteration || state.inSwitch)) {
	        throwError({}, Messages.IllegalBreak);
	    }

	    return astNodeFactory.createBreakStatement(label);
	}

	// 12.9 The return statement

	function parseReturnStatement() {
	    var argument = null;

	    expectKeyword("return");

	    if (!state.inFunctionBody && !extra.ecmaFeatures.globalReturn) {
	        throwErrorTolerant({}, Messages.IllegalReturn);
	    }

	    // "return" followed by a space and an identifier is very common.
	    if (source.charCodeAt(index) === 0x20) {
	        if (syntax.isIdentifierStart(source.charCodeAt(index + 1))) {
	            argument = parseExpression();
	            consumeSemicolon();
	            return astNodeFactory.createReturnStatement(argument);
	        }
	    }

	    if (peekLineTerminator()) {
	        return astNodeFactory.createReturnStatement(null);
	    }

	    if (!match(";")) {
	        if (!match("}") && lookahead.type !== Token.EOF) {
	            argument = parseExpression();
	        }
	    }

	    consumeSemicolon();

	    return astNodeFactory.createReturnStatement(argument);
	}

	// 12.10 The with statement

	function parseWithStatement() {
	    var object, body;

	    if (strict) {
	        // TODO(ikarienator): Should we update the test cases instead?
	        skipComment();
	        throwErrorTolerant({}, Messages.StrictModeWith);
	    }

	    expectKeyword("with");

	    expect("(");

	    object = parseExpression();

	    expect(")");

	    body = parseStatement();

	    return astNodeFactory.createWithStatement(object, body);
	}

	// 12.10 The swith statement

	function parseSwitchCase() {
	    var test, consequent = [], statement,
	        marker = markerCreate();

	    if (matchKeyword("default")) {
	        lex();
	        test = null;
	    } else {
	        expectKeyword("case");
	        test = parseExpression();
	    }
	    expect(":");

	    while (index < length) {
	        if (match("}") || matchKeyword("default") || matchKeyword("case")) {
	            break;
	        }
	        statement = parseSourceElement();
	        if (typeof statement === "undefined") {
	            break;
	        }
	        consequent.push(statement);
	    }

	    return markerApply(marker, astNodeFactory.createSwitchCase(test, consequent));
	}

	function parseSwitchStatement() {
	    var discriminant, cases, clause, oldInSwitch, defaultFound;

	    expectKeyword("switch");

	    expect("(");

	    discriminant = parseExpression();

	    expect(")");

	    expect("{");

	    cases = [];

	    if (match("}")) {
	        lex();
	        return astNodeFactory.createSwitchStatement(discriminant, cases);
	    }

	    oldInSwitch = state.inSwitch;
	    state.inSwitch = true;
	    defaultFound = false;

	    while (index < length) {
	        if (match("}")) {
	            break;
	        }
	        clause = parseSwitchCase();
	        if (clause.test === null) {
	            if (defaultFound) {
	                throwError({}, Messages.MultipleDefaultsInSwitch);
	            }
	            defaultFound = true;
	        }
	        cases.push(clause);
	    }

	    state.inSwitch = oldInSwitch;

	    expect("}");

	    return astNodeFactory.createSwitchStatement(discriminant, cases);
	}

	// 12.13 The throw statement

	function parseThrowStatement() {
	    var argument;

	    expectKeyword("throw");

	    if (peekLineTerminator()) {
	        throwError({}, Messages.NewlineAfterThrow);
	    }

	    argument = parseExpression();

	    consumeSemicolon();

	    return astNodeFactory.createThrowStatement(argument);
	}

	// 12.14 The try statement

	function parseCatchClause() {
	    var param, body,
	        marker = markerCreate(),
	        allowDestructuring = extra.ecmaFeatures.destructuring,
	        options = {
	            paramSet: new StringMap()
	        };

	    expectKeyword("catch");

	    expect("(");
	    if (match(")")) {
	        throwUnexpected(lookahead);
	    }

	    if (match("[")) {
	        if (!allowDestructuring) {
	            throwUnexpected(lookahead);
	        }
	        param = parseArrayInitialiser();
	        reinterpretAsDestructuredParameter(options, param);
	    } else if (match("{")) {

	        if (!allowDestructuring) {
	            throwUnexpected(lookahead);
	        }
	        param = parseObjectInitialiser();
	        reinterpretAsDestructuredParameter(options, param);
	    } else {
	        param = parseVariableIdentifier();
	    }

	    // 12.14.1
	    if (strict && param.name && syntax.isRestrictedWord(param.name)) {
	        throwErrorTolerant({}, Messages.StrictCatchVariable);
	    }

	    expect(")");
	    body = parseBlock();
	    return markerApply(marker, astNodeFactory.createCatchClause(param, body));
	}

	function parseTryStatement() {
	    var block, handler = null, finalizer = null;

	    expectKeyword("try");

	    block = parseBlock();

	    if (matchKeyword("catch")) {
	        handler = parseCatchClause();
	    }

	    if (matchKeyword("finally")) {
	        lex();
	        finalizer = parseBlock();
	    }

	    if (!handler && !finalizer) {
	        throwError({}, Messages.NoCatchOrFinally);
	    }

	    return astNodeFactory.createTryStatement(block, handler, finalizer);
	}

	// 12.15 The debugger statement

	function parseDebuggerStatement() {
	    expectKeyword("debugger");

	    consumeSemicolon();

	    return astNodeFactory.createDebuggerStatement();
	}

	// 12 Statements

	function parseStatement() {
	    var type = lookahead.type,
	        expr,
	        labeledBody,
	        marker;

	    if (type === Token.EOF) {
	        throwUnexpected(lookahead);
	    }

	    if (type === Token.Punctuator && lookahead.value === "{") {
	        return parseBlock();
	    }

	    marker = markerCreate();

	    if (type === Token.Punctuator) {
	        switch (lookahead.value) {
	            case ";":
	                return markerApply(marker, parseEmptyStatement());
	            case "{":
	                return parseBlock();
	            case "(":
	                return markerApply(marker, parseExpressionStatement());
	            default:
	                break;
	        }
	    }

	    marker = markerCreate();

	    if (type === Token.Keyword) {
	        switch (lookahead.value) {
	            case "break":
	                return markerApply(marker, parseBreakStatement());
	            case "continue":
	                return markerApply(marker, parseContinueStatement());
	            case "debugger":
	                return markerApply(marker, parseDebuggerStatement());
	            case "do":
	                return markerApply(marker, parseDoWhileStatement());
	            case "for":
	                return markerApply(marker, parseForStatement());
	            case "function":
	                return markerApply(marker, parseFunctionDeclaration());
	            case "if":
	                return markerApply(marker, parseIfStatement());
	            case "return":
	                return markerApply(marker, parseReturnStatement());
	            case "switch":
	                return markerApply(marker, parseSwitchStatement());
	            case "throw":
	                return markerApply(marker, parseThrowStatement());
	            case "try":
	                return markerApply(marker, parseTryStatement());
	            case "var":
	                return markerApply(marker, parseVariableStatement());
	            case "while":
	                return markerApply(marker, parseWhileStatement());
	            case "with":
	                return markerApply(marker, parseWithStatement());
	            default:
	                break;
	        }
	    }

	    marker = markerCreate();
	    expr = parseExpression();

	    // 12.12 Labelled Statements
	    if ((expr.type === astNodeTypes.Identifier) && match(":")) {
	        lex();

	        if (state.labelSet.has(expr.name)) {
	            throwError({}, Messages.Redeclaration, "Label", expr.name);
	        }

	        state.labelSet.set(expr.name, true);
	        labeledBody = parseStatement();
	        state.labelSet.delete(expr.name);
	        return markerApply(marker, astNodeFactory.createLabeledStatement(expr, labeledBody));
	    }

	    consumeSemicolon();

	    return markerApply(marker, astNodeFactory.createExpressionStatement(expr));
	}

	// 13 Function Definition

	// function parseConciseBody() {
	//     if (match("{")) {
	//         return parseFunctionSourceElements();
	//     }
	//     return parseAssignmentExpression();
	// }

	function parseFunctionSourceElements() {
	    var sourceElement, sourceElements = [], token, directive, firstRestricted,
	        oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, oldParenthesisCount,
	        marker = markerCreate();

	    expect("{");

	    while (index < length) {
	        if (lookahead.type !== Token.StringLiteral) {
	            break;
	        }
	        token = lookahead;

	        sourceElement = parseSourceElement();
	        sourceElements.push(sourceElement);
	        if (sourceElement.expression.type !== astNodeTypes.Literal) {
	            // this is not directive
	            break;
	        }
	        directive = source.slice(token.range[0] + 1, token.range[1] - 1);
	        if (directive === "use strict") {
	            strict = true;

	            if (firstRestricted) {
	                throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
	            }
	        } else {
	            if (!firstRestricted && token.octal) {
	                firstRestricted = token;
	            }
	        }
	    }

	    oldLabelSet = state.labelSet;
	    oldInIteration = state.inIteration;
	    oldInSwitch = state.inSwitch;
	    oldInFunctionBody = state.inFunctionBody;
	    oldParenthesisCount = state.parenthesizedCount;

	    state.labelSet = new StringMap();
	    state.inIteration = false;
	    state.inSwitch = false;
	    state.inFunctionBody = true;

	    while (index < length) {

	        if (match("}")) {
	            break;
	        }

	        sourceElement = parseSourceElement();

	        if (typeof sourceElement === "undefined") {
	            break;
	        }

	        sourceElements.push(sourceElement);
	    }

	    expect("}");

	    state.labelSet = oldLabelSet;
	    state.inIteration = oldInIteration;
	    state.inSwitch = oldInSwitch;
	    state.inFunctionBody = oldInFunctionBody;
	    state.parenthesizedCount = oldParenthesisCount;

	    return markerApply(marker, astNodeFactory.createBlockStatement(sourceElements));
	}

	function validateParam(options, param, name) {

	    if (strict) {
	        if (syntax.isRestrictedWord(name)) {
	            options.stricted = param;
	            options.message = Messages.StrictParamName;
	        }

	        if (options.paramSet.has(name)) {
	            options.stricted = param;
	            options.message = Messages.StrictParamDupe;
	        }
	    } else if (!options.firstRestricted) {
	        if (syntax.isRestrictedWord(name)) {
	            options.firstRestricted = param;
	            options.message = Messages.StrictParamName;
	        } else if (syntax.isStrictModeReservedWord(name, extra.ecmaFeatures)) {
	            options.firstRestricted = param;
	            options.message = Messages.StrictReservedWord;
	        } else if (options.paramSet.has(name)) {
	            options.firstRestricted = param;
	            options.message = Messages.StrictParamDupe;
	        }
	    }
	    options.paramSet.set(name, true);
	}

	function parseParam(options) {
	    var token, param, def,
	        allowRestParams = extra.ecmaFeatures.restParams,
	        allowDestructuring = extra.ecmaFeatures.destructuring,
	        allowDefaultParams = extra.ecmaFeatures.defaultParams,
	        marker = markerCreate();

	    token = lookahead;
	    if (token.value === "...") {
	        if (!allowRestParams) {
	            throwUnexpected(lookahead);
	        }
	        param = parseRestElement();
	        validateParam(options, param.argument, param.argument.name);
	        options.params.push(param);
	        return false;
	    }

	    if (match("[")) {
	        if (!allowDestructuring) {
	            throwUnexpected(lookahead);
	        }
	        param = parseArrayInitialiser();
	        reinterpretAsDestructuredParameter(options, param);
	    } else if (match("{")) {
	        if (!allowDestructuring) {
	            throwUnexpected(lookahead);
	        }
	        param = parseObjectInitialiser();
	        reinterpretAsDestructuredParameter(options, param);
	    } else {
	        param = parseVariableIdentifier();
	        validateParam(options, token, token.value);
	    }

	    if (match("=")) {
	        if (allowDefaultParams || allowDestructuring) {
	            lex();
	            def = parseAssignmentExpression();
	            ++options.defaultCount;
	        } else {
	            throwUnexpected(lookahead);
	        }
	    }

	    if (def) {
	        options.params.push(markerApply(
	            marker,
	            astNodeFactory.createAssignmentPattern(
	                param,
	                def
	            )
	        ));
	    } else {
	        options.params.push(param);
	    }

	    return !match(")");
	}


	function parseParams(firstRestricted) {
	    var options;

	    options = {
	        params: [],
	        defaultCount: 0,
	        firstRestricted: firstRestricted
	    };

	    expect("(");

	    if (!match(")")) {
	        options.paramSet = new StringMap();
	        while (index < length) {
	            if (!parseParam(options)) {
	                break;
	            }
	            expect(",");
	        }
	    }

	    expect(")");

	    return {
	        params: options.params,
	        stricted: options.stricted,
	        firstRestricted: options.firstRestricted,
	        message: options.message
	    };
	}

	function parseFunctionDeclaration(identifierIsOptional) {
	        var id = null, body, token, tmp, firstRestricted, message, previousStrict, previousYieldAllowed, generator,
	            marker = markerCreate(),
	            allowGenerators = extra.ecmaFeatures.generators;

	        expectKeyword("function");

	        generator = false;
	        if (allowGenerators && match("*")) {
	            lex();
	            generator = true;
	        }

	        if (!identifierIsOptional || !match("(")) {

	            token = lookahead;

	            id = parseVariableIdentifier();

	            if (strict) {
	                if (syntax.isRestrictedWord(token.value)) {
	                    throwErrorTolerant(token, Messages.StrictFunctionName);
	                }
	            } else {
	                if (syntax.isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = Messages.StrictFunctionName;
	                } else if (syntax.isStrictModeReservedWord(token.value, extra.ecmaFeatures)) {
	                    firstRestricted = token;
	                    message = Messages.StrictReservedWord;
	                }
	            }
	        }

	        tmp = parseParams(firstRestricted);
	        firstRestricted = tmp.firstRestricted;
	        if (tmp.message) {
	            message = tmp.message;
	        }

	        previousStrict = strict;
	        previousYieldAllowed = state.yieldAllowed;
	        state.yieldAllowed = generator;

	        body = parseFunctionSourceElements();

	        if (strict && firstRestricted) {
	            throwError(firstRestricted, message);
	        }
	        if (strict && tmp.stricted) {
	            throwErrorTolerant(tmp.stricted, message);
	        }
	        strict = previousStrict;
	        state.yieldAllowed = previousYieldAllowed;

	        return markerApply(
	            marker,
	            astNodeFactory.createFunctionDeclaration(
	                id,
	                tmp.params,
	                body,
	                generator,
	                false
	            )
	        );
	    }

	function parseFunctionExpression() {
	    var token, id = null, firstRestricted, message, tmp, body, previousStrict, previousYieldAllowed, generator,
	        marker = markerCreate(),
	        allowGenerators = extra.ecmaFeatures.generators;

	    expectKeyword("function");

	    generator = false;

	    if (allowGenerators && match("*")) {
	        lex();
	        generator = true;
	    }

	    if (!match("(")) {
	        token = lookahead;
	        id = parseVariableIdentifier();
	        if (strict) {
	            if (syntax.isRestrictedWord(token.value)) {
	                throwErrorTolerant(token, Messages.StrictFunctionName);
	            }
	        } else {
	            if (syntax.isRestrictedWord(token.value)) {
	                firstRestricted = token;
	                message = Messages.StrictFunctionName;
	            } else if (syntax.isStrictModeReservedWord(token.value, extra.ecmaFeatures)) {
	                firstRestricted = token;
	                message = Messages.StrictReservedWord;
	            }
	        }
	    }

	    tmp = parseParams(firstRestricted);
	    firstRestricted = tmp.firstRestricted;
	    if (tmp.message) {
	        message = tmp.message;
	    }

	    previousStrict = strict;
	    previousYieldAllowed = state.yieldAllowed;
	    state.yieldAllowed = generator;

	    body = parseFunctionSourceElements();

	    if (strict && firstRestricted) {
	        throwError(firstRestricted, message);
	    }
	    if (strict && tmp.stricted) {
	        throwErrorTolerant(tmp.stricted, message);
	    }
	    strict = previousStrict;
	    state.yieldAllowed = previousYieldAllowed;

	    return markerApply(
	        marker,
	        astNodeFactory.createFunctionExpression(
	            id,
	            tmp.params,
	            body,
	            generator,
	            false
	        )
	    );
	}

	function parseYieldExpression() {
	    var yieldToken, delegateFlag, expr, marker = markerCreate();

	    yieldToken = lex();
	    assert(yieldToken.value === "yield", "Called parseYieldExpression with non-yield lookahead.");

	    if (!state.yieldAllowed) {
	        throwErrorTolerant({}, Messages.IllegalYield);
	    }

	    delegateFlag = false;
	    if (match("*")) {
	        lex();
	        delegateFlag = true;
	    }

	    if (peekLineTerminator()) {
	        return markerApply(marker, astNodeFactory.createYieldExpression(null, delegateFlag));
	    }

	    if (!match(";") && !match(")")) {
	        if (!match("}") && lookahead.type !== Token.EOF) {
	            expr = parseAssignmentExpression();
	        }
	    }

	    return markerApply(marker, astNodeFactory.createYieldExpression(expr, delegateFlag));
	}

	// Modules grammar from:
	// people.mozilla.org/~jorendorff/es6-draft.html

	function parseModuleSpecifier() {
	    var marker = markerCreate(),
	        specifier;

	    if (lookahead.type !== Token.StringLiteral) {
	        throwError({}, Messages.InvalidModuleSpecifier);
	    }
	    specifier = astNodeFactory.createLiteralFromSource(lex(), source);
	    return markerApply(marker, specifier);
	}

	function parseExportSpecifier() {
	    var exported, local, marker = markerCreate();
	    if (matchKeyword("default")) {
	        lex();
	        local = markerApply(marker, astNodeFactory.createIdentifier("default"));
	        // export {default} from "something";
	    } else {
	        local = parseVariableIdentifier();
	    }
	    if (matchContextualKeyword("as")) {
	        lex();
	        exported = parseNonComputedProperty();
	    }
	    return markerApply(marker, astNodeFactory.createExportSpecifier(local, exported));
	}

	function parseExportNamedDeclaration() {
	    var declaration = null,
	        isExportFromIdentifier,
	        src = null, specifiers = [],
	        marker = markerCreate();

	    expectKeyword("export");

	    // non-default export
	    if (lookahead.type === Token.Keyword) {
	        // covers:
	        // export var f = 1;
	        switch (lookahead.value) {
	            case "let":
	            case "const":
	            case "var":
	            case "class":
	            case "function":
	                declaration = parseSourceElement();
	                return markerApply(marker, astNodeFactory.createExportNamedDeclaration(declaration, specifiers, null));
	            default:
	                break;
	        }
	    }

	    expect("{");
	    if (!match("}")) {
	        do {
	            isExportFromIdentifier = isExportFromIdentifier || matchKeyword("default");
	            specifiers.push(parseExportSpecifier());
	        } while (match(",") && lex());
	    }
	    expect("}");

	    if (matchContextualKeyword("from")) {
	        // covering:
	        // export {default} from "foo";
	        // export {foo} from "foo";
	        lex();
	        src = parseModuleSpecifier();
	        consumeSemicolon();
	    } else if (isExportFromIdentifier) {
	        // covering:
	        // export {default}; // missing fromClause
	        throwError({}, lookahead.value ?
	                Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
	    } else {
	        // cover
	        // export {foo};
	        consumeSemicolon();
	    }
	    return markerApply(marker, astNodeFactory.createExportNamedDeclaration(declaration, specifiers, src));
	}

	function parseExportDefaultDeclaration() {
	    var declaration = null,
	        expression = null,
	        possibleIdentifierToken,
	        allowClasses = extra.ecmaFeatures.classes,
	        marker = markerCreate();

	    // covers:
	    // export default ...
	    expectKeyword("export");
	    expectKeyword("default");

	    if (matchKeyword("function") || matchKeyword("class")) {
	        possibleIdentifierToken = lookahead2();
	        if (possibleIdentifierToken.type === Token.Identifier) {
	            // covers:
	            // export default function foo () {}
	            // export default class foo {}
	            declaration = parseSourceElement();
	            return markerApply(marker, astNodeFactory.createExportDefaultDeclaration(declaration));
	        }
	        // covers:
	        // export default function () {}
	        // export default class {}
	        if (lookahead.value === "function") {
	            declaration = parseFunctionDeclaration(true);
	            return markerApply(marker, astNodeFactory.createExportDefaultDeclaration(declaration));
	        } else if (allowClasses && lookahead.value === "class") {
	            declaration = parseClassDeclaration(true);
	            return markerApply(marker, astNodeFactory.createExportDefaultDeclaration(declaration));
	        }
	    }

	    if (matchContextualKeyword("from")) {
	        throwError({}, Messages.UnexpectedToken, lookahead.value);
	    }

	    // covers:
	    // export default {};
	    // export default [];
	    // export default (1 + 2);
	    if (match("{")) {
	        expression = parseObjectInitialiser();
	    } else if (match("[")) {
	        expression = parseArrayInitialiser();
	    } else {
	        expression = parseAssignmentExpression();
	    }
	    consumeSemicolon();
	    return markerApply(marker, astNodeFactory.createExportDefaultDeclaration(expression));
	}


	function parseExportAllDeclaration() {
	    var src,
	        marker = markerCreate();

	    // covers:
	    // export * from "foo";
	    expectKeyword("export");
	    expect("*");
	    if (!matchContextualKeyword("from")) {
	        throwError({}, lookahead.value ?
	                Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
	    }
	    lex();
	    src = parseModuleSpecifier();
	    consumeSemicolon();

	    return markerApply(marker, astNodeFactory.createExportAllDeclaration(src));
	}

	function parseExportDeclaration() {
	    if (state.inFunctionBody) {
	        throwError({}, Messages.IllegalExportDeclaration);
	    }
	    var declarationType = lookahead2().value;
	    if (declarationType === "default") {
	        return parseExportDefaultDeclaration();
	    } else if (declarationType === "*") {
	        return parseExportAllDeclaration();
	    } else {
	        return parseExportNamedDeclaration();
	    }
	}

	function parseImportSpecifier() {
	    // import {<foo as bar>} ...;
	    var local, imported, marker = markerCreate();

	    imported = parseNonComputedProperty();
	    if (matchContextualKeyword("as")) {
	        lex();
	        local = parseVariableIdentifier();
	    }

	    return markerApply(marker, astNodeFactory.createImportSpecifier(local, imported));
	}

	function parseNamedImports() {
	    var specifiers = [];
	    // {foo, bar as bas}
	    expect("{");
	    if (!match("}")) {
	        do {
	            specifiers.push(parseImportSpecifier());
	        } while (match(",") && lex());
	    }
	    expect("}");
	    return specifiers;
	}

	function parseImportDefaultSpecifier() {
	    // import <foo> ...;
	    var local, marker = markerCreate();

	    local = parseNonComputedProperty();

	    return markerApply(marker, astNodeFactory.createImportDefaultSpecifier(local));
	}

	function parseImportNamespaceSpecifier() {
	    // import <* as foo> ...;
	    var local, marker = markerCreate();

	    expect("*");
	    if (!matchContextualKeyword("as")) {
	        throwError({}, Messages.NoAsAfterImportNamespace);
	    }
	    lex();
	    local = parseNonComputedProperty();

	    return markerApply(marker, astNodeFactory.createImportNamespaceSpecifier(local));
	}

	function parseImportDeclaration() {
	    var specifiers, src, marker = markerCreate();

	    if (state.inFunctionBody) {
	        throwError({}, Messages.IllegalImportDeclaration);
	    }

	    expectKeyword("import");
	    specifiers = [];

	    if (lookahead.type === Token.StringLiteral) {
	        // covers:
	        // import "foo";
	        src = parseModuleSpecifier();
	        consumeSemicolon();
	        return markerApply(marker, astNodeFactory.createImportDeclaration(specifiers, src));
	    }

	    if (!matchKeyword("default") && isIdentifierName(lookahead)) {
	        // covers:
	        // import foo
	        // import foo, ...
	        specifiers.push(parseImportDefaultSpecifier());
	        if (match(",")) {
	            lex();
	        }
	    }
	    if (match("*")) {
	        // covers:
	        // import foo, * as foo
	        // import * as foo
	        specifiers.push(parseImportNamespaceSpecifier());
	    } else if (match("{")) {
	        // covers:
	        // import foo, {bar}
	        // import {bar}
	        specifiers = specifiers.concat(parseNamedImports());
	    }

	    if (!matchContextualKeyword("from")) {
	        throwError({}, lookahead.value ?
	                Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
	    }
	    lex();
	    src = parseModuleSpecifier();
	    consumeSemicolon();

	    return markerApply(marker, astNodeFactory.createImportDeclaration(specifiers, src));
	}

	// 14 Functions and classes

	// 14.1 Functions is defined above (13 in ES5)
	// 14.2 Arrow Functions Definitions is defined in (7.3 assignments)

	// 14.3 Method Definitions
	// 14.3.7

	// 14.5 Class Definitions

	function parseClassBody() {
	    var hasConstructor = false, generator = false,
	        allowGenerators = extra.ecmaFeatures.generators,
	        token, isStatic, body = [], method, computed, key;

	    var existingProps = {},
	        topMarker = markerCreate(),
	        marker;

	    existingProps.static = new StringMap();
	    existingProps.prototype = new StringMap();

	    expect("{");

	    while (!match("}")) {

	        // extra semicolons are fine
	        if (match(";")) {
	            lex();
	            continue;
	        }

	        token = lookahead;
	        isStatic = false;
	        generator = match("*");
	        computed = match("[");
	        marker = markerCreate();

	        if (generator) {
	            if (!allowGenerators) {
	                throwUnexpected(lookahead);
	            }
	            lex();
	        }

	        key = parseObjectPropertyKey();

	        // static generator methods
	        if (key.name === "static" && match("*")) {
	            if (!allowGenerators) {
	                throwUnexpected(lookahead);
	            }
	            generator = true;
	            lex();
	        }

	        if (key.name === "static" && lookaheadPropertyName()) {
	            token = lookahead;
	            isStatic = true;
	            computed = match("[");
	            key = parseObjectPropertyKey();
	        }

	        if (generator) {
	            method = parseGeneratorProperty(key, marker);
	        } else {
	            method = tryParseMethodDefinition(token, key, computed, marker, generator);
	        }

	        if (method) {
	            method.static = isStatic;
	            if (method.kind === "init") {
	                method.kind = "method";
	            }

	            if (!isStatic) {

	                if (!method.computed && (method.key.name || (method.key.value && method.key.value.toString())) === "constructor") {
	                    if (method.kind !== "method" || !method.method || method.value.generator) {
	                        throwUnexpected(token, Messages.ConstructorSpecialMethod);
	                    }
	                    if (hasConstructor) {
	                        throwUnexpected(token, Messages.DuplicateConstructor);
	                    } else {
	                        hasConstructor = true;
	                    }
	                    method.kind = "constructor";
	                }
	            } else {
	                if (!method.computed && (method.key.name || method.key.value.toString()) === "prototype") {
	                    throwUnexpected(token, Messages.StaticPrototype);
	                }
	            }
	            method.type = astNodeTypes.MethodDefinition;
	            delete method.method;
	            delete method.shorthand;
	            body.push(method);
	        } else {
	            throwUnexpected(lookahead);
	        }
	    }

	    lex();
	    return markerApply(topMarker, astNodeFactory.createClassBody(body));
	}

	function parseClassExpression() {
	    var id = null, superClass = null, marker = markerCreate(),
	        previousStrict = strict, classBody;

	    // classes run in strict mode
	    strict = true;

	    expectKeyword("class");

	    if (lookahead.type === Token.Identifier) {
	        id = parseVariableIdentifier();
	    }

	    if (matchKeyword("extends")) {
	        lex();
	        superClass = parseLeftHandSideExpressionAllowCall();
	    }

	    classBody = parseClassBody();
	    strict = previousStrict;

	    return markerApply(marker, astNodeFactory.createClassExpression(id, superClass, classBody));
	}

	function parseClassDeclaration(identifierIsOptional) {
	    var id = null, superClass = null, marker = markerCreate(),
	        previousStrict = strict, classBody;

	    // classes run in strict mode
	    strict = true;

	    expectKeyword("class");

	    if (!identifierIsOptional || lookahead.type === Token.Identifier) {
	        id = parseVariableIdentifier();
	    }

	    if (matchKeyword("extends")) {
	        lex();
	        superClass = parseLeftHandSideExpressionAllowCall();
	    }

	    classBody = parseClassBody();
	    strict = previousStrict;

	    return markerApply(marker, astNodeFactory.createClassDeclaration(id, superClass, classBody));
	}

	// 15 Program

	function parseSourceElement() {

	    var allowClasses = extra.ecmaFeatures.classes,
	        allowModules = extra.ecmaFeatures.modules,
	        allowBlockBindings = extra.ecmaFeatures.blockBindings;

	    if (lookahead.type === Token.Keyword) {
	        switch (lookahead.value) {
	            case "export":
	                if (!allowModules) {
	                    throwErrorTolerant({}, Messages.IllegalExportDeclaration);
	                }
	                return parseExportDeclaration();
	            case "import":
	                if (!allowModules) {
	                    throwErrorTolerant({}, Messages.IllegalImportDeclaration);
	                }
	                return parseImportDeclaration();
	            case "function":
	                return parseFunctionDeclaration();
	            case "class":
	                if (allowClasses) {
	                    return parseClassDeclaration();
	                }
	                break;
	            case "const":
	            case "let":
	                if (allowBlockBindings) {
	                    return parseConstLetDeclaration(lookahead.value);
	                }
	                /* falls through */
	            default:
	                return parseStatement();
	        }
	    }

	    if (lookahead.type !== Token.EOF) {
	        return parseStatement();
	    }
	}

	function parseSourceElements() {
	    var sourceElement, sourceElements = [], token, directive, firstRestricted;

	    while (index < length) {
	        token = lookahead;
	        if (token.type !== Token.StringLiteral) {
	            break;
	        }

	        sourceElement = parseSourceElement();
	        sourceElements.push(sourceElement);
	        if (sourceElement.expression.type !== astNodeTypes.Literal) {
	            // this is not directive
	            break;
	        }
	        directive = source.slice(token.range[0] + 1, token.range[1] - 1);
	        if (directive === "use strict") {
	            strict = true;
	            if (firstRestricted) {
	                throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
	            }
	        } else {
	            if (!firstRestricted && token.octal) {
	                firstRestricted = token;
	            }
	        }
	    }

	    while (index < length) {
	        sourceElement = parseSourceElement();
	        /* istanbul ignore if */
	        if (typeof sourceElement === "undefined") {
	            break;
	        }
	        sourceElements.push(sourceElement);
	    }
	    return sourceElements;
	}

	function parseProgram() {
	    var body,
	        marker,
	        isModule = !!extra.ecmaFeatures.modules;

	    skipComment();
	    peek();
	    marker = markerCreate();
	    strict = isModule;

	    body = parseSourceElements();
	    return markerApply(marker, astNodeFactory.createProgram(body, isModule ? "module" : "script"));
	}

	function filterTokenLocation() {
	    var i, entry, token, tokens = [];

	    for (i = 0; i < extra.tokens.length; ++i) {
	        entry = extra.tokens[i];
	        token = {
	            type: entry.type,
	            value: entry.value
	        };
	        if (entry.regex) {
	            token.regex = {
	                pattern: entry.regex.pattern,
	                flags: entry.regex.flags
	            };
	        }
	        if (extra.range) {
	            token.range = entry.range;
	        }
	        if (extra.loc) {
	            token.loc = entry.loc;
	        }
	        tokens.push(token);
	    }

	    extra.tokens = tokens;
	}

	//------------------------------------------------------------------------------
	// Tokenizer
	//------------------------------------------------------------------------------

	function tokenize(code, options) {
	    var toString,
	        tokens;

	    toString = String;
	    if (typeof code !== "string" && !(code instanceof String)) {
	        code = toString(code);
	    }

	    source = code;
	    index = 0;
	    lineNumber = (source.length > 0) ? 1 : 0;
	    lineStart = 0;
	    length = source.length;
	    lookahead = null;
	    state = {
	        allowIn: true,
	        labelSet: {},
	        parenthesisCount: 0,
	        inFunctionBody: false,
	        inIteration: false,
	        inSwitch: false,
	        lastCommentStart: -1,
	        yieldAllowed: false,
	        curlyStack: [],
	        curlyLastIndex: 0,
	        inJSXSpreadAttribute: false,
	        inJSXChild: false,
	        inJSXTag: false
	    };

	    extra = {
	        ecmaFeatures: defaultFeatures
	    };

	    // Options matching.
	    options = options || {};

	    // Of course we collect tokens here.
	    options.tokens = true;
	    extra.tokens = [];
	    extra.tokenize = true;

	    // The following two fields are necessary to compute the Regex tokens.
	    extra.openParenToken = -1;
	    extra.openCurlyToken = -1;

	    extra.range = (typeof options.range === "boolean") && options.range;
	    extra.loc = (typeof options.loc === "boolean") && options.loc;

	    if (typeof options.comment === "boolean" && options.comment) {
	        extra.comments = [];
	    }
	    if (typeof options.tolerant === "boolean" && options.tolerant) {
	        extra.errors = [];
	    }

	    // apply parsing flags
	    if (options.ecmaFeatures && typeof options.ecmaFeatures === "object") {
	        extra.ecmaFeatures = options.ecmaFeatures;
	    }

	    try {
	        peek();
	        if (lookahead.type === Token.EOF) {
	            return extra.tokens;
	        }

	        lex();
	        while (lookahead.type !== Token.EOF) {
	            try {
	                lex();
	            } catch (lexError) {
	                if (extra.errors) {
	                    extra.errors.push(lexError);
	                    // We have to break on the first error
	                    // to avoid infinite loops.
	                    break;
	                } else {
	                    throw lexError;
	                }
	            }
	        }

	        filterTokenLocation();
	        tokens = extra.tokens;

	        if (typeof extra.comments !== "undefined") {
	            tokens.comments = extra.comments;
	        }
	        if (typeof extra.errors !== "undefined") {
	            tokens.errors = extra.errors;
	        }
	    } catch (e) {
	        throw e;
	    } finally {
	        extra = {};
	    }
	    return tokens;
	}

	//------------------------------------------------------------------------------
	// Parser
	//------------------------------------------------------------------------------

	function parse(code, options) {
	    var program, toString;

	    toString = String;
	    if (typeof code !== "string" && !(code instanceof String)) {
	        code = toString(code);
	    }

	    source = code;
	    index = 0;
	    lineNumber = (source.length > 0) ? 1 : 0;
	    lineStart = 0;
	    length = source.length;
	    lookahead = null;
	    state = {
	        allowIn: true,
	        labelSet: new StringMap(),
	        parenthesisCount: 0,
	        inFunctionBody: false,
	        inIteration: false,
	        inSwitch: false,
	        lastCommentStart: -1,
	        yieldAllowed: false,
	        curlyStack: [],
	        curlyLastIndex: 0,
	        inJSXSpreadAttribute: false,
	        inJSXChild: false,
	        inJSXTag: false
	    };

	    extra = {
	        ecmaFeatures: Object.create(defaultFeatures)
	    };

	    // for template strings
	    state.curlyStack = [];

	    if (typeof options !== "undefined") {
	        extra.range = (typeof options.range === "boolean") && options.range;
	        extra.loc = (typeof options.loc === "boolean") && options.loc;
	        extra.attachComment = (typeof options.attachComment === "boolean") && options.attachComment;

	        if (extra.loc && options.source !== null && options.source !== undefined) {
	            extra.source = toString(options.source);
	        }

	        if (typeof options.tokens === "boolean" && options.tokens) {
	            extra.tokens = [];
	        }
	        if (typeof options.comment === "boolean" && options.comment) {
	            extra.comments = [];
	        }
	        if (typeof options.tolerant === "boolean" && options.tolerant) {
	            extra.errors = [];
	        }
	        if (extra.attachComment) {
	            extra.range = true;
	            extra.comments = [];
	            commentAttachment.reset();
	        }

	        if (options.sourceType === "module") {
	            extra.ecmaFeatures = {
	                arrowFunctions: true,
	                blockBindings: true,
	                regexUFlag: true,
	                regexYFlag: true,
	                templateStrings: true,
	                binaryLiterals: true,
	                octalLiterals: true,
	                unicodeCodePointEscapes: true,
	                superInFunctions: true,
	                defaultParams: true,
	                restParams: true,
	                forOf: true,
	                objectLiteralComputedProperties: true,
	                objectLiteralShorthandMethods: true,
	                objectLiteralShorthandProperties: true,
	                objectLiteralDuplicateProperties: true,
	                generators: true,
	                destructuring: true,
	                classes: true,
	                modules: true,
	                newTarget: true
	            };
	        }

	        // apply parsing flags after sourceType to allow overriding
	        if (options.ecmaFeatures && typeof options.ecmaFeatures === "object") {

	            // if it's a module, augment the ecmaFeatures
	            if (options.sourceType === "module") {
	                Object.keys(options.ecmaFeatures).forEach(function(key) {
	                    extra.ecmaFeatures[key] = options.ecmaFeatures[key];
	                });
	            } else {
	                extra.ecmaFeatures = options.ecmaFeatures;
	            }
	        }

	    }

	    try {
	        program = parseProgram();
	        if (typeof extra.comments !== "undefined") {
	            program.comments = extra.comments;
	        }
	        if (typeof extra.tokens !== "undefined") {
	            filterTokenLocation();
	            program.tokens = extra.tokens;
	        }
	        if (typeof extra.errors !== "undefined") {
	            program.errors = extra.errors;
	        }
	    } catch (e) {
	        throw e;
	    } finally {
	        extra = {};
	    }

	    return program;
	}

	//------------------------------------------------------------------------------
	// Public
	//------------------------------------------------------------------------------

	exports.version = __webpack_require__(194).version;

	exports.tokenize = tokenize;

	exports.parse = parse;

	// Deep copy.
	/* istanbul ignore next */
	exports.Syntax = (function () {
	    var name, types = {};

	    if (typeof Object.create === "function") {
	        types = Object.create(null);
	    }

	    for (name in astNodeTypes) {
	        if (astNodeTypes.hasOwnProperty(name)) {
	            types[name] = astNodeTypes[name];
	        }
	    }

	    if (typeof Object.freeze === "function") {
	        Object.freeze(types);
	    }

	    return types;
	}());


/***/ },
/* 185 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Error messages returned by the parser.
	 * @author Nicholas C. Zakas
	 * @copyright 2014 Nicholas C. Zakas. All rights reserved.
	 * @copyright 2011-2013 Ariya Hidayat <ariya.hidayat@gmail.com>
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 * * Redistributions of source code must retain the above copyright
	 *   notice, this list of conditions and the following disclaimer.
	 * * Redistributions in binary form must reproduce the above copyright
	 *   notice, this list of conditions and the following disclaimer in the
	 *   documentation and/or other materials provided with the distribution.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	 * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------

	// None!

	//------------------------------------------------------------------------------
	// Public
	//------------------------------------------------------------------------------

	// error messages should be identical to V8 where possible
	module.exports = {
	    UnexpectedToken: "Unexpected token %0",
	    UnexpectedNumber: "Unexpected number",
	    UnexpectedString: "Unexpected string",
	    UnexpectedIdentifier: "Unexpected identifier",
	    UnexpectedReserved: "Unexpected reserved word",
	    UnexpectedTemplate: "Unexpected quasi %0",
	    UnexpectedEOS: "Unexpected end of input",
	    NewlineAfterThrow: "Illegal newline after throw",
	    InvalidRegExp: "Invalid regular expression",
	    InvalidRegExpFlag: "Invalid regular expression flag",
	    UnterminatedRegExp: "Invalid regular expression: missing /",
	    InvalidLHSInAssignment: "Invalid left-hand side in assignment",
	    InvalidLHSInFormalsList: "Invalid left-hand side in formals list",
	    InvalidLHSInForIn: "Invalid left-hand side in for-in",
	    MultipleDefaultsInSwitch: "More than one default clause in switch statement",
	    NoCatchOrFinally: "Missing catch or finally after try",
	    NoUnintializedConst: "Const must be initialized",
	    UnknownLabel: "Undefined label '%0'",
	    Redeclaration: "%0 '%1' has already been declared",
	    IllegalContinue: "Illegal continue statement",
	    IllegalBreak: "Illegal break statement",
	    IllegalReturn: "Illegal return statement",
	    IllegalYield: "Illegal yield expression",
	    IllegalSpread: "Illegal spread element",
	    StrictModeWith: "Strict mode code may not include a with statement",
	    StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode",
	    StrictVarName: "Variable name may not be eval or arguments in strict mode",
	    StrictParamName: "Parameter name eval or arguments is not allowed in strict mode",
	    StrictParamDupe: "Strict mode function may not have duplicate parameter names",
	    TemplateOctalLiteral: "Octal literals are not allowed in template strings.",
	    ParameterAfterRestParameter: "Rest parameter must be last formal parameter",
	    DefaultRestParameter: "Rest parameter can not have a default value",
	    ElementAfterSpreadElement: "Spread must be the final element of an element list",
	    ObjectPatternAsRestParameter: "Invalid rest parameter",
	    ObjectPatternAsSpread: "Invalid spread argument",
	    StrictFunctionName: "Function name may not be eval or arguments in strict mode",
	    StrictOctalLiteral: "Octal literals are not allowed in strict mode.",
	    StrictDelete: "Delete of an unqualified identifier in strict mode.",
	    StrictDuplicateProperty: "Duplicate data property in object literal not allowed in strict mode",
	    DuplicatePrototypeProperty: "Duplicate '__proto__' property in object literal are not allowed",
	    ConstructorSpecialMethod: "Class constructor may not be an accessor",
	    DuplicateConstructor: "A class may only have one constructor",
	    StaticPrototype: "Classes may not have static property named prototype",
	    AccessorDataProperty: "Object literal may not have data and accessor property with the same name",
	    AccessorGetSet: "Object literal may not have multiple get/set accessors with the same name",
	    StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode",
	    StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode",
	    StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode",
	    StrictReservedWord: "Use of future reserved word in strict mode",
	    InvalidJSXAttributeValue: "JSX value should be either an expression or a quoted JSX text",
	    ExpectedJSXClosingTag: "Expected corresponding JSX closing tag for %0",
	    AdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag",
	    MissingFromClause: "Missing from clause",
	    NoAsAfterImportNamespace: "Missing as after import *",
	    InvalidModuleSpecifier: "Invalid module specifier",
	    IllegalImportDeclaration: "Illegal import declaration",
	    IllegalExportDeclaration: "Illegal export declaration"
	};


/***/ },
/* 186 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Various syntax/pattern checks for parsing.
	 * @author Nicholas C. Zakas
	 * @copyright 2014 Nicholas C. Zakas. All rights reserved.
	 * @copyright 2011-2013 Ariya Hidayat <ariya.hidayat@gmail.com>
	 * @copyright 2012-2013 Mathias Bynens <mathias@qiwi.be>
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 * * Redistributions of source code must retain the above copyright
	 *   notice, this list of conditions and the following disclaimer.
	 * * Redistributions in binary form must reproduce the above copyright
	 *   notice, this list of conditions and the following disclaimer in the
	 *   documentation and/or other materials provided with the distribution.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	 * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------

	// None!

	//------------------------------------------------------------------------------
	// Private
	//------------------------------------------------------------------------------

	// See also tools/generate-identifier-regex.js.
	var Regex = {
	    NonAsciiIdentifierStart: new RegExp("[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]"),
	    NonAsciiIdentifierPart: new RegExp("[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0\u08A2-\u08AC\u08E4-\u08FE\u0900-\u0963\u0966-\u096F\u0971-\u0977\u0979-\u097F\u0981-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C82\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D02\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191C\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1D00-\u1DE6\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA697\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7B\uAA80-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE26\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]"),
	    LeadingZeros: new RegExp("^0+(?!$)")
	};

	//------------------------------------------------------------------------------
	// Public
	//------------------------------------------------------------------------------

	module.exports = {

	    Regex: Regex,

	    isDecimalDigit: function(ch) {
	        return (ch >= 48 && ch <= 57);   // 0..9
	    },

	    isHexDigit: function(ch) {
	        return "0123456789abcdefABCDEF".indexOf(ch) >= 0;
	    },

	    isOctalDigit: function(ch) {
	        return "01234567".indexOf(ch) >= 0;
	    },

	    // 7.2 White Space

	    isWhiteSpace: function(ch) {
	        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||
	            (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);
	    },

	    // 7.3 Line Terminators

	    isLineTerminator: function(ch) {
	        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);
	    },

	    // 7.6 Identifier Names and Identifiers

	    isIdentifierStart: function(ch) {
	        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
	            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
	            (ch >= 0x61 && ch <= 0x7A) ||         // a..z
	            (ch === 0x5C) ||                      // \ (backslash)
	            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));
	    },

	    isIdentifierPart: function(ch) {
	        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
	            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
	            (ch >= 0x61 && ch <= 0x7A) ||         // a..z
	            (ch >= 0x30 && ch <= 0x39) ||         // 0..9
	            (ch === 0x5C) ||                      // \ (backslash)
	            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));
	    },

	    // 7.6.1.2 Future Reserved Words

	    isFutureReservedWord: function(id) {
	        switch (id) {
	            case "class":
	            case "enum":
	            case "export":
	            case "extends":
	            case "import":
	            case "super":
	                return true;
	            default:
	                return false;
	        }
	    },

	    isStrictModeReservedWord: function(id, ecmaFeatures) {
	        switch (id) {
	            case "implements":
	            case "interface":
	            case "package":
	            case "private":
	            case "protected":
	            case "public":
	            case "static":
	            case "yield":
	            case "let":
	                return true;
	            case "await":
	                return ecmaFeatures.modules;
	            default:
	                return false;
	        }
	    },

	    isRestrictedWord: function(id) {
	        return id === "eval" || id === "arguments";
	    },

	    // 7.6.1.1 Keywords

	    isKeyword: function(id, strict, ecmaFeatures) {

	        if (strict && this.isStrictModeReservedWord(id, ecmaFeatures)) {
	            return true;
	        }

	        // "const" is specialized as Keyword in V8.
	        // "yield" and "let" are for compatiblity with SpiderMonkey and ES.next.
	        // Some others are from future reserved words.

	        switch (id.length) {
	            case 2:
	                return (id === "if") || (id === "in") || (id === "do");
	            case 3:
	                return (id === "var") || (id === "for") || (id === "new") ||
	                    (id === "try") || (id === "let");
	            case 4:
	                return (id === "this") || (id === "else") || (id === "case") ||
	                    (id === "void") || (id === "with") || (id === "enum");
	            case 5:
	                return (id === "while") || (id === "break") || (id === "catch") ||
	                    (id === "throw") || (id === "const") || (!ecmaFeatures.generators && id === "yield") ||
	                    (id === "class") || (id === "super");
	            case 6:
	                return (id === "return") || (id === "typeof") || (id === "delete") ||
	                    (id === "switch") || (id === "export") || (id === "import");
	            case 7:
	                return (id === "default") || (id === "finally") || (id === "extends");
	            case 8:
	                return (id === "function") || (id === "continue") || (id === "debugger");
	            case 10:
	                return (id === "instanceof");
	            default:
	                return false;
	        }
	    },

	    isJSXIdentifierStart: function(ch) {
	        // exclude backslash (\)
	        return (ch !== 92) && this.isIdentifierStart(ch);
	    },

	    isJSXIdentifierPart: function(ch) {
	        // exclude backslash (\) and add hyphen (-)
	        return (ch !== 92) && (ch === 45 || this.isIdentifierPart(ch));
	    }


	};


/***/ },
/* 187 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Contains token information.
	 * @author Nicholas C. Zakas
	 * @copyright 2014 Nicholas C. Zakas. All rights reserved.
	 * @copyright 2013 Thaddee Tyl <thaddee.tyl@gmail.com>
	 * @copyright 2011-2013 Ariya Hidayat <ariya.hidayat@gmail.com>
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 * * Redistributions of source code must retain the above copyright
	 *   notice, this list of conditions and the following disclaimer.
	 * * Redistributions in binary form must reproduce the above copyright
	 *   notice, this list of conditions and the following disclaimer in the
	 *   documentation and/or other materials provided with the distribution.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	 * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------

	// None!

	//------------------------------------------------------------------------------
	// Private
	//------------------------------------------------------------------------------

	var Token = {
	    BooleanLiteral: 1,
	    EOF: 2,
	    Identifier: 3,
	    Keyword: 4,
	    NullLiteral: 5,
	    NumericLiteral: 6,
	    Punctuator: 7,
	    StringLiteral: 8,
	    RegularExpression: 9,
	    Template: 10,
	    JSXIdentifier: 11,
	    JSXText: 12
	};

	var TokenName = {};
	TokenName[Token.BooleanLiteral] = "Boolean";
	TokenName[Token.EOF] = "<end>";
	TokenName[Token.Identifier] = "Identifier";
	TokenName[Token.Keyword] = "Keyword";
	TokenName[Token.NullLiteral] = "Null";
	TokenName[Token.NumericLiteral] = "Numeric";
	TokenName[Token.Punctuator] = "Punctuator";
	TokenName[Token.StringLiteral] = "String";
	TokenName[Token.RegularExpression] = "RegularExpression";
	TokenName[Token.Template] = "Template";
	TokenName[Token.JSXIdentifier] = "JSXIdentifier";
	TokenName[Token.JSXText] = "JSXText";

	// A function following one of those tokens is an expression.
	var FnExprTokens = ["(", "{", "[", "in", "typeof", "instanceof", "new",
	                "return", "case", "delete", "throw", "void",
	                // assignment operators
	                "=", "+=", "-=", "*=", "/=", "%=", "<<=", ">>=", ">>>=",
	                "&=", "|=", "^=", ",",
	                // binary/unary operators
	                "+", "-", "*", "/", "%", "++", "--", "<<", ">>", ">>>", "&",
	                "|", "^", "!", "~", "&&", "||", "?", ":", "===", "==", ">=",
	                "<=", "<", ">", "!=", "!=="];


	//------------------------------------------------------------------------------
	// Public
	//------------------------------------------------------------------------------

	module.exports = {
	    Token: Token,
	    TokenName: TokenName,
	    FnExprTokens: FnExprTokens
	};


/***/ },
/* 188 */
/***/ function(module, exports) {

	/**
	 * @fileoverview The AST node types produced by the parser.
	 * @author Nicholas C. Zakas
	 * @copyright 2014 Nicholas C. Zakas. All rights reserved.
	 * @copyright 2011-2013 Ariya Hidayat <ariya.hidayat@gmail.com>
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 * * Redistributions of source code must retain the above copyright
	 *   notice, this list of conditions and the following disclaimer.
	 * * Redistributions in binary form must reproduce the above copyright
	 *   notice, this list of conditions and the following disclaimer in the
	 *   documentation and/or other materials provided with the distribution.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	 * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------

	// None!

	//------------------------------------------------------------------------------
	// Public
	//------------------------------------------------------------------------------

	module.exports = {
	    AssignmentExpression: "AssignmentExpression",
	    AssignmentPattern: "AssignmentPattern",
	    ArrayExpression: "ArrayExpression",
	    ArrayPattern: "ArrayPattern",
	    ArrowFunctionExpression: "ArrowFunctionExpression",
	    BlockStatement: "BlockStatement",
	    BinaryExpression: "BinaryExpression",
	    BreakStatement: "BreakStatement",
	    CallExpression: "CallExpression",
	    CatchClause: "CatchClause",
	    ClassBody: "ClassBody",
	    ClassDeclaration: "ClassDeclaration",
	    ClassExpression: "ClassExpression",
	    ConditionalExpression: "ConditionalExpression",
	    ContinueStatement: "ContinueStatement",
	    DoWhileStatement: "DoWhileStatement",
	    DebuggerStatement: "DebuggerStatement",
	    EmptyStatement: "EmptyStatement",
	    ExperimentalRestProperty: "ExperimentalRestProperty",
	    ExperimentalSpreadProperty: "ExperimentalSpreadProperty",
	    ExpressionStatement: "ExpressionStatement",
	    ForStatement: "ForStatement",
	    ForInStatement: "ForInStatement",
	    ForOfStatement: "ForOfStatement",
	    FunctionDeclaration: "FunctionDeclaration",
	    FunctionExpression: "FunctionExpression",
	    Identifier: "Identifier",
	    IfStatement: "IfStatement",
	    Literal: "Literal",
	    LabeledStatement: "LabeledStatement",
	    LogicalExpression: "LogicalExpression",
	    MemberExpression: "MemberExpression",
	    MetaProperty: "MetaProperty",
	    MethodDefinition: "MethodDefinition",
	    NewExpression: "NewExpression",
	    ObjectExpression: "ObjectExpression",
	    ObjectPattern: "ObjectPattern",
	    Program: "Program",
	    Property: "Property",
	    RestElement: "RestElement",
	    ReturnStatement: "ReturnStatement",
	    SequenceExpression: "SequenceExpression",
	    SpreadElement: "SpreadElement",
	    Super: "Super",
	    SwitchCase: "SwitchCase",
	    SwitchStatement: "SwitchStatement",
	    TaggedTemplateExpression: "TaggedTemplateExpression",
	    TemplateElement: "TemplateElement",
	    TemplateLiteral: "TemplateLiteral",
	    ThisExpression: "ThisExpression",
	    ThrowStatement: "ThrowStatement",
	    TryStatement: "TryStatement",
	    UnaryExpression: "UnaryExpression",
	    UpdateExpression: "UpdateExpression",
	    VariableDeclaration: "VariableDeclaration",
	    VariableDeclarator: "VariableDeclarator",
	    WhileStatement: "WhileStatement",
	    WithStatement: "WithStatement",
	    YieldExpression: "YieldExpression",
	    JSXIdentifier: "JSXIdentifier",
	    JSXNamespacedName: "JSXNamespacedName",
	    JSXMemberExpression: "JSXMemberExpression",
	    JSXEmptyExpression: "JSXEmptyExpression",
	    JSXExpressionContainer: "JSXExpressionContainer",
	    JSXElement: "JSXElement",
	    JSXClosingElement: "JSXClosingElement",
	    JSXOpeningElement: "JSXOpeningElement",
	    JSXAttribute: "JSXAttribute",
	    JSXSpreadAttribute: "JSXSpreadAttribute",
	    JSXText: "JSXText",
	    ExportDefaultDeclaration: "ExportDefaultDeclaration",
	    ExportNamedDeclaration: "ExportNamedDeclaration",
	    ExportAllDeclaration: "ExportAllDeclaration",
	    ExportSpecifier: "ExportSpecifier",
	    ImportDeclaration: "ImportDeclaration",
	    ImportSpecifier: "ImportSpecifier",
	    ImportDefaultSpecifier: "ImportDefaultSpecifier",
	    ImportNamespaceSpecifier: "ImportNamespaceSpecifier"
	};


/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview A factory for creating AST nodes
	 * @author Fred K. Schott
	 * @copyright 2014 Fred K. Schott. All rights reserved.
	 * @copyright 2011-2013 Ariya Hidayat <ariya.hidayat@gmail.com>
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 * * Redistributions of source code must retain the above copyright
	 *   notice, this list of conditions and the following disclaimer.
	 * * Redistributions in binary form must reproduce the above copyright
	 *   notice, this list of conditions and the following disclaimer in the
	 *   documentation and/or other materials provided with the distribution.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	 * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------

	var astNodeTypes = __webpack_require__(188);

	//------------------------------------------------------------------------------
	// Public
	//------------------------------------------------------------------------------

	module.exports = {

	    /**
	     * Create an Array Expression ASTNode out of an array of elements
	     * @param {ASTNode[]} elements An array of ASTNode elements
	     * @returns {ASTNode} An ASTNode representing the entire array expression
	     */
	    createArrayExpression: function(elements) {
	        return {
	            type: astNodeTypes.ArrayExpression,
	            elements: elements
	        };
	    },

	    /**
	     * Create an Arrow Function Expression ASTNode
	     * @param {ASTNode} params The function arguments
	     * @param {ASTNode} body The function body
	     * @param {boolean} expression True if the arrow function is created via an expression.
	     *      Always false for declarations, but kept here to be in sync with
	     *      FunctionExpression objects.
	     * @returns {ASTNode} An ASTNode representing the entire arrow function expression
	     */
	    createArrowFunctionExpression: function (params, body, expression) {
	        return {
	            type: astNodeTypes.ArrowFunctionExpression,
	            id: null,
	            params: params,
	            body: body,
	            generator: false,
	            expression: expression
	        };
	    },

	    /**
	     * Create an ASTNode representation of an assignment expression
	     * @param {ASTNode} operator The assignment operator
	     * @param {ASTNode} left The left operand
	     * @param {ASTNode} right The right operand
	     * @returns {ASTNode} An ASTNode representing the entire assignment expression
	     */
	    createAssignmentExpression: function(operator, left, right) {
	        return {
	            type: astNodeTypes.AssignmentExpression,
	            operator: operator,
	            left: left,
	            right: right
	        };
	    },

	    /**
	     * Create an ASTNode representation of an assignment pattern (default parameters)
	     * @param {ASTNode} left The left operand
	     * @param {ASTNode} right The right operand
	     * @returns {ASTNode} An ASTNode representing the entire assignment pattern
	     */
	    createAssignmentPattern: function(left, right) {
	        return {
	            type: astNodeTypes.AssignmentPattern,
	            left: left,
	            right: right
	        };
	    },

	    /**
	     * Create an ASTNode representation of a binary expression
	     * @param {ASTNode} operator The assignment operator
	     * @param {ASTNode} left The left operand
	     * @param {ASTNode} right The right operand
	     * @returns {ASTNode} An ASTNode representing the entire binary expression
	     */
	    createBinaryExpression: function(operator, left, right) {
	        var type = (operator === "||" || operator === "&&") ? astNodeTypes.LogicalExpression :
	                    astNodeTypes.BinaryExpression;
	        return {
	            type: type,
	            operator: operator,
	            left: left,
	            right: right
	        };
	    },

	    /**
	     * Create an ASTNode representation of a block statement
	     * @param {ASTNode} body The block statement body
	     * @returns {ASTNode} An ASTNode representing the entire block statement
	     */
	    createBlockStatement: function(body) {
	        return {
	            type: astNodeTypes.BlockStatement,
	            body: body
	        };
	    },

	    /**
	     * Create an ASTNode representation of a break statement
	     * @param {ASTNode} label The break statement label
	     * @returns {ASTNode} An ASTNode representing the break statement
	     */
	    createBreakStatement: function(label) {
	        return {
	            type: astNodeTypes.BreakStatement,
	            label: label
	        };
	    },

	    /**
	     * Create an ASTNode representation of a call expression
	     * @param {ASTNode} callee The function being called
	     * @param {ASTNode[]} args An array of ASTNodes representing the function call arguments
	     * @returns {ASTNode} An ASTNode representing the entire call expression
	     */
	    createCallExpression: function(callee, args) {
	        return {
	            type: astNodeTypes.CallExpression,
	            callee: callee,
	            "arguments": args
	        };
	    },

	    /**
	     * Create an ASTNode representation of a catch clause/block
	     * @param {ASTNode} param Any catch clause exeption/conditional parameter information
	     * @param {ASTNode} body The catch block body
	     * @returns {ASTNode} An ASTNode representing the entire catch clause
	     */
	    createCatchClause: function(param, body) {
	        return {
	            type: astNodeTypes.CatchClause,
	            param: param,
	            body: body
	        };
	    },

	    /**
	     * Creates an ASTNode representation of a class body.
	     * @param {ASTNode} body The node representing the body of the class.
	     * @returns {ASTNode} An ASTNode representing the class body.
	     */
	    createClassBody: function(body) {
	        return {
	            type: astNodeTypes.ClassBody,
	            body: body
	        };
	    },

	    createClassExpression: function(id, superClass, body) {
	        return {
	            type: astNodeTypes.ClassExpression,
	            id: id,
	            superClass: superClass,
	            body: body
	        };
	    },

	    createClassDeclaration: function(id, superClass, body) {
	        return {
	            type: astNodeTypes.ClassDeclaration,
	            id: id,
	            superClass: superClass,
	            body: body
	        };
	    },

	    createMethodDefinition: function(propertyType, kind, key, value, computed) {
	        return {
	            type: astNodeTypes.MethodDefinition,
	            key: key,
	            value: value,
	            kind: kind,
	            "static": propertyType === "static",
	            computed: computed
	        };
	    },

	    createMetaProperty: function(meta, property) {
	        return {
	            type: astNodeTypes.MetaProperty,
	            meta: meta,
	            property: property
	        };
	    },

	    /**
	     * Create an ASTNode representation of a conditional expression
	     * @param {ASTNode} test The conditional to evaluate
	     * @param {ASTNode} consequent The code to be run if the test returns true
	     * @param {ASTNode} alternate The code to be run if the test returns false
	     * @returns {ASTNode} An ASTNode representing the entire conditional expression
	     */
	    createConditionalExpression: function(test, consequent, alternate) {
	        return {
	            type: astNodeTypes.ConditionalExpression,
	            test: test,
	            consequent: consequent,
	            alternate: alternate
	        };
	    },

	    /**
	     * Create an ASTNode representation of a continue statement
	     * @param {?ASTNode} label The optional continue label (null if not set)
	     * @returns {ASTNode} An ASTNode representing the continue statement
	     */
	    createContinueStatement: function(label) {
	        return {
	            type: astNodeTypes.ContinueStatement,
	            label: label
	        };
	    },

	    /**
	     * Create an ASTNode representation of a debugger statement
	     * @returns {ASTNode} An ASTNode representing the debugger statement
	     */
	    createDebuggerStatement: function() {
	        return {
	            type: astNodeTypes.DebuggerStatement
	        };
	    },

	    /**
	     * Create an ASTNode representation of an empty statement
	     * @returns {ASTNode} An ASTNode representing an empty statement
	     */
	    createEmptyStatement: function() {
	        return {
	            type: astNodeTypes.EmptyStatement
	        };
	    },

	    /**
	     * Create an ASTNode representation of an expression statement
	     * @param {ASTNode} expression The expression
	     * @returns {ASTNode} An ASTNode representing an expression statement
	     */
	    createExpressionStatement: function(expression) {
	        return {
	            type: astNodeTypes.ExpressionStatement,
	            expression: expression
	        };
	    },

	    /**
	     * Create an ASTNode representation of a while statement
	     * @param {ASTNode} test The while conditional
	     * @param {ASTNode} body The while loop body
	     * @returns {ASTNode} An ASTNode representing a while statement
	     */
	    createWhileStatement: function(test, body) {
	        return {
	            type: astNodeTypes.WhileStatement,
	            test: test,
	            body: body
	        };
	    },

	    /**
	     * Create an ASTNode representation of a do..while statement
	     * @param {ASTNode} test The do..while conditional
	     * @param {ASTNode} body The do..while loop body
	     * @returns {ASTNode} An ASTNode representing a do..while statement
	     */
	    createDoWhileStatement: function(test, body) {
	        return {
	            type: astNodeTypes.DoWhileStatement,
	            body: body,
	            test: test
	        };
	    },

	    /**
	     * Create an ASTNode representation of a for statement
	     * @param {ASTNode} init The initialization expression
	     * @param {ASTNode} test The conditional test expression
	     * @param {ASTNode} update The update expression
	     * @param {ASTNode} body The statement body
	     * @returns {ASTNode} An ASTNode representing a for statement
	     */
	    createForStatement: function(init, test, update, body) {
	        return {
	            type: astNodeTypes.ForStatement,
	            init: init,
	            test: test,
	            update: update,
	            body: body
	        };
	    },

	    /**
	     * Create an ASTNode representation of a for..in statement
	     * @param {ASTNode} left The left-side variable for the property name
	     * @param {ASTNode} right The right-side object
	     * @param {ASTNode} body The statement body
	     * @returns {ASTNode} An ASTNode representing a for..in statement
	     */
	    createForInStatement: function(left, right, body) {
	        return {
	            type: astNodeTypes.ForInStatement,
	            left: left,
	            right: right,
	            body: body,
	            each: false
	        };
	    },

	    /**
	     * Create an ASTNode representation of a for..of statement
	     * @param {ASTNode} left The left-side variable for the property value
	     * @param {ASTNode} right The right-side object
	     * @param {ASTNode} body The statement body
	     * @returns {ASTNode} An ASTNode representing a for..of statement
	     */
	    createForOfStatement: function(left, right, body) {
	        return {
	            type: astNodeTypes.ForOfStatement,
	            left: left,
	            right: right,
	            body: body
	        };
	    },

	    /**
	     * Create an ASTNode representation of a function declaration
	     * @param {ASTNode} id The function name
	     * @param {ASTNode} params The function arguments
	     * @param {ASTNode} body The function body
	     * @param {boolean} generator True if the function is a generator, false if not.
	     * @param {boolean} expression True if the function is created via an expression.
	     *      Always false for declarations, but kept here to be in sync with
	     *      FunctionExpression objects.
	     * @returns {ASTNode} An ASTNode representing a function declaration
	     */
	    createFunctionDeclaration: function (id, params, body, generator, expression) {
	        return {
	            type: astNodeTypes.FunctionDeclaration,
	            id: id,
	            params: params || [],
	            body: body,
	            generator: !!generator,
	            expression: !!expression
	        };
	    },

	    /**
	     * Create an ASTNode representation of a function expression
	     * @param {ASTNode} id The function name
	     * @param {ASTNode} params The function arguments
	     * @param {ASTNode} body The function body
	     * @param {boolean} generator True if the function is a generator, false if not.
	     * @param {boolean} expression True if the function is created via an expression.
	     * @returns {ASTNode} An ASTNode representing a function declaration
	     */
	    createFunctionExpression: function (id, params, body, generator, expression) {
	        return {
	            type: astNodeTypes.FunctionExpression,
	            id: id,
	            params: params || [],
	            body: body,
	            generator: !!generator,
	            expression: !!expression
	        };
	    },

	    /**
	     * Create an ASTNode representation of an identifier
	     * @param {ASTNode} name The identifier name
	     * @returns {ASTNode} An ASTNode representing an identifier
	     */
	    createIdentifier: function(name) {
	        return {
	            type: astNodeTypes.Identifier,
	            name: name
	        };
	    },

	    /**
	     * Create an ASTNode representation of an if statement
	     * @param {ASTNode} test The if conditional expression
	     * @param {ASTNode} consequent The consequent if statement to run
	     * @param {ASTNode} alternate the "else" alternate statement
	     * @returns {ASTNode} An ASTNode representing an if statement
	     */
	    createIfStatement: function(test, consequent, alternate) {
	        return {
	            type: astNodeTypes.IfStatement,
	            test: test,
	            consequent: consequent,
	            alternate: alternate
	        };
	    },

	    /**
	     * Create an ASTNode representation of a labeled statement
	     * @param {ASTNode} label The statement label
	     * @param {ASTNode} body The labeled statement body
	     * @returns {ASTNode} An ASTNode representing a labeled statement
	     */
	    createLabeledStatement: function(label, body) {
	        return {
	            type: astNodeTypes.LabeledStatement,
	            label: label,
	            body: body
	        };
	    },

	    /**
	     * Create an ASTNode literal from the source code
	     * @param {ASTNode} token The ASTNode token
	     * @param {string} source The source code to get the literal from
	     * @returns {ASTNode} An ASTNode representing the new literal
	     */
	    createLiteralFromSource: function(token, source) {
	        var node = {
	            type: astNodeTypes.Literal,
	            value: token.value,
	            raw: source.slice(token.range[0], token.range[1])
	        };

	        // regular expressions have regex properties
	        if (token.regex) {
	            node.regex = token.regex;
	        }

	        return node;
	    },

	    /**
	     * Create an ASTNode template element
	     * @param {Object} value Data on the element value
	     * @param {string} value.raw The raw template string
	     * @param {string} value.cooked The processed template string
	     * @param {boolean} tail True if this is the final element in a template string
	     * @returns {ASTNode} An ASTNode representing the template string element
	     */
	    createTemplateElement: function(value, tail) {
	        return {
	            type: astNodeTypes.TemplateElement,
	            value: value,
	            tail: tail
	        };
	    },

	    /**
	     * Create an ASTNode template literal
	     * @param {ASTNode[]} quasis An array of the template string elements
	     * @param {ASTNode[]} expressions An array of the template string expressions
	     * @returns {ASTNode} An ASTNode representing the template string
	     */
	    createTemplateLiteral: function(quasis, expressions) {
	        return {
	            type: astNodeTypes.TemplateLiteral,
	            quasis: quasis,
	            expressions: expressions
	        };
	    },

	    /**
	     * Create an ASTNode representation of a spread element
	     * @param {ASTNode} argument The array being spread
	     * @returns {ASTNode} An ASTNode representing a spread element
	     */
	    createSpreadElement: function(argument) {
	        return {
	            type: astNodeTypes.SpreadElement,
	            argument: argument
	        };
	    },

	    /**
	     * Create an ASTNode representation of an experimental rest property
	     * @param {ASTNode} argument The identifier being rested
	     * @returns {ASTNode} An ASTNode representing a rest element
	     */
	    createExperimentalRestProperty: function(argument) {
	        return {
	            type: astNodeTypes.ExperimentalRestProperty,
	            argument: argument
	        };
	    },

	    /**
	     * Create an ASTNode representation of an experimental spread property
	     * @param {ASTNode} argument The identifier being spread
	     * @returns {ASTNode} An ASTNode representing a spread element
	     */
	    createExperimentalSpreadProperty: function(argument) {
	        return {
	            type: astNodeTypes.ExperimentalSpreadProperty,
	            argument: argument
	        };
	    },

	    /**
	     * Create an ASTNode tagged template expression
	     * @param {ASTNode} tag The tag expression
	     * @param {ASTNode} quasi A TemplateLiteral ASTNode representing
	     * the template string itself.
	     * @returns {ASTNode} An ASTNode representing the tagged template
	     */
	    createTaggedTemplateExpression: function(tag, quasi) {
	        return {
	            type: astNodeTypes.TaggedTemplateExpression,
	            tag: tag,
	            quasi: quasi
	        };
	    },

	    /**
	     * Create an ASTNode representation of a member expression
	     * @param {string} accessor The member access method (bracket or period)
	     * @param {ASTNode} object The object being referenced
	     * @param {ASTNode} property The object-property being referenced
	     * @returns {ASTNode} An ASTNode representing a member expression
	     */
	    createMemberExpression: function(accessor, object, property) {
	        return {
	            type: astNodeTypes.MemberExpression,
	            computed: accessor === "[",
	            object: object,
	            property: property
	        };
	    },

	    /**
	     * Create an ASTNode representation of a new expression
	     * @param {ASTNode} callee The constructor for the new object type
	     * @param {ASTNode} args The arguments passed to the constructor
	     * @returns {ASTNode} An ASTNode representing a new expression
	     */
	    createNewExpression: function(callee, args) {
	        return {
	            type: astNodeTypes.NewExpression,
	            callee: callee,
	            "arguments": args
	        };
	    },

	    /**
	     * Create an ASTNode representation of a new object expression
	     * @param {ASTNode[]} properties An array of ASTNodes that represent all object
	     *      properties and associated values
	     * @returns {ASTNode} An ASTNode representing a new object expression
	     */
	    createObjectExpression: function(properties) {
	        return {
	            type: astNodeTypes.ObjectExpression,
	            properties: properties
	        };
	    },

	    /**
	     * Create an ASTNode representation of a postfix expression
	     * @param {string} operator The postfix operator ("++", "--", etc.)
	     * @param {ASTNode} argument The operator argument
	     * @returns {ASTNode} An ASTNode representing a postfix expression
	     */
	    createPostfixExpression: function(operator, argument) {
	        return {
	            type: astNodeTypes.UpdateExpression,
	            operator: operator,
	            argument: argument,
	            prefix: false
	        };
	    },

	    /**
	     * Create an ASTNode representation of an entire program
	     * @param {ASTNode} body The program body
	     * @param {string} sourceType Either "module" or "script".
	     * @returns {ASTNode} An ASTNode representing an entire program
	     */
	    createProgram: function(body, sourceType) {
	        return {
	            type: astNodeTypes.Program,
	            body: body,
	            sourceType: sourceType
	        };
	    },

	    /**
	     * Create an ASTNode representation of an object property
	     * @param {string} kind The type of property represented ("get", "set", etc.)
	     * @param {ASTNode} key The property key
	     * @param {ASTNode} value The new property value
	     * @param {boolean} method True if the property is also a method (value is a function)
	     * @param {boolean} shorthand True if the property is shorthand
	     * @param {boolean} computed True if the property value has been computed
	     * @returns {ASTNode} An ASTNode representing an object property
	     */
	    createProperty: function(kind, key, value, method, shorthand, computed) {
	        return {
	            type: astNodeTypes.Property,
	            key: key,
	            value: value,
	            kind: kind,
	            method: method,
	            shorthand: shorthand,
	            computed: computed
	        };
	    },

	    /**
	     * Create an ASTNode representation of a rest element
	     * @param {ASTNode} argument The rest argument
	     * @returns {ASTNode} An ASTNode representing a rest element
	     */
	    createRestElement: function (argument) {
	        return {
	            type: astNodeTypes.RestElement,
	            argument: argument
	        };
	    },

	    /**
	     * Create an ASTNode representation of a return statement
	     * @param {?ASTNode} argument The return argument, null if no argument is provided
	     * @returns {ASTNode} An ASTNode representing a return statement
	     */
	    createReturnStatement: function(argument) {
	        return {
	            type: astNodeTypes.ReturnStatement,
	            argument: argument
	        };
	    },

	    /**
	     * Create an ASTNode representation of a sequence of expressions
	     * @param {ASTNode[]} expressions An array containing each expression, in order
	     * @returns {ASTNode} An ASTNode representing a sequence of expressions
	     */
	    createSequenceExpression: function(expressions) {
	        return {
	            type: astNodeTypes.SequenceExpression,
	            expressions: expressions
	        };
	    },

	    /**
	     * Create an ASTNode representation of super
	     * @returns {ASTNode} An ASTNode representing super
	     */
	    createSuper: function() {
	        return {
	            type: astNodeTypes.Super
	        };
	    },

	    /**
	     * Create an ASTNode representation of a switch case statement
	     * @param {ASTNode} test The case value to test against the switch value
	     * @param {ASTNode} consequent The consequent case statement
	     * @returns {ASTNode} An ASTNode representing a switch case
	     */
	    createSwitchCase: function(test, consequent) {
	        return {
	            type: astNodeTypes.SwitchCase,
	            test: test,
	            consequent: consequent
	        };
	    },

	    /**
	     * Create an ASTNode representation of a switch statement
	     * @param {ASTNode} discriminant An expression to test against each case value
	     * @param {ASTNode[]} cases An array of switch case statements
	     * @returns {ASTNode} An ASTNode representing a switch statement
	     */
	    createSwitchStatement: function(discriminant, cases) {
	        return {
	            type: astNodeTypes.SwitchStatement,
	            discriminant: discriminant,
	            cases: cases
	        };
	    },

	    /**
	     * Create an ASTNode representation of a this statement
	     * @returns {ASTNode} An ASTNode representing a this statement
	     */
	    createThisExpression: function() {
	        return {
	            type: astNodeTypes.ThisExpression
	        };
	    },

	    /**
	     * Create an ASTNode representation of a throw statement
	     * @param {ASTNode} argument The argument to throw
	     * @returns {ASTNode} An ASTNode representing a throw statement
	     */
	    createThrowStatement: function(argument) {
	        return {
	            type: astNodeTypes.ThrowStatement,
	            argument: argument
	        };
	    },

	    /**
	     * Create an ASTNode representation of a try statement
	     * @param {ASTNode} block The try block
	     * @param {ASTNode} handler A catch handler
	     * @param {?ASTNode} finalizer The final code block to run after the try/catch has run
	     * @returns {ASTNode} An ASTNode representing a try statement
	     */
	    createTryStatement: function(block, handler, finalizer) {
	        return {
	            type: astNodeTypes.TryStatement,
	            block: block,
	            handler: handler,
	            finalizer: finalizer
	        };
	    },

	    /**
	     * Create an ASTNode representation of a unary expression
	     * @param {string} operator The unary operator
	     * @param {ASTNode} argument The unary operand
	     * @returns {ASTNode} An ASTNode representing a unary expression
	     */
	    createUnaryExpression: function(operator, argument) {
	        if (operator === "++" || operator === "--") {
	            return {
	                type: astNodeTypes.UpdateExpression,
	                operator: operator,
	                argument: argument,
	                prefix: true
	            };
	        }
	        return {
	            type: astNodeTypes.UnaryExpression,
	            operator: operator,
	            argument: argument,
	            prefix: true
	        };
	    },

	    /**
	     * Create an ASTNode representation of a variable declaration
	     * @param {ASTNode[]} declarations An array of variable declarations
	     * @param {string} kind The kind of variable created ("var", "let", etc.)
	     * @returns {ASTNode} An ASTNode representing a variable declaration
	     */
	    createVariableDeclaration: function(declarations, kind) {
	        return {
	            type: astNodeTypes.VariableDeclaration,
	            declarations: declarations,
	            kind: kind
	        };
	    },

	    /**
	     * Create an ASTNode representation of a variable declarator
	     * @param {ASTNode} id The variable ID
	     * @param {ASTNode} init The variable's initial value
	     * @returns {ASTNode} An ASTNode representing a variable declarator
	     */
	    createVariableDeclarator: function(id, init) {
	        return {
	            type: astNodeTypes.VariableDeclarator,
	            id: id,
	            init: init
	        };
	    },

	    /**
	     * Create an ASTNode representation of a with statement
	     * @param {ASTNode} object The with statement object expression
	     * @param {ASTNode} body The with statement body
	     * @returns {ASTNode} An ASTNode representing a with statement
	     */
	    createWithStatement: function(object, body) {
	        return {
	            type: astNodeTypes.WithStatement,
	            object: object,
	            body: body
	        };
	    },

	    createYieldExpression: function(argument, delegate) {
	        return {
	            type: astNodeTypes.YieldExpression,
	            argument: argument || null,
	            delegate: delegate
	        };
	    },

	    createJSXAttribute: function(name, value) {
	        return {
	            type: astNodeTypes.JSXAttribute,
	            name: name,
	            value: value || null
	        };
	    },

	    createJSXSpreadAttribute: function(argument) {
	        return {
	            type: astNodeTypes.JSXSpreadAttribute,
	            argument: argument
	        };
	    },

	    createJSXIdentifier: function(name) {
	        return {
	            type: astNodeTypes.JSXIdentifier,
	            name: name
	        };
	    },

	    createJSXNamespacedName: function(namespace, name) {
	        return {
	            type: astNodeTypes.JSXNamespacedName,
	            namespace: namespace,
	            name: name
	        };
	    },

	    createJSXMemberExpression: function(object, property) {
	        return {
	            type: astNodeTypes.JSXMemberExpression,
	            object: object,
	            property: property
	        };
	    },

	    createJSXElement: function(openingElement, closingElement, children) {
	        return {
	            type: astNodeTypes.JSXElement,
	            openingElement: openingElement,
	            closingElement: closingElement,
	            children: children
	        };
	    },

	    createJSXEmptyExpression: function() {
	        return {
	            type: astNodeTypes.JSXEmptyExpression
	        };
	    },

	    createJSXExpressionContainer: function(expression) {
	        return {
	            type: astNodeTypes.JSXExpressionContainer,
	            expression: expression
	        };
	    },

	    createJSXOpeningElement: function(name, attributes, selfClosing) {
	        return {
	            type: astNodeTypes.JSXOpeningElement,
	            name: name,
	            selfClosing: selfClosing,
	            attributes: attributes
	        };
	    },

	    createJSXClosingElement: function(name) {
	        return {
	            type: astNodeTypes.JSXClosingElement,
	            name: name
	        };
	    },

	    createExportSpecifier: function(local, exported) {
	        return {
	            type: astNodeTypes.ExportSpecifier,
	            exported: exported || local,
	            local: local
	        };
	    },

	    createImportDefaultSpecifier: function(local) {
	        return {
	            type: astNodeTypes.ImportDefaultSpecifier,
	            local: local
	        };
	    },

	    createImportNamespaceSpecifier: function(local) {
	        return {
	            type: astNodeTypes.ImportNamespaceSpecifier,
	            local: local
	        };
	    },

	    createExportNamedDeclaration: function(declaration, specifiers, source) {
	        return {
	            type: astNodeTypes.ExportNamedDeclaration,
	            declaration: declaration,
	            specifiers: specifiers,
	            source: source
	        };
	    },

	    createExportDefaultDeclaration: function(declaration) {
	        return {
	            type: astNodeTypes.ExportDefaultDeclaration,
	            declaration: declaration
	        };
	    },

	    createExportAllDeclaration: function(source) {
	        return {
	            type: astNodeTypes.ExportAllDeclaration,
	            source: source
	        };
	    },

	    createImportSpecifier: function(local, imported) {
	        return {
	            type: astNodeTypes.ImportSpecifier,
	            local: local || imported,
	            imported: imported
	        };
	    },

	    createImportDeclaration: function(specifiers, source) {
	        return {
	            type: astNodeTypes.ImportDeclaration,
	            specifiers: specifiers,
	            source: source
	        };
	    }

	};


/***/ },
/* 190 */
/***/ function(module, exports) {

	/**
	 * @fileoverview The list of feature flags supported by the parser and their default
	 *      settings.
	 * @author Nicholas C. Zakas
	 * @copyright 2015 Fred K. Schott. All rights reserved.
	 * @copyright 2014 Nicholas C. Zakas. All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 * * Redistributions of source code must retain the above copyright
	 *   notice, this list of conditions and the following disclaimer.
	 * * Redistributions in binary form must reproduce the above copyright
	 *   notice, this list of conditions and the following disclaimer in the
	 *   documentation and/or other materials provided with the distribution.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	 * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------

	// None!

	//------------------------------------------------------------------------------
	// Public
	//------------------------------------------------------------------------------

	module.exports = {

	    // enable parsing of arrow functions
	    arrowFunctions: false,

	    // enable parsing of let and const
	    blockBindings: true,

	    // enable parsing of destructured arrays and objects
	    destructuring: false,

	    // enable parsing of regex u flag
	    regexUFlag: false,

	    // enable parsing of regex y flag
	    regexYFlag: false,

	    // enable parsing of template strings
	    templateStrings: false,

	    // enable parsing binary literals
	    binaryLiterals: false,

	    // enable parsing ES6 octal literals
	    octalLiterals: false,

	    // enable parsing unicode code point escape sequences
	    unicodeCodePointEscapes: true,

	    // enable parsing of default parameters
	    defaultParams: false,

	    // enable parsing of rest parameters
	    restParams: false,

	    // enable parsing of for-of statements
	    forOf: false,

	    // enable parsing computed object literal properties
	    objectLiteralComputedProperties: false,

	    // enable parsing of shorthand object literal methods
	    objectLiteralShorthandMethods: false,

	    // enable parsing of shorthand object literal properties
	    objectLiteralShorthandProperties: false,

	    // Allow duplicate object literal properties (except '__proto__')
	    objectLiteralDuplicateProperties: false,

	    // enable parsing of generators/yield
	    generators: false,

	    // support the spread operator
	    spread: false,

	    // enable super in functions
	    superInFunctions: false,

	    // enable parsing of classes
	    classes: false,

	    // enable parsing of new.target
	    newTarget: false,

	    // enable parsing of modules
	    modules: false,

	    // React JSX parsing
	    jsx: false,

	    // allow return statement in global scope
	    globalReturn: false,

	    // allow experimental object rest/spread
	    experimentalObjectRestSpread: false
	};


/***/ },
/* 191 */
/***/ function(module, exports) {

	/**
	 * @fileoverview The list of XHTML entities that are valid in JSX.
	 * @author Nicholas C. Zakas
	 * @copyright 2014 Nicholas C. Zakas. All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 * * Redistributions of source code must retain the above copyright
	 *   notice, this list of conditions and the following disclaimer.
	 * * Redistributions in binary form must reproduce the above copyright
	 *   notice, this list of conditions and the following disclaimer in the
	 *   documentation and/or other materials provided with the distribution.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	 * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------

	// None!

	//------------------------------------------------------------------------------
	// Public
	//------------------------------------------------------------------------------

	module.exports = {
	    quot: "\u0022",
	    amp: "&",
	    apos: "\u0027",
	    lt: "<",
	    gt: ">",
	    nbsp: "\u00A0",
	    iexcl: "\u00A1",
	    cent: "\u00A2",
	    pound: "\u00A3",
	    curren: "\u00A4",
	    yen: "\u00A5",
	    brvbar: "\u00A6",
	    sect: "\u00A7",
	    uml: "\u00A8",
	    copy: "\u00A9",
	    ordf: "\u00AA",
	    laquo: "\u00AB",
	    not: "\u00AC",
	    shy: "\u00AD",
	    reg: "\u00AE",
	    macr: "\u00AF",
	    deg: "\u00B0",
	    plusmn: "\u00B1",
	    sup2: "\u00B2",
	    sup3: "\u00B3",
	    acute: "\u00B4",
	    micro: "\u00B5",
	    para: "\u00B6",
	    middot: "\u00B7",
	    cedil: "\u00B8",
	    sup1: "\u00B9",
	    ordm: "\u00BA",
	    raquo: "\u00BB",
	    frac14: "\u00BC",
	    frac12: "\u00BD",
	    frac34: "\u00BE",
	    iquest: "\u00BF",
	    Agrave: "\u00C0",
	    Aacute: "\u00C1",
	    Acirc: "\u00C2",
	    Atilde: "\u00C3",
	    Auml: "\u00C4",
	    Aring: "\u00C5",
	    AElig: "\u00C6",
	    Ccedil: "\u00C7",
	    Egrave: "\u00C8",
	    Eacute: "\u00C9",
	    Ecirc: "\u00CA",
	    Euml: "\u00CB",
	    Igrave: "\u00CC",
	    Iacute: "\u00CD",
	    Icirc: "\u00CE",
	    Iuml: "\u00CF",
	    ETH: "\u00D0",
	    Ntilde: "\u00D1",
	    Ograve: "\u00D2",
	    Oacute: "\u00D3",
	    Ocirc: "\u00D4",
	    Otilde: "\u00D5",
	    Ouml: "\u00D6",
	    times: "\u00D7",
	    Oslash: "\u00D8",
	    Ugrave: "\u00D9",
	    Uacute: "\u00DA",
	    Ucirc: "\u00DB",
	    Uuml: "\u00DC",
	    Yacute: "\u00DD",
	    THORN: "\u00DE",
	    szlig: "\u00DF",
	    agrave: "\u00E0",
	    aacute: "\u00E1",
	    acirc: "\u00E2",
	    atilde: "\u00E3",
	    auml: "\u00E4",
	    aring: "\u00E5",
	    aelig: "\u00E6",
	    ccedil: "\u00E7",
	    egrave: "\u00E8",
	    eacute: "\u00E9",
	    ecirc: "\u00EA",
	    euml: "\u00EB",
	    igrave: "\u00EC",
	    iacute: "\u00ED",
	    icirc: "\u00EE",
	    iuml: "\u00EF",
	    eth: "\u00F0",
	    ntilde: "\u00F1",
	    ograve: "\u00F2",
	    oacute: "\u00F3",
	    ocirc: "\u00F4",
	    otilde: "\u00F5",
	    ouml: "\u00F6",
	    divide: "\u00F7",
	    oslash: "\u00F8",
	    ugrave: "\u00F9",
	    uacute: "\u00FA",
	    ucirc: "\u00FB",
	    uuml: "\u00FC",
	    yacute: "\u00FD",
	    thorn: "\u00FE",
	    yuml: "\u00FF",
	    OElig: "\u0152",
	    oelig: "\u0153",
	    Scaron: "\u0160",
	    scaron: "\u0161",
	    Yuml: "\u0178",
	    fnof: "\u0192",
	    circ: "\u02C6",
	    tilde: "\u02DC",
	    Alpha: "\u0391",
	    Beta: "\u0392",
	    Gamma: "\u0393",
	    Delta: "\u0394",
	    Epsilon: "\u0395",
	    Zeta: "\u0396",
	    Eta: "\u0397",
	    Theta: "\u0398",
	    Iota: "\u0399",
	    Kappa: "\u039A",
	    Lambda: "\u039B",
	    Mu: "\u039C",
	    Nu: "\u039D",
	    Xi: "\u039E",
	    Omicron: "\u039F",
	    Pi: "\u03A0",
	    Rho: "\u03A1",
	    Sigma: "\u03A3",
	    Tau: "\u03A4",
	    Upsilon: "\u03A5",
	    Phi: "\u03A6",
	    Chi: "\u03A7",
	    Psi: "\u03A8",
	    Omega: "\u03A9",
	    alpha: "\u03B1",
	    beta: "\u03B2",
	    gamma: "\u03B3",
	    delta: "\u03B4",
	    epsilon: "\u03B5",
	    zeta: "\u03B6",
	    eta: "\u03B7",
	    theta: "\u03B8",
	    iota: "\u03B9",
	    kappa: "\u03BA",
	    lambda: "\u03BB",
	    mu: "\u03BC",
	    nu: "\u03BD",
	    xi: "\u03BE",
	    omicron: "\u03BF",
	    pi: "\u03C0",
	    rho: "\u03C1",
	    sigmaf: "\u03C2",
	    sigma: "\u03C3",
	    tau: "\u03C4",
	    upsilon: "\u03C5",
	    phi: "\u03C6",
	    chi: "\u03C7",
	    psi: "\u03C8",
	    omega: "\u03C9",
	    thetasym: "\u03D1",
	    upsih: "\u03D2",
	    piv: "\u03D6",
	    ensp: "\u2002",
	    emsp: "\u2003",
	    thinsp: "\u2009",
	    zwnj: "\u200C",
	    zwj: "\u200D",
	    lrm: "\u200E",
	    rlm: "\u200F",
	    ndash: "\u2013",
	    mdash: "\u2014",
	    lsquo: "\u2018",
	    rsquo: "\u2019",
	    sbquo: "\u201A",
	    ldquo: "\u201C",
	    rdquo: "\u201D",
	    bdquo: "\u201E",
	    dagger: "\u2020",
	    Dagger: "\u2021",
	    bull: "\u2022",
	    hellip: "\u2026",
	    permil: "\u2030",
	    prime: "\u2032",
	    Prime: "\u2033",
	    lsaquo: "\u2039",
	    rsaquo: "\u203A",
	    oline: "\u203E",
	    frasl: "\u2044",
	    euro: "\u20AC",
	    image: "\u2111",
	    weierp: "\u2118",
	    real: "\u211C",
	    trade: "\u2122",
	    alefsym: "\u2135",
	    larr: "\u2190",
	    uarr: "\u2191",
	    rarr: "\u2192",
	    darr: "\u2193",
	    harr: "\u2194",
	    crarr: "\u21B5",
	    lArr: "\u21D0",
	    uArr: "\u21D1",
	    rArr: "\u21D2",
	    dArr: "\u21D3",
	    hArr: "\u21D4",
	    forall: "\u2200",
	    part: "\u2202",
	    exist: "\u2203",
	    empty: "\u2205",
	    nabla: "\u2207",
	    isin: "\u2208",
	    notin: "\u2209",
	    ni: "\u220B",
	    prod: "\u220F",
	    sum: "\u2211",
	    minus: "\u2212",
	    lowast: "\u2217",
	    radic: "\u221A",
	    prop: "\u221D",
	    infin: "\u221E",
	    ang: "\u2220",
	    and: "\u2227",
	    or: "\u2228",
	    cap: "\u2229",
	    cup: "\u222A",
	    "int": "\u222B",
	    there4: "\u2234",
	    sim: "\u223C",
	    cong: "\u2245",
	    asymp: "\u2248",
	    ne: "\u2260",
	    equiv: "\u2261",
	    le: "\u2264",
	    ge: "\u2265",
	    sub: "\u2282",
	    sup: "\u2283",
	    nsub: "\u2284",
	    sube: "\u2286",
	    supe: "\u2287",
	    oplus: "\u2295",
	    otimes: "\u2297",
	    perp: "\u22A5",
	    sdot: "\u22C5",
	    lceil: "\u2308",
	    rceil: "\u2309",
	    lfloor: "\u230A",
	    rfloor: "\u230B",
	    lang: "\u2329",
	    rang: "\u232A",
	    loz: "\u25CA",
	    spades: "\u2660",
	    clubs: "\u2663",
	    hearts: "\u2665",
	    diams: "\u2666"
	};


/***/ },
/* 192 */
/***/ function(module, exports) {

	/**
	 * @fileoverview A simple map that helps avoid collisions on the Object prototype.
	 * @author Jamund Ferguson
	 * @copyright 2015 Jamund Ferguson. All rights reserved.
	 * @copyright 2011-2013 Ariya Hidayat <ariya.hidayat@gmail.com>
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 * * Redistributions of source code must retain the above copyright
	 *   notice, this list of conditions and the following disclaimer.
	 * * Redistributions in binary form must reproduce the above copyright
	 *   notice, this list of conditions and the following disclaimer in the
	 *   documentation and/or other materials provided with the distribution.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	 * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */

	"use strict";

	function StringMap() {
	    this.$data = {};
	}

	StringMap.prototype.get = function (key) {
	    key = "$" + key;
	    return this.$data[key];
	};

	StringMap.prototype.set = function (key, value) {
	    key = "$" + key;
	    this.$data[key] = value;
	    return this;
	};

	StringMap.prototype.has = function (key) {
	    key = "$" + key;
	    return Object.prototype.hasOwnProperty.call(this.$data, key);
	};

	StringMap.prototype.delete = function (key) {
	    key = "$" + key;
	    return delete this.$data[key];
	};

	module.exports = StringMap;


/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Attaches comments to the AST.
	 * @author Nicholas C. Zakas
	 * @copyright 2015 Nicholas C. Zakas. All rights reserved.
	 * @copyright 2011-2013 Ariya Hidayat <ariya.hidayat@gmail.com>
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 * * Redistributions of source code must retain the above copyright
	 *   notice, this list of conditions and the following disclaimer.
	 * * Redistributions in binary form must reproduce the above copyright
	 *   notice, this list of conditions and the following disclaimer in the
	 *   documentation and/or other materials provided with the distribution.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	 * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------

	var astNodeTypes = __webpack_require__(188);

	//------------------------------------------------------------------------------
	// Private
	//------------------------------------------------------------------------------

	var extra = {
	        trailingComments: [],
	        leadingComments: [],
	        bottomRightStack: []
	    };

	//------------------------------------------------------------------------------
	// Public
	//------------------------------------------------------------------------------

	module.exports = {

	    reset: function() {
	        extra.trailingComments = [];
	        extra.leadingComments = [];
	        extra.bottomRightStack = [];
	    },

	    addComment: function(comment) {
	        extra.trailingComments.push(comment);
	        extra.leadingComments.push(comment);
	    },

	    processComment: function(node) {
	        var lastChild,
	            trailingComments,
	            i;

	        if (node.type === astNodeTypes.Program) {
	            if (node.body.length > 0) {
	                return;
	            }
	        }

	        if (extra.trailingComments.length > 0) {

	            /*
	             * If the first comment in trailingComments comes after the
	             * current node, then we're good - all comments in the array will
	             * come after the node and so it's safe to add then as official
	             * trailingComments.
	             */
	            if (extra.trailingComments[0].range[0] >= node.range[1]) {
	                trailingComments = extra.trailingComments;
	                extra.trailingComments = [];
	            } else {

	                /*
	                 * Otherwise, if the first comment doesn't come after the
	                 * current node, that means we have a mix of leading and trailing
	                 * comments in the array and that leadingComments contains the
	                 * same items as trailingComments. Reset trailingComments to
	                 * zero items and we'll handle this by evaluating leadingComments
	                 * later.
	                 */
	                extra.trailingComments.length = 0;
	            }
	        } else {
	            if (extra.bottomRightStack.length > 0 &&
	                    extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments &&
	                    extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments[0].range[0] >= node.range[1]) {
	                trailingComments = extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments;
	                delete extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments;
	            }
	        }

	        // Eating the stack.
	        while (extra.bottomRightStack.length > 0 && extra.bottomRightStack[extra.bottomRightStack.length - 1].range[0] >= node.range[0]) {
	            lastChild = extra.bottomRightStack.pop();
	        }

	        if (lastChild) {
	            if (lastChild.leadingComments) {
	                if (lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= node.range[0]) {
	                    node.leadingComments = lastChild.leadingComments;
	                    delete lastChild.leadingComments;
	                } else {
	                    // A leading comment for an anonymous class had been stolen by its first MethodDefinition,
	                    // so this takes back the leading comment.
	                    // See Also: https://github.com/eslint/espree/issues/158
	                    for (i = lastChild.leadingComments.length - 2; i >= 0; --i) {
	                        if (lastChild.leadingComments[i].range[1] <= node.range[0]) {
	                            node.leadingComments = lastChild.leadingComments.splice(0, i + 1);
	                            break;
	                        }
	                    }
	                }
	            }
	        } else if (extra.leadingComments.length > 0) {

	            if (extra.leadingComments[extra.leadingComments.length - 1].range[1] <= node.range[0]) {
	                node.leadingComments = extra.leadingComments;
	                extra.leadingComments = [];
	            } else {

	                // https://github.com/eslint/espree/issues/2

	                /*
	                 * In special cases, such as return (without a value) and
	                 * debugger, all comments will end up as leadingComments and
	                 * will otherwise be eliminated. This extra step runs when the
	                 * bottomRightStack is empty and there are comments left
	                 * in leadingComments.
	                 *
	                 * This loop figures out the stopping point between the actual
	                 * leading and trailing comments by finding the location of the
	                 * first comment that comes after the given node.
	                 */
	                for (i = 0; i < extra.leadingComments.length; i++) {
	                    if (extra.leadingComments[i].range[1] > node.range[0]) {
	                        break;
	                    }
	                }

	                /*
	                 * Split the array based on the location of the first comment
	                 * that comes after the node. Keep in mind that this could
	                 * result in an empty array, and if so, the array must be
	                 * deleted.
	                 */
	                node.leadingComments = extra.leadingComments.slice(0, i);
	                if (node.leadingComments.length === 0) {
	                    delete node.leadingComments;
	                }

	                /*
	                 * Similarly, trailing comments are attached later. The variable
	                 * must be reset to null if there are no trailing comments.
	                 */
	                trailingComments = extra.leadingComments.slice(i);
	                if (trailingComments.length === 0) {
	                    trailingComments = null;
	                }
	            }
	        }

	        if (trailingComments) {
	            node.trailingComments = trailingComments;
	        }

	        extra.bottomRightStack.push(node);
	    }

	};


/***/ },
/* 194 */
/***/ function(module, exports) {

	module.exports = {
		"name": "espree",
		"description": "An actively-maintained fork of Esprima, the ECMAScript parsing infrastructure for multipurpose analysis",
		"author": {
			"name": "Nicholas C. Zakas",
			"email": "nicholas+npm@nczconsulting.com"
		},
		"homepage": "https://github.com/eslint/espree",
		"main": "espree.js",
		"bin": {
			"esparse": "./bin/esparse.js",
			"esvalidate": "./bin/esvalidate.js"
		},
		"version": "2.2.3",
		"files": [
			"bin",
			"lib",
			"test/run.js",
			"test/runner.js",
			"test/test.js",
			"test/compat.js",
			"test/reflect.js",
			"espree.js"
		],
		"engines": {
			"node": ">=0.10.0"
		},
		"repository": {
			"type": "git",
			"url": "git+ssh://git@github.com/eslint/espree.git"
		},
		"bugs": {
			"url": "http://github.com/eslint/espree.git"
		},
		"licenses": [
			{
				"type": "BSD",
				"url": "http://github.com/nzakas/espree/raw/master/LICENSE"
			}
		],
		"devDependencies": {
			"browserify": "^7.0.0",
			"chai": "^1.10.0",
			"complexity-report": "~0.6.1",
			"dateformat": "^1.0.11",
			"eslint": "^0.9.2",
			"esprima": "git://github.com/jquery/esprima.git",
			"esprima-fb": "^8001.2001.0-dev-harmony-fb",
			"istanbul": "~0.2.6",
			"json-diff": "~0.3.1",
			"leche": "^1.0.1",
			"mocha": "^2.0.1",
			"npm-license": "^0.2.3",
			"optimist": "~0.6.0",
			"regenerate": "~0.5.4",
			"semver": "^4.1.1",
			"shelljs": "^0.3.0",
			"shelljs-nodecli": "^0.1.1",
			"unicode-6.3.0": "~0.1.0"
		},
		"keywords": [
			"ast",
			"ecmascript",
			"javascript",
			"parser",
			"syntax"
		],
		"scripts": {
			"generate-regex": "node tools/generate-identifier-regex.js",
			"test": "npm run-script lint && node Makefile.js test && node test/run.js",
			"lint": "node Makefile.js lint",
			"patch": "node Makefile.js patch",
			"minor": "node Makefile.js minor",
			"major": "node Makefile.js major",
			"browserify": "node Makefile.js browserify",
			"coverage": "npm run-script analyze-coverage && npm run-script check-coverage",
			"analyze-coverage": "node node_modules/istanbul/lib/cli.js cover test/runner.js",
			"check-coverage": "node node_modules/istanbul/lib/cli.js check-coverage --statement 99 --branch 99 --function 99",
			"complexity": "npm run-script analyze-complexity && npm run-script check-complexity",
			"analyze-complexity": "node tools/list-complexity.js",
			"check-complexity": "node node_modules/complexity-report/src/cli.js --maxcc 14 --silent -l -w espree.js",
			"benchmark": "node test/benchmarks.js",
			"benchmark-quick": "node test/benchmarks.js quick"
		},
		"dependencies": {},
		"gitHead": "4e72bb00332dbbced9a77d7c281962a46a6759cc",
		"_id": "espree@2.2.3",
		"_shasum": "158cfc10f6e57c6bbc5a7438eb8bc40f267f9b54",
		"_from": "espree@>=2.2.0 <3.0.0",
		"_npmVersion": "1.4.28",
		"_npmUser": {
			"name": "nzakas",
			"email": "nicholas@nczconsulting.com"
		},
		"maintainers": [
			{
				"name": "nzakas",
				"email": "nicholas@nczconsulting.com"
			}
		],
		"dist": {
			"shasum": "158cfc10f6e57c6bbc5a7438eb8bc40f267f9b54",
			"tarball": "http://registry.npmjs.org/espree/-/espree-2.2.3.tgz"
		},
		"directories": {},
		"_resolved": "https://registry.npmjs.org/espree/-/espree-2.2.3.tgz",
		"readme": "ERROR: No README data found!"
	}

/***/ },
/* 195 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to disalow whitespace that is not a tab or space, whitespace inside strings and comments are allowed
	 * @author Jonathan Kingston
	 * @copyright 2014 Jonathan Kingston. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var irregularWhitespace = /[\u0085\u00A0\ufeff\f\v\u00a0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u202f\u205f\u3000]+/mg,
	        irregularLineTerminators = /[\u2028\u2029]/mg;

	    // Module store of errors that we have found
	    var errors = [];

	    /**
	     * Removes errors that occur inside a string node
	     * @param {ASTNode} node to check for matching errors.
	     * @returns {void}
	     * @private
	     */
	    function removeStringError(node) {
	        var locStart = node.loc.start;
	        var locEnd = node.loc.end;

	        errors = errors.filter(function(error) {
	            var errorLoc = error[1];
	            if (errorLoc.line >= locStart.line && errorLoc.line <= locEnd.line) {
	                if (errorLoc.column >= locStart.column && (errorLoc.column <= locEnd.column || errorLoc.line < locEnd.line)) {
	                    return false;
	                }
	            }
	            return true;
	        });
	    }

	    /**
	     * Checks nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors
	     * @param {ASTNode} node to check for matching errors.
	     * @returns {void}
	     * @private
	     */
	    function removeInvalidNodeErrors(node) {
	        if (typeof node.value === "string") {
	            // If we have irregular characters remove them from the errors list
	            if (node.raw.match(irregularWhitespace) || node.raw.match(irregularLineTerminators)) {
	                removeStringError(node);
	            }
	        }
	    }

	    /**
	     * Checks the program source for irregular whitespace
	     * @param {ASTNode} node The program node
	     * @returns {void}
	     * @private
	     */
	    function checkForIrregularWhitespace(node) {
	        var sourceLines = context.getSourceLines();

	        sourceLines.forEach(function(sourceLine, lineIndex) {
	            var lineNumber = lineIndex + 1,
	                location,
	                match;

	            while ((match = irregularWhitespace.exec(sourceLine)) !== null) {
	                location = {
	                    line: lineNumber,
	                    column: match.index
	                };

	                errors.push([node, location, "Irregular whitespace not allowed"]);
	            }
	        });
	    }

	    /**
	     * Checks the program source for irregular line terminators
	     * @param {ASTNode} node The program node
	     * @returns {void}
	     * @private
	     */
	    function checkForIrregularLineTerminators(node) {
	        var source = context.getSource(),
	            sourceLines = context.getSourceLines(),
	            linebreaks = source.match(/\r\n|\r|\n|\u2028|\u2029/g),
	            lastLineIndex = -1,
	            lineIndex,
	            location,
	            match;

	        while ((match = irregularLineTerminators.exec(source)) !== null) {
	            lineIndex = linebreaks.indexOf(match[0], lastLineIndex + 1) || 0;

	            location = {
	                line: lineIndex + 1,
	                column: sourceLines[lineIndex].length
	            };

	            errors.push([node, location, "Irregular whitespace not allowed"]);
	            lastLineIndex = lineIndex;
	        }
	    }

	    return {
	        "Program": function(node) {
	            /**
	             * As we can easily fire warnings for all white space issues with all the source its simpler to fire them here
	             * This means we can check all the application code without having to worry about issues caused in the parser tokens
	             * When writing this code also evaluating per node was missing out connecting tokens in some cases
	             * We can later filter the errors when they are found to be not an issue in nodes we don't care about
	             */

	            checkForIrregularWhitespace(node);
	            checkForIrregularLineTerminators(node);
	        },

	        "Identifier": removeInvalidNodeErrors,
	        "Literal": removeInvalidNodeErrors,
	        "Program:exit": function() {

	            // If we have any errors remaining report on them
	            errors.forEach(function(error) {
	                context.report.apply(context, error);
	            });
	        }
	    };
	};

	module.exports.schema = [];


/***/ },
/* 196 */
/***/ function(module, exports) {

	/**
	 * @fileoverview A rule to disallow negated left operands of the `in` operator
	 * @author Michael Ficarra
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {

	        "BinaryExpression": function(node) {
	            if (node.operator === "in" && node.left.type === "UnaryExpression" && node.left.operator === "!") {
	                context.report(node, "The `in` expression's left operand is negated");
	            }
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 197 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag use of an object property of the global object (Math and JSON) as a function
	 * @author James Allardice
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {
	        "CallExpression": function(node) {

	            if (node.callee.type === "Identifier") {
	                var name = node.callee.name;
	                if (name === "Math" || name === "JSON") {
	                    context.report(node, "'{{name}}' is not a function.", { name: name });
	                }
	            }
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 198 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to count multiple spaces in regular expressions
	 * @author Matt DuVall <http://www.mattduvall.com/>
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {

	        "Literal": function(node) {
	            var token = context.getFirstToken(node),
	                nodeType = token.type,
	                nodeValue = token.value,
	                multipleSpacesRegex = /( {2,})+?/,
	                regexResults;

	            if (nodeType === "RegularExpression") {
	                regexResults = multipleSpacesRegex.exec(nodeValue);

	                if (regexResults !== null) {
	                    context.report(node, "Spaces are hard to count. Use {" + regexResults[0].length + "}.");
	                }
	            }
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 199 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Disallow sparse arrays
	 * @author Nicholas C. Zakas
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {


	    //--------------------------------------------------------------------------
	    // Public
	    //--------------------------------------------------------------------------

	    return {

	        "ArrayExpression": function(node) {

	            var emptySpot = node.elements.indexOf(null) > -1;

	            if (emptySpot) {
	                context.report(node, "Unexpected comma in middle of array.");
	            }
	        }

	    };

	};

	module.exports.schema = [];


/***/ },
/* 200 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Checks for unreachable code due to return, throws, break, and continue.
	 * @author Joel Feenstra
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------


	function report(context, node, unreachableType) {
	    var keyword;
	    switch (unreachableType) {
	        case "BreakStatement":
	            keyword = "break";
	            break;
	        case "ContinueStatement":
	            keyword = "continue";
	            break;
	        case "ReturnStatement":
	            keyword = "return";
	            break;
	        case "ThrowStatement":
	            keyword = "throw";
	            break;
	        default:
	            return;
	    }
	    context.report(node, "Found unexpected statement after a {{type}}.", { type: keyword });
	}


	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    /**
	     * Checks if a node is an exception for no-unreachable because of variable/function hoisting
	     * @param {ASTNode} node The AST node to check.
	     * @returns {boolean} if the node doesn't trigger unreachable
	     * @private
	     */
	    function isUnreachableAllowed(node) {
	        return node.type === "FunctionDeclaration" ||
	            node.type === "VariableDeclaration" &&
	            node.declarations.every(function(declaration) {
	                return declaration.type === "VariableDeclarator" && declaration.init === null;
	            });
	    }

	    /*
	     * Verifies that the given node is the last node or followed exclusively by
	     * hoisted declarations
	     * @param {ASTNode} node Node that should be the last node
	     * @returns {void}
	     * @private
	     */
	    function checkNode(node) {
	        var parent = context.getAncestors().pop();
	        var field, i, sibling;

	        switch (parent.type) {
	            case "SwitchCase":
	                field = "consequent";
	                break;
	            case "Program":
	            case "BlockStatement":
	                field = "body";
	                break;
	            default:
	                return;
	        }

	        for (i = parent[field].length - 1; i >= 0; i--) {
	            sibling = parent[field][i];
	            if (sibling === node) {
	                return; // Found the last reachable statement, all done
	            }

	            if (!isUnreachableAllowed(sibling)) {
	                report(context, sibling, node.type);
	            }
	        }
	    }

	    return {
	        "ReturnStatement": checkNode,
	        "ThrowStatement": checkNode,
	        "ContinueStatement": checkNode,
	        "BreakStatement": checkNode
	    };

	};

	module.exports.schema = [];


/***/ },
/* 201 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag comparisons to the value NaN
	 * @author James Allardice
	 * @copyright 2014 Jordan Harband. All rights reserved.
	 * @copyright 2013 James Allardice. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {
	        "BinaryExpression": function(node) {
	            if (/^(?:[<>]|[!=]=)=?$/.test(node.operator) && (node.left.name === "NaN" || node.right.name === "NaN")) {
	                context.report(node, "Use the isNaN function to compare with NaN.");
	            }
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Validates JSDoc comments are syntactically correct
	 * @author Nicholas C. Zakas
	 * @copyright 2014 Nicholas C. Zakas. All rights reserved.
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------

	var doctrine = __webpack_require__(203);

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var options = context.options[0] || {},
	        prefer = options.prefer || {},

	        // these both default to true, so you have to explicitly make them false
	        requireReturn = options.requireReturn !== false,
	        requireParamDescription = options.requireParamDescription !== false,
	        requireReturnDescription = options.requireReturnDescription !== false;

	    //--------------------------------------------------------------------------
	    // Helpers
	    //--------------------------------------------------------------------------

	    // Using a stack to store if a function returns or not (handling nested functions)
	    var fns = [];

	    /**
	     * When parsing a new function, store it in our function stack.
	     * @param {ASTNode} node A function node to check.
	     * @returns {void}
	     * @private
	     */
	    function startFunction(node) {
	        fns.push({
	            returnPresent: (node.type === "ArrowFunctionExpression" && node.body.type !== "BlockStatement")
	        });
	    }

	    /**
	     * Indicate that return has been found in the current function.
	     * @param {ASTNode} node The return node.
	     * @returns {void}
	     * @private
	     */
	    function addReturn(node) {
	        var functionState = fns[fns.length - 1];

	        if (functionState && node.argument !== null) {
	            functionState.returnPresent = true;
	        }
	    }

	    /**
	     * Validate the JSDoc node and output warnings if anything is wrong.
	     * @param {ASTNode} node The AST node to check.
	     * @returns {void}
	     * @private
	     */
	    function checkJSDoc(node) {
	        var jsdocNode = context.getJSDocComment(node),
	            functionData = fns.pop(),
	            hasReturns = false,
	            hasConstructor = false,
	            params = Object.create(null),
	            jsdoc;

	        // make sure only to validate JSDoc comments
	        if (jsdocNode) {

	            try {
	                jsdoc = doctrine.parse(jsdocNode.value, {
	                    strict: true,
	                    unwrap: true,
	                    sloppy: true
	                });
	            } catch (ex) {

	                if (/braces/i.test(ex.message)) {
	                    context.report(jsdocNode, "JSDoc type missing brace.");
	                } else {
	                    context.report(jsdocNode, "JSDoc syntax error.");
	                }

	                return;
	            }

	            jsdoc.tags.forEach(function(tag) {

	                switch (tag.title) {

	                    case "param":
	                        if (!tag.type) {
	                            context.report(jsdocNode, "Missing JSDoc parameter type for '{{name}}'.", { name: tag.name });
	                        }

	                        if (!tag.description && requireParamDescription) {
	                            context.report(jsdocNode, "Missing JSDoc parameter description for '{{name}}'.", { name: tag.name });
	                        }

	                        if (params[tag.name]) {
	                            context.report(jsdocNode, "Duplicate JSDoc parameter '{{name}}'.", { name: tag.name });
	                        } else if (tag.name.indexOf(".") === -1) {
	                            params[tag.name] = 1;
	                        }
	                        break;

	                    case "return":
	                    case "returns":
	                        hasReturns = true;

	                        if (!requireReturn && !functionData.returnPresent && tag.type.name !== "void" && tag.type.name !== "undefined") {
	                            context.report(jsdocNode, "Unexpected @" + tag.title + " tag; function has no return statement.");
	                        } else {
	                            if (!tag.type) {
	                                context.report(jsdocNode, "Missing JSDoc return type.");
	                            }

	                            if (tag.type.name !== "void" && !tag.description && requireReturnDescription) {
	                                context.report(jsdocNode, "Missing JSDoc return description.");
	                            }
	                        }

	                        break;

	                    case "constructor":
	                    case "class":
	                        hasConstructor = true;
	                        break;

	                    // no default
	                }

	                // check tag preferences
	                if (prefer.hasOwnProperty(tag.title)) {
	                    context.report(jsdocNode, "Use @{{name}} instead.", { name: prefer[tag.title] });
	                }

	            });

	            // check for functions missing @returns
	            if (!hasReturns && !hasConstructor && node.parent.kind !== "get") {
	                if (requireReturn || functionData.returnPresent) {
	                    context.report(jsdocNode, "Missing JSDoc @returns for function.");
	                }
	            }

	            // check the parameters
	            var jsdocParams = Object.keys(params);

	            node.params.forEach(function(param, i) {
	                var name = param.name;

	                // TODO(nzakas): Figure out logical things to do with destructured, default, rest params
	                if (param.type === "Identifier") {
	                    if (jsdocParams[i] && (name !== jsdocParams[i])) {
	                        context.report(jsdocNode, "Expected JSDoc for '{{name}}' but found '{{jsdocName}}'.", {
	                            name: name,
	                            jsdocName: jsdocParams[i]
	                        });
	                    } else if (!params[name]) {
	                        context.report(jsdocNode, "Missing JSDoc for parameter '{{name}}'.", {
	                            name: name
	                        });
	                    }
	                }
	            });

	        }

	    }

	    //--------------------------------------------------------------------------
	    // Public
	    //--------------------------------------------------------------------------

	    return {
	        "ArrowFunctionExpression": startFunction,
	        "FunctionExpression": startFunction,
	        "FunctionDeclaration": startFunction,
	        "ArrowFunctionExpression:exit": checkJSDoc,
	        "FunctionExpression:exit": checkJSDoc,
	        "FunctionDeclaration:exit": checkJSDoc,
	        "ReturnStatement": addReturn
	    };

	};

	module.exports.schema = [
	    {
	        "type": "object",
	        "properties": {
	            "prefer": {
	                "type": "object",
	                "additionalProperties": {
	                    "type": "string"
	                }
	            },
	            "requireReturn": {
	                "type": "boolean"
	            },
	            "requireParamDescription": {
	                "type": "boolean"
	            },
	            "requireReturnDescription": {
	                "type": "boolean"
	            }
	        },
	        "additionalProperties": false
	    }
	];


/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	/*
	  Copyright (C) 2012-2014 Yusuke Suzuki <utatane.tea@gmail.com>
	  Copyright (C) 2014 Dan Tao <daniel.tao@gmail.com>
	  Copyright (C) 2013 Andrew Eisenberg <andrew@eisenberg.as>

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	(function () {
	    'use strict';

	    var typed,
	        utility,
	        isArray,
	        jsdoc,
	        esutils,
	        hasOwnProperty;

	    esutils = __webpack_require__(204);
	    isArray = __webpack_require__(208);
	    typed = __webpack_require__(209);
	    utility = __webpack_require__(210);

	    function sliceSource(source, index, last) {
	        return source.slice(index, last);
	    }

	    hasOwnProperty = (function () {
	        var func = Object.prototype.hasOwnProperty;
	        return function hasOwnProperty(obj, name) {
	            return func.call(obj, name);
	        };
	    }());

	    function shallowCopy(obj) {
	        var ret = {}, key;
	        for (key in obj) {
	            if (obj.hasOwnProperty(key)) {
	                ret[key] = obj[key];
	            }
	        }
	        return ret;
	    }

	    function isASCIIAlphanumeric(ch) {
	        return (ch >= 0x61  /* 'a' */ && ch <= 0x7A  /* 'z' */) ||
	            (ch >= 0x41  /* 'A' */ && ch <= 0x5A  /* 'Z' */) ||
	            (ch >= 0x30  /* '0' */ && ch <= 0x39  /* '9' */);
	    }

	    function isParamTitle(title) {
	        return title === 'param' || title === 'argument' || title === 'arg';
	    }

	    function isProperty(title) {
	        return title === 'property' || title === 'prop';
	    }

	    function isNameParameterRequired(title) {
	        return isParamTitle(title) || isProperty(title) ||
	            title === 'alias' || title === 'this' || title === 'mixes' || title === 'requires';
	    }

	    function isAllowedName(title) {
	        return isNameParameterRequired(title) || title === 'const' || title === 'constant';
	    }

	    function isAllowedNested(title) {
	        return isProperty(title) || isParamTitle(title);
	    }

	    function isTypeParameterRequired(title) {
	        return isParamTitle(title) || title === 'define' || title === 'enum' ||
	            title === 'implements' || title === 'return' ||
	            title === 'this' || title === 'type' || title === 'typedef' ||
	            title === 'returns' || isProperty(title);
	    }

	    // Consider deprecation instead using 'isTypeParameterRequired' and 'Rules' declaration to pick when a type is optional/required
	    // This would require changes to 'parseType'
	    function isAllowedType(title) {
	        return isTypeParameterRequired(title) || title === 'throws' || title === 'const' || title === 'constant' ||
	            title === 'namespace' || title === 'member' || title === 'var' || title === 'module' ||
	            title === 'constructor' || title === 'class' || title === 'extends' || title === 'augments' ||
	            title === 'public' || title === 'private' || title === 'protected';
	    }

	    function trim(str) {
	        return str.replace(/^\s+/, '').replace(/\s+$/, '');
	    }

	    function unwrapComment(doc) {
	        // JSDoc comment is following form
	        //   /**
	        //    * .......
	        //    */
	        // remove /**, */ and *
	        var BEFORE_STAR = 0,
	            STAR = 1,
	            AFTER_STAR = 2,
	            index,
	            len,
	            mode,
	            result,
	            ch;

	        doc = doc.replace(/^\/\*\*?/, '').replace(/\*\/$/, '');
	        index = 0;
	        len = doc.length;
	        mode = BEFORE_STAR;
	        result = '';

	        while (index < len) {
	            ch = doc.charCodeAt(index);
	            switch (mode) {
	            case BEFORE_STAR:
	                if (esutils.code.isLineTerminator(ch)) {
	                    result += String.fromCharCode(ch);
	                } else if (ch === 0x2A  /* '*' */) {
	                    mode = STAR;
	                } else if (!esutils.code.isWhiteSpace(ch)) {
	                    result += String.fromCharCode(ch);
	                    mode = AFTER_STAR;
	                }
	                break;

	            case STAR:
	                if (!esutils.code.isWhiteSpace(ch)) {
	                    result += String.fromCharCode(ch);
	                }
	                mode = esutils.code.isLineTerminator(ch) ? BEFORE_STAR : AFTER_STAR;
	                break;

	            case AFTER_STAR:
	                result += String.fromCharCode(ch);
	                if (esutils.code.isLineTerminator(ch)) {
	                    mode = BEFORE_STAR;
	                }
	                break;
	            }
	            index += 1;
	        }

	        return result;
	    }

	    // JSDoc Tag Parser

	    (function (exports) {
	        var Rules,
	            index,
	            lineNumber,
	            length,
	            source,
	            recoverable,
	            sloppy,
	            strict;

	        function advance() {
	            var ch = source.charCodeAt(index);
	            index += 1;
	            if (esutils.code.isLineTerminator(ch) && !(ch === 0x0D  /* '\r' */ && source.charCodeAt(index) === 0x0A  /* '\n' */)) {
	                lineNumber += 1;
	            }
	            return String.fromCharCode(ch);
	        }

	        function scanTitle() {
	            var title = '';
	            // waste '@'
	            advance();

	            while (index < length && isASCIIAlphanumeric(source.charCodeAt(index))) {
	                title += advance();
	            }

	            return title;
	        }

	        function seekContent() {
	            var ch, waiting, last = index;

	            waiting = false;
	            while (last < length) {
	                ch = source.charCodeAt(last);
	                if (esutils.code.isLineTerminator(ch) && !(ch === 0x0D  /* '\r' */ && source.charCodeAt(last + 1) === 0x0A  /* '\n' */)) {
	                    lineNumber += 1;
	                    waiting = true;
	                } else if (waiting) {
	                    if (ch === 0x40  /* '@' */) {
	                        break;
	                    }
	                    if (!esutils.code.isWhiteSpace(ch)) {
	                        waiting = false;
	                    }
	                }
	                last += 1;
	            }
	            return last;
	        }

	        // type expression may have nest brace, such as,
	        // { { ok: string } }
	        //
	        // therefore, scanning type expression with balancing braces.
	        function parseType(title, last) {
	            var ch, brace, type, direct = false;


	            // search '{'
	            while (index < last) {
	                ch = source.charCodeAt(index);
	                if (esutils.code.isWhiteSpace(ch)) {
	                    advance();
	                } else if (ch === 0x7B  /* '{' */) {
	                    advance();
	                    break;
	                } else {
	                    // this is direct pattern
	                    direct = true;
	                    break;
	                }
	            }


	            if (direct) {
	                return null;
	            }

	            // type expression { is found
	            brace = 1;
	            type = '';
	            while (index < last) {
	                ch = source.charCodeAt(index);
	                if (esutils.code.isLineTerminator(ch)) {
	                    advance();
	                } else {
	                    if (ch === 0x7D  /* '}' */) {
	                        brace -= 1;
	                        if (brace === 0) {
	                            advance();
	                            break;
	                        }
	                    } else if (ch === 0x7B  /* '{' */) {
	                        brace += 1;
	                    }
	                    type += advance();
	                }
	            }

	            if (brace !== 0) {
	                // braces is not balanced
	                return utility.throwError('Braces are not balanced');
	            }

	            if (isParamTitle(title)) {
	                return typed.parseParamType(type);
	            }
	            return typed.parseType(type);
	        }

	        function scanIdentifier(last) {
	            var identifier;
	            if (!esutils.code.isIdentifierStart(source.charCodeAt(index))) {
	                return null;
	            }
	            identifier = advance();
	            while (index < last && esutils.code.isIdentifierPart(source.charCodeAt(index))) {
	                identifier += advance();
	            }
	            return identifier;
	        }

	        function skipWhiteSpace(last) {
	            while (index < last && (esutils.code.isWhiteSpace(source.charCodeAt(index)) || esutils.code.isLineTerminator(source.charCodeAt(index)))) {
	                advance();
	            }
	        }

	        function parseName(last, allowBrackets, allowNestedParams) {
	            var name = '', useBrackets;

	            skipWhiteSpace(last);

	            if (index >= last) {
	                return null;
	            }

	            if (allowBrackets && source.charCodeAt(index) === 0x5B  /* '[' */) {
	                useBrackets = true;
	                name = advance();
	            }

	            if (!esutils.code.isIdentifierStart(source.charCodeAt(index))) {
	                return null;
	            }

	            name += scanIdentifier(last);

	            if (allowNestedParams) {
	                if (source.charCodeAt(index) === 0x3A /* ':' */ && (
	                        name === 'module' ||
	                        name === 'external' ||
	                        name === 'event')) {
	                    name += advance();
	                    name += scanIdentifier(last);

	                }
	                while (source.charCodeAt(index) === 0x2E  /* '.' */ ||
	                        source.charCodeAt(index) === 0x23  /* '#' */ ||
	                        source.charCodeAt(index) === 0x7E  /* '~' */) {
	                    name += advance();
	                    name += scanIdentifier(last);
	                }
	            }

	            if (useBrackets) {
	                // do we have a default value for this?
	                if (source.charCodeAt(index) === 0x3D  /* '=' */) {

	                    // consume the '='' symbol
	                    name += advance();
	                    // scan in the default value
	                    while (index < last && source.charCodeAt(index) !== 0x5D  /* ']' */) {
	                        name += advance();
	                    }
	                }

	                if (index >= last  || source.charCodeAt(index) !== 0x5D  /* ']' */) {
	                    // we never found a closing ']'
	                    return null;
	                }

	                // collect the last ']'
	                name += advance();
	            }

	            return name;
	        }

	        function skipToTag() {
	            while (index < length && source.charCodeAt(index) !== 0x40  /* '@' */) {
	                advance();
	            }
	            if (index >= length) {
	                return false;
	            }
	            utility.assert(source.charCodeAt(index) === 0x40  /* '@' */);
	            return true;
	        }

	        function TagParser(options, title) {
	            this._options = options;
	            this._title = title;
	            this._tag = {
	                title: title,
	                description: null
	            };
	            if (this._options.lineNumbers) {
	                this._tag.lineNumber = lineNumber;
	            }
	            this._last = 0;
	            // space to save special information for title parsers.
	            this._extra = { };
	        }

	        // addError(err, ...)
	        TagParser.prototype.addError = function addError(errorText) {
	            var args = Array.prototype.slice.call(arguments, 1),
	                msg = errorText.replace(
	                    /%(\d)/g,
	                    function (whole, index) {
	                        utility.assert(index < args.length, 'Message reference must be in range');
	                        return args[index];
	                    }
	                );

	            if (!this._tag.errors) {
	                this._tag.errors = [];
	            }
	            if (strict) {
	                utility.throwError(msg);
	            }
	            this._tag.errors.push(msg);
	            return recoverable;
	        };

	        TagParser.prototype.parseType = function () {
	            // type required titles
	            if (isTypeParameterRequired(this._title)) {
	                try {
	                    this._tag.type = parseType(this._title, this._last);
	                    if (!this._tag.type) {
	                        if (!isParamTitle(this._title)) {
	                            if (!this.addError('Missing or invalid tag type')) {
	                                return false;
	                            }
	                        }
	                    }
	                } catch (error) {
	                    this._tag.type = null;
	                    if (!this.addError(error.message)) {
	                        return false;
	                    }
	                }
	            } else if (isAllowedType(this._title)) {
	                // optional types
	                try {
	                    this._tag.type = parseType(this._title, this._last);
	                } catch (e) {
	                    //For optional types, lets drop the thrown error when we hit the end of the file
	                }
	            }
	            return true;
	        };

	        TagParser.prototype._parseNamePath = function (optional) {
	            var name;
	            name = parseName(this._last, sloppy && isParamTitle(this._title), true);
	            if (!name) {
	                if (!optional) {
	                    if (!this.addError('Missing or invalid tag name')) {
	                        return false;
	                    }
	                }
	            }
	            this._tag.name = name;
	            return true;
	        };

	        TagParser.prototype.parseNamePath = function () {
	            return this._parseNamePath(false);
	        };

	        TagParser.prototype.parseNamePathOptional = function () {
	            return this._parseNamePath(true);
	        };


	        TagParser.prototype.parseName = function () {
	            var assign, name;

	            // param, property requires name
	            if (isAllowedName(this._title)) {
	                this._tag.name = parseName(this._last, sloppy && isParamTitle(this._title), isAllowedNested(this._title));
	                if (!this._tag.name) {
	                    if (!isNameParameterRequired(this._title)) {
	                        return true;
	                    }

	                    // it's possible the name has already been parsed but interpreted as a type
	                    // it's also possible this is a sloppy declaration, in which case it will be
	                    // fixed at the end
	                    if (isParamTitle(this._title) && this._tag.type && this._tag.type.name) {
	                        this._extra.name = this._tag.type;
	                        this._tag.name = this._tag.type.name;
	                        this._tag.type = null;
	                    } else {
	                        if (!this.addError('Missing or invalid tag name')) {
	                            return false;
	                        }
	                    }
	                } else {
	                    name = this._tag.name;
	                    if (name.charAt(0) === '[' && name.charAt(name.length - 1) === ']') {
	                        // extract the default value if there is one
	                        // example: @param {string} [somebody=John Doe] description
	                        assign = name.substring(1, name.length - 1).split('=');
	                        if (assign[1]) {
	                            this._tag['default'] = assign[1];
	                        }
	                        this._tag.name = assign[0];

	                        // convert to an optional type
	                        if (this._tag.type && this._tag.type.type !== 'OptionalType') {
	                            this._tag.type = {
	                                type: 'OptionalType',
	                                expression: this._tag.type
	                            };
	                        }
	                    }
	                }
	            }

	            return true;
	        };

	        TagParser.prototype.parseDescription = function parseDescription() {
	            var description = trim(sliceSource(source, index, this._last));
	            if (description) {
	                if ((/^-\s+/).test(description)) {
	                    description = description.substring(2);
	                }
	                this._tag.description = description;
	            }
	            return true;
	        };

	        TagParser.prototype.parseKind = function parseKind() {
	            var kind, kinds;
	            kinds = {
	                'class': true,
	                'constant': true,
	                'event': true,
	                'external': true,
	                'file': true,
	                'function': true,
	                'member': true,
	                'mixin': true,
	                'module': true,
	                'namespace': true,
	                'typedef': true
	            };
	            kind = trim(sliceSource(source, index, this._last));
	            this._tag.kind = kind;
	            if (!hasOwnProperty(kinds, kind)) {
	                if (!this.addError('Invalid kind name \'%0\'', kind)) {
	                    return false;
	                }
	            }
	            return true;
	        };

	        TagParser.prototype.parseAccess = function parseAccess() {
	            var access;
	            access = trim(sliceSource(source, index, this._last));
	            this._tag.access = access;
	            if (access !== 'private' && access !== 'protected' && access !== 'public') {
	                if (!this.addError('Invalid access name \'%0\'', access)) {
	                    return false;
	                }
	            }
	            return true;
	        };

	        TagParser.prototype.parseVariation = function parseVariation() {
	            var variation, text;
	            text = trim(sliceSource(source, index, this._last));
	            variation = parseFloat(text, 10);
	            this._tag.variation = variation;
	            if (isNaN(variation)) {
	                if (!this.addError('Invalid variation \'%0\'', text)) {
	                    return false;
	                }
	            }
	            return true;
	        };

	        TagParser.prototype.ensureEnd = function () {
	            var shouldBeEmpty = trim(sliceSource(source, index, this._last));
	            if (shouldBeEmpty) {
	                if (!this.addError('Unknown content \'%0\'', shouldBeEmpty)) {
	                    return false;
	                }
	            }
	            return true;
	        };

	        TagParser.prototype.epilogue = function epilogue() {
	            var description;

	            description = this._tag.description;
	            // un-fix potentially sloppy declaration
	            if (isParamTitle(this._title) && !this._tag.type && description && description.charAt(0) === '[') {
	                this._tag.type = this._extra.name;
	                this._tag.name = undefined;

	                if (!sloppy) {
	                    if (!this.addError('Missing or invalid tag name')) {
	                        return false;
	                    }
	                }
	            }

	            return true;
	        };

	        Rules = {
	            // http://usejsdoc.org/tags-access.html
	            'access': ['parseAccess'],
	            // http://usejsdoc.org/tags-alias.html
	            'alias': ['parseNamePath', 'ensureEnd'],
	            // http://usejsdoc.org/tags-augments.html
	            'augments': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
	            // http://usejsdoc.org/tags-constructor.html
	            'constructor': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
	            // Synonym: http://usejsdoc.org/tags-constructor.html
	            'class': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
	            // Synonym: http://usejsdoc.org/tags-extends.html
	            'extends': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
	            // http://usejsdoc.org/tags-deprecated.html
	            'deprecated': ['parseDescription'],
	            // http://usejsdoc.org/tags-global.html
	            'global': ['ensureEnd'],
	            // http://usejsdoc.org/tags-inner.html
	            'inner': ['ensureEnd'],
	            // http://usejsdoc.org/tags-instance.html
	            'instance': ['ensureEnd'],
	            // http://usejsdoc.org/tags-kind.html
	            'kind': ['parseKind'],
	            // http://usejsdoc.org/tags-mixes.html
	            'mixes': ['parseNamePath', 'ensureEnd'],
	            // http://usejsdoc.org/tags-mixin.html
	            'mixin': ['parseNamePathOptional', 'ensureEnd'],
	            // http://usejsdoc.org/tags-member.html
	            'member': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
	            // http://usejsdoc.org/tags-method.html
	            'method': ['parseNamePathOptional', 'ensureEnd'],
	            // http://usejsdoc.org/tags-module.html
	            'module': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
	            // Synonym: http://usejsdoc.org/tags-method.html
	            'func': ['parseNamePathOptional', 'ensureEnd'],
	            // Synonym: http://usejsdoc.org/tags-method.html
	            'function': ['parseNamePathOptional', 'ensureEnd'],
	            // Synonym: http://usejsdoc.org/tags-member.html
	            'var': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
	            // http://usejsdoc.org/tags-name.html
	            'name': ['parseNamePath', 'ensureEnd'],
	            // http://usejsdoc.org/tags-namespace.html
	            'namespace': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
	            // http://usejsdoc.org/tags-private.html
	            'private': ['parseType', 'parseDescription'],
	            // http://usejsdoc.org/tags-protected.html
	            'protected': ['parseType', 'parseDescription'],
	            // http://usejsdoc.org/tags-public.html
	            'public': ['parseType', 'parseDescription'],
	            // http://usejsdoc.org/tags-readonly.html
	            'readonly': ['ensureEnd'],
	            // http://usejsdoc.org/tags-requires.html
	            'requires': ['parseNamePath', 'ensureEnd'],
	            // http://usejsdoc.org/tags-since.html
	            'since': ['parseDescription'],
	            // http://usejsdoc.org/tags-static.html
	            'static': ['ensureEnd'],
	            // http://usejsdoc.org/tags-summary.html
	            'summary': ['parseDescription'],
	            // http://usejsdoc.org/tags-this.html
	            'this': ['parseNamePath', 'ensureEnd'],
	            // http://usejsdoc.org/tags-todo.html
	            'todo': ['parseDescription'],
	            // http://usejsdoc.org/tags-variation.html
	            'variation': ['parseVariation'],
	            // http://usejsdoc.org/tags-version.html
	            'version': ['parseDescription']
	        };

	        TagParser.prototype.parse = function parse() {
	            var i, iz, sequences, method;

	            // empty title
	            if (!this._title) {
	                if (!this.addError('Missing or invalid title')) {
	                    return null;
	                }
	            }

	            // Seek to content last index.
	            this._last = seekContent(this._title);

	            if (hasOwnProperty(Rules, this._title)) {
	                sequences = Rules[this._title];
	            } else {
	                // default sequences
	                sequences = ['parseType', 'parseName', 'parseDescription', 'epilogue'];
	            }

	            for (i = 0, iz = sequences.length; i < iz; ++i) {
	                method = sequences[i];
	                if (!this[method]()) {
	                    return null;
	                }
	            }

	            // Seek global index to end of this tag.
	            index = this._last;
	            return this._tag;
	        };

	        function parseTag(options) {
	            var title, parser;

	            // skip to tag
	            if (!skipToTag()) {
	                return null;
	            }

	            // scan title
	            title = scanTitle();

	            // construct tag parser
	            parser = new TagParser(options, title);
	            return parser.parse();
	        }

	        //
	        // Parse JSDoc
	        //

	        function scanJSDocDescription() {
	            var description = '', ch, atAllowed;

	            atAllowed = true;
	            while (index < length) {
	                ch = source.charCodeAt(index);

	                if (atAllowed && ch === 0x40  /* '@' */) {
	                    break;
	                }

	                if (esutils.code.isLineTerminator(ch)) {
	                    atAllowed = true;
	                } else if (atAllowed && !esutils.code.isWhiteSpace(ch)) {
	                    atAllowed = false;
	                }

	                description += advance();
	            }
	            return trim(description);
	        }

	        function parse(comment, options) {
	            var tags = [], tag, description, interestingTags, i, iz;

	            if (options === undefined) {
	                options = {};
	            }

	            if (typeof options.unwrap === 'boolean' && options.unwrap) {
	                source = unwrapComment(comment);
	            } else {
	                source = comment;
	            }

	            // array of relevant tags
	            if (options.tags) {
	                if (isArray(options.tags)) {
	                    interestingTags = { };
	                    for (i = 0, iz = options.tags.length; i < iz; i++) {
	                        if (typeof options.tags[i] === 'string') {
	                            interestingTags[options.tags[i]] = true;
	                        } else {
	                            utility.throwError('Invalid "tags" parameter: ' + options.tags);
	                        }
	                    }
	                } else {
	                    utility.throwError('Invalid "tags" parameter: ' + options.tags);
	                }
	            }

	            length = source.length;
	            index = 0;
	            lineNumber = 0;
	            recoverable = options.recoverable;
	            sloppy = options.sloppy;
	            strict = options.strict;

	            description = scanJSDocDescription();

	            while (true) {
	                tag = parseTag(options);
	                if (!tag) {
	                    break;
	                }
	                if (!interestingTags || interestingTags.hasOwnProperty(tag.title)) {
	                    tags.push(tag);
	                }
	            }

	            return {
	                description: description,
	                tags: tags
	            };
	        }
	        exports.parse = parse;
	    }(jsdoc = {}));

	    exports.version = utility.VERSION;
	    exports.parse = jsdoc.parse;
	    exports.parseType = typed.parseType;
	    exports.parseParamType = typed.parseParamType;
	    exports.unwrapComment = unwrapComment;
	    exports.Syntax = shallowCopy(typed.Syntax);
	    exports.Error = utility.DoctrineError;
	    exports.type = {
	        Syntax: exports.Syntax,
	        parseType: typed.parseType,
	        parseParamType: typed.parseParamType,
	        stringify: typed.stringify
	    };
	}());
	/* vim: set sw=4 ts=4 et tw=80 : */


/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	/*
	  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/


	(function () {
	    'use strict';

	    exports.ast = __webpack_require__(205);
	    exports.code = __webpack_require__(206);
	    exports.keyword = __webpack_require__(207);
	}());
	/* vim: set sw=4 ts=4 et tw=80 : */


/***/ },
/* 205 */
/***/ function(module, exports) {

	/*
	  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	(function () {
	    'use strict';

	    function isExpression(node) {
	        if (node == null) { return false; }
	        switch (node.type) {
	            case 'ArrayExpression':
	            case 'AssignmentExpression':
	            case 'BinaryExpression':
	            case 'CallExpression':
	            case 'ConditionalExpression':
	            case 'FunctionExpression':
	            case 'Identifier':
	            case 'Literal':
	            case 'LogicalExpression':
	            case 'MemberExpression':
	            case 'NewExpression':
	            case 'ObjectExpression':
	            case 'SequenceExpression':
	            case 'ThisExpression':
	            case 'UnaryExpression':
	            case 'UpdateExpression':
	                return true;
	        }
	        return false;
	    }

	    function isIterationStatement(node) {
	        if (node == null) { return false; }
	        switch (node.type) {
	            case 'DoWhileStatement':
	            case 'ForInStatement':
	            case 'ForStatement':
	            case 'WhileStatement':
	                return true;
	        }
	        return false;
	    }

	    function isStatement(node) {
	        if (node == null) { return false; }
	        switch (node.type) {
	            case 'BlockStatement':
	            case 'BreakStatement':
	            case 'ContinueStatement':
	            case 'DebuggerStatement':
	            case 'DoWhileStatement':
	            case 'EmptyStatement':
	            case 'ExpressionStatement':
	            case 'ForInStatement':
	            case 'ForStatement':
	            case 'IfStatement':
	            case 'LabeledStatement':
	            case 'ReturnStatement':
	            case 'SwitchStatement':
	            case 'ThrowStatement':
	            case 'TryStatement':
	            case 'VariableDeclaration':
	            case 'WhileStatement':
	            case 'WithStatement':
	                return true;
	        }
	        return false;
	    }

	    function isSourceElement(node) {
	      return isStatement(node) || node != null && node.type === 'FunctionDeclaration';
	    }

	    function trailingStatement(node) {
	        switch (node.type) {
	        case 'IfStatement':
	            if (node.alternate != null) {
	                return node.alternate;
	            }
	            return node.consequent;

	        case 'LabeledStatement':
	        case 'ForStatement':
	        case 'ForInStatement':
	        case 'WhileStatement':
	        case 'WithStatement':
	            return node.body;
	        }
	        return null;
	    }

	    function isProblematicIfStatement(node) {
	        var current;

	        if (node.type !== 'IfStatement') {
	            return false;
	        }
	        if (node.alternate == null) {
	            return false;
	        }
	        current = node.consequent;
	        do {
	            if (current.type === 'IfStatement') {
	                if (current.alternate == null)  {
	                    return true;
	                }
	            }
	            current = trailingStatement(current);
	        } while (current);

	        return false;
	    }

	    module.exports = {
	        isExpression: isExpression,
	        isStatement: isStatement,
	        isIterationStatement: isIterationStatement,
	        isSourceElement: isSourceElement,
	        isProblematicIfStatement: isProblematicIfStatement,

	        trailingStatement: trailingStatement
	    };
	}());
	/* vim: set sw=4 ts=4 et tw=80 : */


/***/ },
/* 206 */
/***/ function(module, exports) {

	/*
	  Copyright (C) 2013-2014 Yusuke Suzuki <utatane.tea@gmail.com>
	  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	(function () {
	    'use strict';

	    var Regex, NON_ASCII_WHITESPACES;

	    // See `tools/generate-identifier-regex.js`.
	    Regex = {
	        NonAsciiIdentifierStart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]'),
	        NonAsciiIdentifierPart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0\u08A2-\u08AC\u08E4-\u08FE\u0900-\u0963\u0966-\u096F\u0971-\u0977\u0979-\u097F\u0981-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C82\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D02\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191C\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1D00-\u1DE6\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA697\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7B\uAA80-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE26\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]')
	    };

	    function isDecimalDigit(ch) {
	        return (ch >= 48 && ch <= 57);   // 0..9
	    }

	    function isHexDigit(ch) {
	        return isDecimalDigit(ch) ||    // 0..9
	            (97 <= ch && ch <= 102) ||  // a..f
	            (65 <= ch && ch <= 70);     // A..F
	    }

	    function isOctalDigit(ch) {
	        return (ch >= 48 && ch <= 55);   // 0..7
	    }

	    // 7.2 White Space

	    NON_ASCII_WHITESPACES = [
	        0x1680, 0x180E,
	        0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A,
	        0x202F, 0x205F,
	        0x3000,
	        0xFEFF
	    ];

	    function isWhiteSpace(ch) {
	        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||
	            (ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0);
	    }

	    // 7.3 Line Terminators

	    function isLineTerminator(ch) {
	        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);
	    }

	    // 7.6 Identifier Names and Identifiers

	    function isIdentifierStart(ch) {
	        return (ch >= 97 && ch <= 122) ||     // a..z
	            (ch >= 65 && ch <= 90) ||         // A..Z
	            (ch === 36) || (ch === 95) ||     // $ (dollar) and _ (underscore)
	            (ch === 92) ||                    // \ (backslash)
	            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));
	    }

	    function isIdentifierPart(ch) {
	        return (ch >= 97 && ch <= 122) ||     // a..z
	            (ch >= 65 && ch <= 90) ||         // A..Z
	            (ch >= 48 && ch <= 57) ||         // 0..9
	            (ch === 36) || (ch === 95) ||     // $ (dollar) and _ (underscore)
	            (ch === 92) ||                    // \ (backslash)
	            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));
	    }

	    module.exports = {
	        isDecimalDigit: isDecimalDigit,
	        isHexDigit: isHexDigit,
	        isOctalDigit: isOctalDigit,
	        isWhiteSpace: isWhiteSpace,
	        isLineTerminator: isLineTerminator,
	        isIdentifierStart: isIdentifierStart,
	        isIdentifierPart: isIdentifierPart
	    };
	}());
	/* vim: set sw=4 ts=4 et tw=80 : */


/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	/*
	  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	(function () {
	    'use strict';

	    var code = __webpack_require__(206);

	    function isStrictModeReservedWordES6(id) {
	        switch (id) {
	        case 'implements':
	        case 'interface':
	        case 'package':
	        case 'private':
	        case 'protected':
	        case 'public':
	        case 'static':
	        case 'let':
	            return true;
	        default:
	            return false;
	        }
	    }

	    function isKeywordES5(id, strict) {
	        // yield should not be treated as keyword under non-strict mode.
	        if (!strict && id === 'yield') {
	            return false;
	        }
	        return isKeywordES6(id, strict);
	    }

	    function isKeywordES6(id, strict) {
	        if (strict && isStrictModeReservedWordES6(id)) {
	            return true;
	        }

	        switch (id.length) {
	        case 2:
	            return (id === 'if') || (id === 'in') || (id === 'do');
	        case 3:
	            return (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');
	        case 4:
	            return (id === 'this') || (id === 'else') || (id === 'case') ||
	                (id === 'void') || (id === 'with') || (id === 'enum');
	        case 5:
	            return (id === 'while') || (id === 'break') || (id === 'catch') ||
	                (id === 'throw') || (id === 'const') || (id === 'yield') ||
	                (id === 'class') || (id === 'super');
	        case 6:
	            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
	                (id === 'switch') || (id === 'export') || (id === 'import');
	        case 7:
	            return (id === 'default') || (id === 'finally') || (id === 'extends');
	        case 8:
	            return (id === 'function') || (id === 'continue') || (id === 'debugger');
	        case 10:
	            return (id === 'instanceof');
	        default:
	            return false;
	        }
	    }

	    function isReservedWordES5(id, strict) {
	        return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);
	    }

	    function isReservedWordES6(id, strict) {
	        return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);
	    }

	    function isRestrictedWord(id) {
	        return id === 'eval' || id === 'arguments';
	    }

	    function isIdentifierName(id) {
	        var i, iz, ch;

	        if (id.length === 0) {
	            return false;
	        }

	        ch = id.charCodeAt(0);
	        if (!code.isIdentifierStart(ch) || ch === 92) {  // \ (backslash)
	            return false;
	        }

	        for (i = 1, iz = id.length; i < iz; ++i) {
	            ch = id.charCodeAt(i);
	            if (!code.isIdentifierPart(ch) || ch === 92) {  // \ (backslash)
	                return false;
	            }
	        }
	        return true;
	    }

	    function isIdentifierES5(id, strict) {
	        return isIdentifierName(id) && !isReservedWordES5(id, strict);
	    }

	    function isIdentifierES6(id, strict) {
	        return isIdentifierName(id) && !isReservedWordES6(id, strict);
	    }

	    module.exports = {
	        isKeywordES5: isKeywordES5,
	        isKeywordES6: isKeywordES6,
	        isReservedWordES5: isReservedWordES5,
	        isReservedWordES6: isReservedWordES6,
	        isRestrictedWord: isRestrictedWord,
	        isIdentifierName: isIdentifierName,
	        isIdentifierES5: isIdentifierES5,
	        isIdentifierES6: isIdentifierES6
	    };
	}());
	/* vim: set sw=4 ts=4 et tw=80 : */


/***/ },
/* 208 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	/*
	  Copyright (C) 2012-2014 Yusuke Suzuki <utatane.tea@gmail.com>
	  Copyright (C) 2014 Dan Tao <daniel.tao@gmail.com>
	  Copyright (C) 2013 Andrew Eisenberg <andrew@eisenberg.as>

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	// "typed", the Type Expression Parser for doctrine.

	(function () {
	    'use strict';

	    var Syntax,
	        Token,
	        source,
	        length,
	        index,
	        previous,
	        token,
	        value,
	        esutils,
	        utility;

	    esutils = __webpack_require__(204);
	    utility = __webpack_require__(210);

	    Syntax = {
	        NullableLiteral: 'NullableLiteral',
	        AllLiteral: 'AllLiteral',
	        NullLiteral: 'NullLiteral',
	        UndefinedLiteral: 'UndefinedLiteral',
	        VoidLiteral: 'VoidLiteral',
	        UnionType: 'UnionType',
	        ArrayType: 'ArrayType',
	        RecordType: 'RecordType',
	        FieldType: 'FieldType',
	        FunctionType: 'FunctionType',
	        ParameterType: 'ParameterType',
	        RestType: 'RestType',
	        NonNullableType: 'NonNullableType',
	        OptionalType: 'OptionalType',
	        NullableType: 'NullableType',
	        NameExpression: 'NameExpression',
	        TypeApplication: 'TypeApplication'
	    };

	    Token = {
	        ILLEGAL: 0,    // ILLEGAL
	        DOT_LT: 1,     // .<
	        REST: 2,       // ...
	        LT: 3,         // <
	        GT: 4,         // >
	        LPAREN: 5,     // (
	        RPAREN: 6,     // )
	        LBRACE: 7,     // {
	        RBRACE: 8,     // }
	        LBRACK: 9,    // [
	        RBRACK: 10,    // ]
	        COMMA: 11,     // ,
	        COLON: 12,     // :
	        STAR: 13,      // *
	        PIPE: 14,      // |
	        QUESTION: 15,  // ?
	        BANG: 16,      // !
	        EQUAL: 17,     // =
	        NAME: 18,      // name token
	        STRING: 19,    // string
	        NUMBER: 20,    // number
	        EOF: 21
	    };

	    function isTypeName(ch) {
	        return '><(){}[],:*|?!='.indexOf(String.fromCharCode(ch)) === -1 && !esutils.code.isWhiteSpace(ch) && !esutils.code.isLineTerminator(ch);
	    }

	    function Context(previous, index, token, value) {
	        this._previous = previous;
	        this._index = index;
	        this._token = token;
	        this._value = value;
	    }

	    Context.prototype.restore = function () {
	        previous = this._previous;
	        index = this._index;
	        token = this._token;
	        value = this._value;
	    };

	    Context.save = function () {
	        return new Context(previous, index, token, value);
	    };

	    function advance() {
	        var ch = source.charAt(index);
	        index += 1;
	        return ch;
	    }

	    function scanHexEscape(prefix) {
	        var i, len, ch, code = 0;

	        len = (prefix === 'u') ? 4 : 2;
	        for (i = 0; i < len; ++i) {
	            if (index < length && esutils.code.isHexDigit(source.charCodeAt(index))) {
	                ch = advance();
	                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
	            } else {
	                return '';
	            }
	        }
	        return String.fromCharCode(code);
	    }

	    function scanString() {
	        var str = '', quote, ch, code, unescaped, restore; //TODO review removal octal = false
	        quote = source.charAt(index);
	        ++index;

	        while (index < length) {
	            ch = advance();

	            if (ch === quote) {
	                quote = '';
	                break;
	            } else if (ch === '\\') {
	                ch = advance();
	                if (!esutils.code.isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                    case 'n':
	                        str += '\n';
	                        break;
	                    case 'r':
	                        str += '\r';
	                        break;
	                    case 't':
	                        str += '\t';
	                        break;
	                    case 'u':
	                    case 'x':
	                        restore = index;
	                        unescaped = scanHexEscape(ch);
	                        if (unescaped) {
	                            str += unescaped;
	                        } else {
	                            index = restore;
	                            str += ch;
	                        }
	                        break;
	                    case 'b':
	                        str += '\b';
	                        break;
	                    case 'f':
	                        str += '\f';
	                        break;
	                    case 'v':
	                        str += '\v';
	                        break;

	                    default:
	                        if (esutils.code.isOctalDigit(ch.charCodeAt(0))) {
	                            code = '01234567'.indexOf(ch);

	                            // \0 is not octal escape sequence
	                            // Deprecating unused code. TODO review removal
	                            //if (code !== 0) {
	                            //    octal = true;
	                            //}

	                            if (index < length && esutils.code.isOctalDigit(source.charCodeAt(index))) {
	                                //TODO Review Removal octal = true;
	                                code = code * 8 + '01234567'.indexOf(advance());

	                                // 3 digits are only allowed when string starts
	                                // with 0, 1, 2, 3
	                                if ('0123'.indexOf(ch) >= 0 &&
	                                        index < length &&
	                                        esutils.code.isOctalDigit(source.charCodeAt(index))) {
	                                    code = code * 8 + '01234567'.indexOf(advance());
	                                }
	                            }
	                            str += String.fromCharCode(code);
	                        } else {
	                            str += ch;
	                        }
	                        break;
	                    }
	                } else {
	                    if (ch ===  '\r' && source.charCodeAt(index) === 0x0A  /* '\n' */) {
	                        ++index;
	                    }
	                }
	            } else if (esutils.code.isLineTerminator(ch.charCodeAt(0))) {
	                break;
	            } else {
	                str += ch;
	            }
	        }

	        if (quote !== '') {
	            utility.throwError('unexpected quote');
	        }

	        value = str;
	        return Token.STRING;
	    }

	    function scanNumber() {
	        var number, ch;

	        number = '';
	        ch = source.charCodeAt(index);

	        if (ch !== 0x2E  /* '.' */) {
	            number = advance();
	            ch = source.charCodeAt(index);

	            if (number === '0') {
	                if (ch === 0x78  /* 'x' */ || ch === 0x58  /* 'X' */) {
	                    number += advance();
	                    while (index < length) {
	                        ch = source.charCodeAt(index);
	                        if (!esutils.code.isHexDigit(ch)) {
	                            break;
	                        }
	                        number += advance();
	                    }

	                    if (number.length <= 2) {
	                        // only 0x
	                        utility.throwError('unexpected token');
	                    }

	                    if (index < length) {
	                        ch = source.charCodeAt(index);
	                        if (esutils.code.isIdentifierStart(ch)) {
	                            utility.throwError('unexpected token');
	                        }
	                    }
	                    value = parseInt(number, 16);
	                    return Token.NUMBER;
	                }

	                if (esutils.code.isOctalDigit(ch)) {
	                    number += advance();
	                    while (index < length) {
	                        ch = source.charCodeAt(index);
	                        if (!esutils.code.isOctalDigit(ch)) {
	                            break;
	                        }
	                        number += advance();
	                    }

	                    if (index < length) {
	                        ch = source.charCodeAt(index);
	                        if (esutils.code.isIdentifierStart(ch) || esutils.code.isDecimalDigit(ch)) {
	                            utility.throwError('unexpected token');
	                        }
	                    }
	                    value = parseInt(number, 8);
	                    return Token.NUMBER;
	                }

	                if (esutils.code.isDecimalDigit(ch)) {
	                    utility.throwError('unexpected token');
	                }
	            }

	            while (index < length) {
	                ch = source.charCodeAt(index);
	                if (!esutils.code.isDecimalDigit(ch)) {
	                    break;
	                }
	                number += advance();
	            }
	        }

	        if (ch === 0x2E  /* '.' */) {
	            number += advance();
	            while (index < length) {
	                ch = source.charCodeAt(index);
	                if (!esutils.code.isDecimalDigit(ch)) {
	                    break;
	                }
	                number += advance();
	            }
	        }

	        if (ch === 0x65  /* 'e' */ || ch === 0x45  /* 'E' */) {
	            number += advance();

	            ch = source.charCodeAt(index);
	            if (ch === 0x2B  /* '+' */ || ch === 0x2D  /* '-' */) {
	                number += advance();
	            }

	            ch = source.charCodeAt(index);
	            if (esutils.code.isDecimalDigit(ch)) {
	                number += advance();
	                while (index < length) {
	                    ch = source.charCodeAt(index);
	                    if (!esutils.code.isDecimalDigit(ch)) {
	                        break;
	                    }
	                    number += advance();
	                }
	            } else {
	                utility.throwError('unexpected token');
	            }
	        }

	        if (index < length) {
	            ch = source.charCodeAt(index);
	            if (esutils.code.isIdentifierStart(ch)) {
	                utility.throwError('unexpected token');
	            }
	        }

	        value = parseFloat(number);
	        return Token.NUMBER;
	    }


	    function scanTypeName() {
	        var ch, ch2;

	        value = advance();
	        while (index < length && isTypeName(source.charCodeAt(index))) {
	            ch = source.charCodeAt(index);
	            if (ch === 0x2E  /* '.' */) {
	                if ((index + 1) >= length) {
	                    return Token.ILLEGAL;
	                }
	                ch2 = source.charCodeAt(index + 1);
	                if (ch2 === 0x3C  /* '<' */) {
	                    break;
	                }
	            }
	            value += advance();
	        }
	        return Token.NAME;
	    }

	    function next() {
	        var ch;

	        previous = index;

	        while (index < length && esutils.code.isWhiteSpace(source.charCodeAt(index))) {
	            advance();
	        }
	        if (index >= length) {
	            token = Token.EOF;
	            return token;
	        }

	        ch = source.charCodeAt(index);
	        switch (ch) {
	        case 0x27:  /* ''' */
	        case 0x22:  /* '"' */
	            token = scanString();
	            return token;

	        case 0x3A:  /* ':' */
	            advance();
	            token = Token.COLON;
	            return token;

	        case 0x2C:  /* ',' */
	            advance();
	            token = Token.COMMA;
	            return token;

	        case 0x28:  /* '(' */
	            advance();
	            token = Token.LPAREN;
	            return token;

	        case 0x29:  /* ')' */
	            advance();
	            token = Token.RPAREN;
	            return token;

	        case 0x5B:  /* '[' */
	            advance();
	            token = Token.LBRACK;
	            return token;

	        case 0x5D:  /* ']' */
	            advance();
	            token = Token.RBRACK;
	            return token;

	        case 0x7B:  /* '{' */
	            advance();
	            token = Token.LBRACE;
	            return token;

	        case 0x7D:  /* '}' */
	            advance();
	            token = Token.RBRACE;
	            return token;

	        case 0x2E:  /* '.' */
	            if (index + 1 < length) {
	                ch = source.charCodeAt(index + 1);
	                if (ch === 0x3C  /* '<' */) {
	                    advance();  // '.'
	                    advance();  // '<'
	                    token = Token.DOT_LT;
	                    return token;
	                }

	                if (ch === 0x2E  /* '.' */ && index + 2 < length && source.charCodeAt(index + 2) === 0x2E  /* '.' */) {
	                    advance();  // '.'
	                    advance();  // '.'
	                    advance();  // '.'
	                    token = Token.REST;
	                    return token;
	                }

	                if (esutils.code.isDecimalDigit(ch)) {
	                    token = scanNumber();
	                    return token;
	                }
	            }
	            token = Token.ILLEGAL;
	            return token;

	        case 0x3C:  /* '<' */
	            advance();
	            token = Token.LT;
	            return token;

	        case 0x3E:  /* '>' */
	            advance();
	            token = Token.GT;
	            return token;

	        case 0x2A:  /* '*' */
	            advance();
	            token = Token.STAR;
	            return token;

	        case 0x7C:  /* '|' */
	            advance();
	            token = Token.PIPE;
	            return token;

	        case 0x3F:  /* '?' */
	            advance();
	            token = Token.QUESTION;
	            return token;

	        case 0x21:  /* '!' */
	            advance();
	            token = Token.BANG;
	            return token;

	        case 0x3D:  /* '=' */
	            advance();
	            token = Token.EQUAL;
	            return token;

	        default:
	            if (esutils.code.isDecimalDigit(ch)) {
	                token = scanNumber();
	                return token;
	            }

	            // type string permits following case,
	            //
	            // namespace.module.MyClass
	            //
	            // this reduced 1 token TK_NAME
	            utility.assert(isTypeName(ch));
	            token = scanTypeName();
	            return token;
	        }
	    }

	    function consume(target, text) {
	        utility.assert(token === target, text || 'consumed token not matched');
	        next();
	    }

	    function expect(target, message) {
	        if (token !== target) {
	            utility.throwError(message || 'unexpected token');
	        }
	        next();
	    }

	    // UnionType := '(' TypeUnionList ')'
	    //
	    // TypeUnionList :=
	    //     <<empty>>
	    //   | NonemptyTypeUnionList
	    //
	    // NonemptyTypeUnionList :=
	    //     TypeExpression
	    //   | TypeExpression '|' NonemptyTypeUnionList
	    function parseUnionType() {
	        var elements;
	        consume(Token.LPAREN, 'UnionType should start with (');
	        elements = [];
	        if (token !== Token.RPAREN) {
	            while (true) {
	                elements.push(parseTypeExpression());
	                if (token === Token.RPAREN) {
	                    break;
	                }
	                expect(Token.PIPE);
	            }
	        }
	        consume(Token.RPAREN, 'UnionType should end with )');
	        return {
	            type: Syntax.UnionType,
	            elements: elements
	        };
	    }

	    // ArrayType := '[' ElementTypeList ']'
	    //
	    // ElementTypeList :=
	    //     <<empty>>
	    //  | TypeExpression
	    //  | '...' TypeExpression
	    //  | TypeExpression ',' ElementTypeList
	    function parseArrayType() {
	        var elements;
	        consume(Token.LBRACK, 'ArrayType should start with [');
	        elements = [];
	        while (token !== Token.RBRACK) {
	            if (token === Token.REST) {
	                consume(Token.REST);
	                elements.push({
	                    type: Syntax.RestType,
	                    expression: parseTypeExpression()
	                });
	                break;
	            } else {
	                elements.push(parseTypeExpression());
	            }
	            if (token !== Token.RBRACK) {
	                expect(Token.COMMA);
	            }
	        }
	        expect(Token.RBRACK);
	        return {
	            type: Syntax.ArrayType,
	            elements: elements
	        };
	    }

	    function parseFieldName() {
	        var v = value;
	        if (token === Token.NAME || token === Token.STRING) {
	            next();
	            return v;
	        }

	        if (token === Token.NUMBER) {
	            consume(Token.NUMBER);
	            return String(v);
	        }

	        utility.throwError('unexpected token');
	    }

	    // FieldType :=
	    //     FieldName
	    //   | FieldName ':' TypeExpression
	    //
	    // FieldName :=
	    //     NameExpression
	    //   | StringLiteral
	    //   | NumberLiteral
	    //   | ReservedIdentifier
	    function parseFieldType() {
	        var key;

	        key = parseFieldName();
	        if (token === Token.COLON) {
	            consume(Token.COLON);
	            return {
	                type: Syntax.FieldType,
	                key: key,
	                value: parseTypeExpression()
	            };
	        }
	        return {
	            type: Syntax.FieldType,
	            key: key,
	            value: null
	        };
	    }

	    // RecordType := '{' FieldTypeList '}'
	    //
	    // FieldTypeList :=
	    //     <<empty>>
	    //   | FieldType
	    //   | FieldType ',' FieldTypeList
	    function parseRecordType() {
	        var fields;

	        consume(Token.LBRACE, 'RecordType should start with {');
	        fields = [];
	        if (token === Token.COMMA) {
	            consume(Token.COMMA);
	        } else {
	            while (token !== Token.RBRACE) {
	                fields.push(parseFieldType());
	                if (token !== Token.RBRACE) {
	                    expect(Token.COMMA);
	                }
	            }
	        }
	        expect(Token.RBRACE);
	        return {
	            type: Syntax.RecordType,
	            fields: fields
	        };
	    }

	    // NameExpression :=
	    //    Identifier
	    //  | TagIdentifier ':' Identifier
	    //
	    // Tag identifier is one of "module", "external" or "event"
	    // Identifier is the same as Token.NAME, including any dots, something like
	    // namespace.module.MyClass
	    function parseNameExpression() {
	        var name = value;
	        expect(Token.NAME);

	        if (token === Token.COLON && (
	                name === 'module' ||
	                name === 'external' ||
	                name === 'event')) {
	            consume(Token.COLON);
	            name += ':' + value;
	            expect(Token.NAME);
	        }

	        return {
	            type: Syntax.NameExpression,
	            name: name
	        };
	    }

	    // TypeExpressionList :=
	    //     TopLevelTypeExpression
	    //   | TopLevelTypeExpression ',' TypeExpressionList
	    function parseTypeExpressionList() {
	        var elements = [];

	        elements.push(parseTop());
	        while (token === Token.COMMA) {
	            consume(Token.COMMA);
	            elements.push(parseTop());
	        }
	        return elements;
	    }

	    // TypeName :=
	    //     NameExpression
	    //   | NameExpression TypeApplication
	    //
	    // TypeApplication :=
	    //     '.<' TypeExpressionList '>'
	    //   | '<' TypeExpressionList '>'   // this is extension of doctrine
	    function parseTypeName() {
	        var expr, applications;

	        expr = parseNameExpression();
	        if (token === Token.DOT_LT || token === Token.LT) {
	            next();
	            applications = parseTypeExpressionList();
	            expect(Token.GT);
	            return {
	                type: Syntax.TypeApplication,
	                expression: expr,
	                applications: applications
	            };
	        }
	        return expr;
	    }

	    // ResultType :=
	    //     <<empty>>
	    //   | ':' void
	    //   | ':' TypeExpression
	    //
	    // BNF is above
	    // but, we remove <<empty>> pattern, so token is always TypeToken::COLON
	    function parseResultType() {
	        consume(Token.COLON, 'ResultType should start with :');
	        if (token === Token.NAME && value === 'void') {
	            consume(Token.NAME);
	            return {
	                type: Syntax.VoidLiteral
	            };
	        }
	        return parseTypeExpression();
	    }

	    // ParametersType :=
	    //     RestParameterType
	    //   | NonRestParametersType
	    //   | NonRestParametersType ',' RestParameterType
	    //
	    // RestParameterType :=
	    //     '...'
	    //     '...' Identifier
	    //
	    // NonRestParametersType :=
	    //     ParameterType ',' NonRestParametersType
	    //   | ParameterType
	    //   | OptionalParametersType
	    //
	    // OptionalParametersType :=
	    //     OptionalParameterType
	    //   | OptionalParameterType, OptionalParametersType
	    //
	    // OptionalParameterType := ParameterType=
	    //
	    // ParameterType := TypeExpression | Identifier ':' TypeExpression
	    //
	    // Identifier is "new" or "this"
	    function parseParametersType() {
	        var params = [], optionalSequence = false, expr, rest = false;

	        while (token !== Token.RPAREN) {
	            if (token === Token.REST) {
	                // RestParameterType
	                consume(Token.REST);
	                rest = true;
	            }

	            expr = parseTypeExpression();
	            if (expr.type === Syntax.NameExpression && token === Token.COLON) {
	                // Identifier ':' TypeExpression
	                consume(Token.COLON);
	                expr = {
	                    type: Syntax.ParameterType,
	                    name: expr.name,
	                    expression: parseTypeExpression()
	                };
	            }
	            if (token === Token.EQUAL) {
	                consume(Token.EQUAL);
	                expr = {
	                    type: Syntax.OptionalType,
	                    expression: expr
	                };
	                optionalSequence = true;
	            } else {
	                if (optionalSequence) {
	                    utility.throwError('unexpected token');
	                }
	            }
	            if (rest) {
	                expr = {
	                    type: Syntax.RestType,
	                    expression: expr
	                };
	            }
	            params.push(expr);
	            if (token !== Token.RPAREN) {
	                expect(Token.COMMA);
	            }
	        }
	        return params;
	    }

	    // FunctionType := 'function' FunctionSignatureType
	    //
	    // FunctionSignatureType :=
	    //   | TypeParameters '(' ')' ResultType
	    //   | TypeParameters '(' ParametersType ')' ResultType
	    //   | TypeParameters '(' 'this' ':' TypeName ')' ResultType
	    //   | TypeParameters '(' 'this' ':' TypeName ',' ParametersType ')' ResultType
	    function parseFunctionType() {
	        var isNew, thisBinding, params, result, fnType;
	        utility.assert(token === Token.NAME && value === 'function', 'FunctionType should start with \'function\'');
	        consume(Token.NAME);

	        // Google Closure Compiler is not implementing TypeParameters.
	        // So we do not. if we don't get '(', we see it as error.
	        expect(Token.LPAREN);

	        isNew = false;
	        params = [];
	        thisBinding = null;
	        if (token !== Token.RPAREN) {
	            // ParametersType or 'this'
	            if (token === Token.NAME &&
	                    (value === 'this' || value === 'new')) {
	                // 'this' or 'new'
	                // 'new' is Closure Compiler extension
	                isNew = value === 'new';
	                consume(Token.NAME);
	                expect(Token.COLON);
	                thisBinding = parseTypeName();
	                if (token === Token.COMMA) {
	                    consume(Token.COMMA);
	                    params = parseParametersType();
	                }
	            } else {
	                params = parseParametersType();
	            }
	        }

	        expect(Token.RPAREN);

	        result = null;
	        if (token === Token.COLON) {
	            result = parseResultType();
	        }

	        fnType = {
	            type: Syntax.FunctionType,
	            params: params,
	            result: result
	        };
	        if (thisBinding) {
	            // avoid adding null 'new' and 'this' properties
	            fnType['this'] = thisBinding;
	            if (isNew) {
	                fnType['new'] = true;
	            }
	        }
	        return fnType;
	    }

	    // BasicTypeExpression :=
	    //     '*'
	    //   | 'null'
	    //   | 'undefined'
	    //   | TypeName
	    //   | FunctionType
	    //   | UnionType
	    //   | RecordType
	    //   | ArrayType
	    function parseBasicTypeExpression() {
	        var context;
	        switch (token) {
	        case Token.STAR:
	            consume(Token.STAR);
	            return {
	                type: Syntax.AllLiteral
	            };

	        case Token.LPAREN:
	            return parseUnionType();

	        case Token.LBRACK:
	            return parseArrayType();

	        case Token.LBRACE:
	            return parseRecordType();

	        case Token.NAME:
	            if (value === 'null') {
	                consume(Token.NAME);
	                return {
	                    type: Syntax.NullLiteral
	                };
	            }

	            if (value === 'undefined') {
	                consume(Token.NAME);
	                return {
	                    type: Syntax.UndefinedLiteral
	                };
	            }

	            context = Context.save();
	            if (value === 'function') {
	                try {
	                    return parseFunctionType();
	                } catch (e) {
	                    context.restore();
	                }
	            }

	            return parseTypeName();

	        default:
	            utility.throwError('unexpected token');
	        }
	    }

	    // TypeExpression :=
	    //     BasicTypeExpression
	    //   | '?' BasicTypeExpression
	    //   | '!' BasicTypeExpression
	    //   | BasicTypeExpression '?'
	    //   | BasicTypeExpression '!'
	    //   | '?'
	    //   | BasicTypeExpression '[]'
	    function parseTypeExpression() {
	        var expr;

	        if (token === Token.QUESTION) {
	            consume(Token.QUESTION);
	            if (token === Token.COMMA || token === Token.EQUAL || token === Token.RBRACE ||
	                    token === Token.RPAREN || token === Token.PIPE || token === Token.EOF ||
	                    token === Token.RBRACK || token === Token.GT) {
	                return {
	                    type: Syntax.NullableLiteral
	                };
	            }
	            return {
	                type: Syntax.NullableType,
	                expression: parseBasicTypeExpression(),
	                prefix: true
	            };
	        }

	        if (token === Token.BANG) {
	            consume(Token.BANG);
	            return {
	                type: Syntax.NonNullableType,
	                expression: parseBasicTypeExpression(),
	                prefix: true
	            };
	        }

	        expr = parseBasicTypeExpression();
	        if (token === Token.BANG) {
	            consume(Token.BANG);
	            return {
	                type: Syntax.NonNullableType,
	                expression: expr,
	                prefix: false
	            };
	        }

	        if (token === Token.QUESTION) {
	            consume(Token.QUESTION);
	            return {
	                type: Syntax.NullableType,
	                expression: expr,
	                prefix: false
	            };
	        }

	        if (token === Token.LBRACK) {
	            consume(Token.LBRACK);
	            expect(Token.RBRACK, 'expected an array-style type declaration (' + value + '[])');
	            return {
	                type: Syntax.TypeApplication,
	                expression: {
	                    type: Syntax.NameExpression,
	                    name: 'Array'
	                },
	                applications: [expr]
	            };
	        }

	        return expr;
	    }

	    // TopLevelTypeExpression :=
	    //      TypeExpression
	    //    | TypeUnionList
	    //
	    // This rule is Google Closure Compiler extension, not ES4
	    // like,
	    //   { number | string }
	    // If strict to ES4, we should write it as
	    //   { (number|string) }
	    function parseTop() {
	        var expr, elements;

	        expr = parseTypeExpression();
	        if (token !== Token.PIPE) {
	            return expr;
	        }

	        elements = [ expr ];
	        consume(Token.PIPE);
	        while (true) {
	            elements.push(parseTypeExpression());
	            if (token !== Token.PIPE) {
	                break;
	            }
	            consume(Token.PIPE);
	        }

	        return {
	            type: Syntax.UnionType,
	            elements: elements
	        };
	    }

	    function parseTopParamType() {
	        var expr;

	        if (token === Token.REST) {
	            consume(Token.REST);
	            return {
	                type: Syntax.RestType,
	                expression: parseTop()
	            };
	        }

	        expr = parseTop();
	        if (token === Token.EQUAL) {
	            consume(Token.EQUAL);
	            return {
	                type: Syntax.OptionalType,
	                expression: expr
	            };
	        }

	        return expr;
	    }

	    function parseType(src, opt) {
	        var expr;

	        source = src;
	        length = source.length;
	        index = 0;
	        previous = 0;

	        next();
	        expr = parseTop();

	        if (opt && opt.midstream) {
	            return {
	                expression: expr,
	                index: previous
	            };
	        }

	        if (token !== Token.EOF) {
	            utility.throwError('not reach to EOF');
	        }

	        return expr;
	    }

	    function parseParamType(src, opt) {
	        var expr;

	        source = src;
	        length = source.length;
	        index = 0;
	        previous = 0;

	        next();
	        expr = parseTopParamType();

	        if (opt && opt.midstream) {
	            return {
	                expression: expr,
	                index: previous
	            };
	        }

	        if (token !== Token.EOF) {
	            utility.throwError('not reach to EOF');
	        }

	        return expr;
	    }

	    function stringifyImpl(node, compact, topLevel) {
	        var result, i, iz;

	        switch (node.type) {
	        case Syntax.NullableLiteral:
	            result = '?';
	            break;

	        case Syntax.AllLiteral:
	            result = '*';
	            break;

	        case Syntax.NullLiteral:
	            result = 'null';
	            break;

	        case Syntax.UndefinedLiteral:
	            result = 'undefined';
	            break;

	        case Syntax.VoidLiteral:
	            result = 'void';
	            break;

	        case Syntax.UnionType:
	            if (!topLevel) {
	                result = '(';
	            } else {
	                result = '';
	            }

	            for (i = 0, iz = node.elements.length; i < iz; ++i) {
	                result += stringifyImpl(node.elements[i], compact);
	                if ((i + 1) !== iz) {
	                    result += '|';
	                }
	            }

	            if (!topLevel) {
	                result += ')';
	            }
	            break;

	        case Syntax.ArrayType:
	            result = '[';
	            for (i = 0, iz = node.elements.length; i < iz; ++i) {
	                result += stringifyImpl(node.elements[i], compact);
	                if ((i + 1) !== iz) {
	                    result += compact ? ',' : ', ';
	                }
	            }
	            result += ']';
	            break;

	        case Syntax.RecordType:
	            result = '{';
	            for (i = 0, iz = node.fields.length; i < iz; ++i) {
	                result += stringifyImpl(node.fields[i], compact);
	                if ((i + 1) !== iz) {
	                    result += compact ? ',' : ', ';
	                }
	            }
	            result += '}';
	            break;

	        case Syntax.FieldType:
	            if (node.value) {
	                result = node.key + (compact ? ':' : ': ') + stringifyImpl(node.value, compact);
	            } else {
	                result = node.key;
	            }
	            break;

	        case Syntax.FunctionType:
	            result = compact ? 'function(' : 'function (';

	            if (node['this']) {
	                if (node['new']) {
	                    result += (compact ? 'new:' : 'new: ');
	                } else {
	                    result += (compact ? 'this:' : 'this: ');
	                }

	                result += stringifyImpl(node['this'], compact);

	                if (node.params.length !== 0) {
	                    result += compact ? ',' : ', ';
	                }
	            }

	            for (i = 0, iz = node.params.length; i < iz; ++i) {
	                result += stringifyImpl(node.params[i], compact);
	                if ((i + 1) !== iz) {
	                    result += compact ? ',' : ', ';
	                }
	            }

	            result += ')';

	            if (node.result) {
	                result += (compact ? ':' : ': ') + stringifyImpl(node.result, compact);
	            }
	            break;

	        case Syntax.ParameterType:
	            result = node.name + (compact ? ':' : ': ') + stringifyImpl(node.expression, compact);
	            break;

	        case Syntax.RestType:
	            result = '...';
	            if (node.expression) {
	                result += stringifyImpl(node.expression, compact);
	            }
	            break;

	        case Syntax.NonNullableType:
	            if (node.prefix) {
	                result = '!' + stringifyImpl(node.expression, compact);
	            } else {
	                result = stringifyImpl(node.expression, compact) + '!';
	            }
	            break;

	        case Syntax.OptionalType:
	            result = stringifyImpl(node.expression, compact) + '=';
	            break;

	        case Syntax.NullableType:
	            if (node.prefix) {
	                result = '?' + stringifyImpl(node.expression, compact);
	            } else {
	                result = stringifyImpl(node.expression, compact) + '?';
	            }
	            break;

	        case Syntax.NameExpression:
	            result = node.name;
	            break;

	        case Syntax.TypeApplication:
	            result = stringifyImpl(node.expression, compact) + '.<';
	            for (i = 0, iz = node.applications.length; i < iz; ++i) {
	                result += stringifyImpl(node.applications[i], compact);
	                if ((i + 1) !== iz) {
	                    result += compact ? ',' : ', ';
	                }
	            }
	            result += '>';
	            break;

	        default:
	            utility.throwError('Unknown type ' + node.type);
	        }

	        return result;
	    }

	    function stringify(node, options) {
	        if (options == null) {
	            options = {};
	        }
	        return stringifyImpl(node, options.compact, options.topLevel);
	    }

	    exports.parseType = parseType;
	    exports.parseParamType = parseParamType;
	    exports.stringify = stringify;
	    exports.Syntax = Syntax;
	}());
	/* vim: set sw=4 ts=4 et tw=80 : */


/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	/*
	  Copyright (C) 2014 Yusuke Suzuki <utatane.tea@gmail.com>

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/


	(function () {
	    'use strict';

	    var VERSION;

	    VERSION = __webpack_require__(211).version;
	    exports.VERSION = VERSION;

	    function DoctrineError(message) {
	        this.name = 'DoctrineError';
	        this.message = message;
	    }
	    DoctrineError.prototype = (function () {
	        var Middle = function () { };
	        Middle.prototype = Error.prototype;
	        return new Middle();
	    }());
	    DoctrineError.prototype.constructor = DoctrineError;
	    exports.DoctrineError = DoctrineError;

	    function throwError(message) {
	        throw new DoctrineError(message);
	    }
	    exports.throwError = throwError;

	    exports.assert = __webpack_require__(212);
	}());

	/* vim: set sw=4 ts=4 et tw=80 : */


/***/ },
/* 211 */
/***/ function(module, exports) {

	module.exports = {
		"name": "doctrine",
		"description": "JSDoc parser",
		"homepage": "http://github.com/Constellation/doctrine.html",
		"main": "lib/doctrine.js",
		"version": "0.6.4",
		"engines": {
			"node": ">=0.10.0"
		},
		"directories": {
			"lib": "./lib"
		},
		"maintainers": [
			{
				"name": "constellation",
				"email": "utatane.tea@gmail.com"
			}
		],
		"repository": {
			"type": "git",
			"url": "git+ssh://git@github.com/Constellation/doctrine.git"
		},
		"devDependencies": {
			"coveralls": "^2.11.2",
			"gulp": "^3.8.10",
			"gulp-bump": "^0.1.13",
			"gulp-eslint": "^0.5.0",
			"gulp-filter": "^2.0.2",
			"gulp-git": "^1.0.0",
			"gulp-istanbul": "^0.6.0",
			"gulp-jshint": "^1.9.0",
			"gulp-mocha": "^2.0.0",
			"gulp-tag-version": "^1.2.1",
			"jshint-stylish": "^1.0.0",
			"should": "^5.0.1"
		},
		"licenses": [
			{
				"type": "BSD",
				"url": "http://github.com/Constellation/doctrine/raw/master/LICENSE.BSD"
			}
		],
		"scripts": {
			"test": "gulp",
			"unit-test": "gulp test",
			"lint": "gulp lint",
			"coveralls": "cat ./coverage/lcov.info | coveralls && rm -rf ./coverage"
		},
		"dependencies": {
			"esutils": "^1.1.6",
			"isarray": "0.0.1"
		},
		"gitHead": "0835299b485ecdfa908d20628d6c8900144590ff",
		"bugs": {
			"url": "https://github.com/Constellation/doctrine/issues"
		},
		"_id": "doctrine@0.6.4",
		"_shasum": "81428491a942ef18b0492056eda3800eee57d61d",
		"_from": "doctrine@>=0.6.2 <0.7.0",
		"_npmVersion": "1.4.28",
		"_npmUser": {
			"name": "constellation",
			"email": "utatane.tea@gmail.com"
		},
		"dist": {
			"shasum": "81428491a942ef18b0492056eda3800eee57d61d",
			"tarball": "http://registry.npmjs.org/doctrine/-/doctrine-0.6.4.tgz"
		},
		"_resolved": "https://registry.npmjs.org/doctrine/-/doctrine-0.6.4.tgz",
		"readme": "ERROR: No README data found!"
	}

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
	//
	// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
	//
	// Originally from narwhal.js (http://narwhaljs.org)
	// Copyright (c) 2009 Thomas Robinson <280north.com>
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the 'Software'), to
	// deal in the Software without restriction, including without limitation the
	// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	// sell copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

	// when used in node, this will actually load the util module we depend on
	// versus loading the builtin util module as happens otherwise
	// this is a bug in node module loading as far as I am concerned
	var util = __webpack_require__(213);

	var pSlice = Array.prototype.slice;
	var hasOwn = Object.prototype.hasOwnProperty;

	// 1. The assert module provides functions that throw
	// AssertionError's when particular conditions are not met. The
	// assert module must conform to the following interface.

	var assert = module.exports = ok;

	// 2. The AssertionError is defined in assert.
	// new assert.AssertionError({ message: message,
	//                             actual: actual,
	//                             expected: expected })

	assert.AssertionError = function AssertionError(options) {
	  this.name = 'AssertionError';
	  this.actual = options.actual;
	  this.expected = options.expected;
	  this.operator = options.operator;
	  if (options.message) {
	    this.message = options.message;
	    this.generatedMessage = false;
	  } else {
	    this.message = getMessage(this);
	    this.generatedMessage = true;
	  }
	  var stackStartFunction = options.stackStartFunction || fail;

	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, stackStartFunction);
	  }
	  else {
	    // non v8 browsers so we can have a stacktrace
	    var err = new Error();
	    if (err.stack) {
	      var out = err.stack;

	      // try to strip useless frames
	      var fn_name = stackStartFunction.name;
	      var idx = out.indexOf('\n' + fn_name);
	      if (idx >= 0) {
	        // once we have located the function frame
	        // we need to strip out everything before it (and its line)
	        var next_line = out.indexOf('\n', idx + 1);
	        out = out.substring(next_line + 1);
	      }

	      this.stack = out;
	    }
	  }
	};

	// assert.AssertionError instanceof Error
	util.inherits(assert.AssertionError, Error);

	function replacer(key, value) {
	  if (util.isUndefined(value)) {
	    return '' + value;
	  }
	  if (util.isNumber(value) && !isFinite(value)) {
	    return value.toString();
	  }
	  if (util.isFunction(value) || util.isRegExp(value)) {
	    return value.toString();
	  }
	  return value;
	}

	function truncate(s, n) {
	  if (util.isString(s)) {
	    return s.length < n ? s : s.slice(0, n);
	  } else {
	    return s;
	  }
	}

	function getMessage(self) {
	  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
	         self.operator + ' ' +
	         truncate(JSON.stringify(self.expected, replacer), 128);
	}

	// At present only the three keys mentioned above are used and
	// understood by the spec. Implementations or sub modules can pass
	// other keys to the AssertionError's constructor - they will be
	// ignored.

	// 3. All of the following functions must throw an AssertionError
	// when a corresponding condition is not met, with a message that
	// may be undefined if not provided.  All assertion methods provide
	// both the actual and expected values to the assertion error for
	// display purposes.

	function fail(actual, expected, message, operator, stackStartFunction) {
	  throw new assert.AssertionError({
	    message: message,
	    actual: actual,
	    expected: expected,
	    operator: operator,
	    stackStartFunction: stackStartFunction
	  });
	}

	// EXTENSION! allows for well behaved errors defined elsewhere.
	assert.fail = fail;

	// 4. Pure assertion tests whether a value is truthy, as determined
	// by !!guard.
	// assert.ok(guard, message_opt);
	// This statement is equivalent to assert.equal(true, !!guard,
	// message_opt);. To test strictly for the value true, use
	// assert.strictEqual(true, guard, message_opt);.

	function ok(value, message) {
	  if (!value) fail(value, true, message, '==', assert.ok);
	}
	assert.ok = ok;

	// 5. The equality assertion tests shallow, coercive equality with
	// ==.
	// assert.equal(actual, expected, message_opt);

	assert.equal = function equal(actual, expected, message) {
	  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
	};

	// 6. The non-equality assertion tests for whether two objects are not equal
	// with != assert.notEqual(actual, expected, message_opt);

	assert.notEqual = function notEqual(actual, expected, message) {
	  if (actual == expected) {
	    fail(actual, expected, message, '!=', assert.notEqual);
	  }
	};

	// 7. The equivalence assertion tests a deep equality relation.
	// assert.deepEqual(actual, expected, message_opt);

	assert.deepEqual = function deepEqual(actual, expected, message) {
	  if (!_deepEqual(actual, expected)) {
	    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
	  }
	};

	function _deepEqual(actual, expected) {
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;

	  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
	    if (actual.length != expected.length) return false;

	    for (var i = 0; i < actual.length; i++) {
	      if (actual[i] !== expected[i]) return false;
	    }

	    return true;

	  // 7.2. If the expected value is a Date object, the actual value is
	  // equivalent if it is also a Date object that refers to the same time.
	  } else if (util.isDate(actual) && util.isDate(expected)) {
	    return actual.getTime() === expected.getTime();

	  // 7.3 If the expected value is a RegExp object, the actual value is
	  // equivalent if it is also a RegExp object with the same source and
	  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
	  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
	    return actual.source === expected.source &&
	           actual.global === expected.global &&
	           actual.multiline === expected.multiline &&
	           actual.lastIndex === expected.lastIndex &&
	           actual.ignoreCase === expected.ignoreCase;

	  // 7.4. Other pairs that do not both pass typeof value == 'object',
	  // equivalence is determined by ==.
	  } else if (!util.isObject(actual) && !util.isObject(expected)) {
	    return actual == expected;

	  // 7.5 For all other Object pairs, including Array objects, equivalence is
	  // determined by having the same number of owned properties (as verified
	  // with Object.prototype.hasOwnProperty.call), the same set of keys
	  // (although not necessarily the same order), equivalent values for every
	  // corresponding key, and an identical 'prototype' property. Note: this
	  // accounts for both named and indexed properties on Arrays.
	  } else {
	    return objEquiv(actual, expected);
	  }
	}

	function isArguments(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	}

	function objEquiv(a, b) {
	  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
	    return false;
	  // an identical 'prototype' property.
	  if (a.prototype !== b.prototype) return false;
	  // if one is a primitive, the other must be same
	  if (util.isPrimitive(a) || util.isPrimitive(b)) {
	    return a === b;
	  }
	  var aIsArgs = isArguments(a),
	      bIsArgs = isArguments(b);
	  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
	    return false;
	  if (aIsArgs) {
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return _deepEqual(a, b);
	  }
	  var ka = objectKeys(a),
	      kb = objectKeys(b),
	      key, i;
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length != kb.length)
	    return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] != kb[i])
	      return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!_deepEqual(a[key], b[key])) return false;
	  }
	  return true;
	}

	// 8. The non-equivalence assertion tests for any deep inequality.
	// assert.notDeepEqual(actual, expected, message_opt);

	assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
	  if (_deepEqual(actual, expected)) {
	    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
	  }
	};

	// 9. The strict equality assertion tests strict equality, as determined by ===.
	// assert.strictEqual(actual, expected, message_opt);

	assert.strictEqual = function strictEqual(actual, expected, message) {
	  if (actual !== expected) {
	    fail(actual, expected, message, '===', assert.strictEqual);
	  }
	};

	// 10. The strict non-equality assertion tests for strict inequality, as
	// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

	assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
	  if (actual === expected) {
	    fail(actual, expected, message, '!==', assert.notStrictEqual);
	  }
	};

	function expectedException(actual, expected) {
	  if (!actual || !expected) {
	    return false;
	  }

	  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
	    return expected.test(actual);
	  } else if (actual instanceof expected) {
	    return true;
	  } else if (expected.call({}, actual) === true) {
	    return true;
	  }

	  return false;
	}

	function _throws(shouldThrow, block, expected, message) {
	  var actual;

	  if (util.isString(expected)) {
	    message = expected;
	    expected = null;
	  }

	  try {
	    block();
	  } catch (e) {
	    actual = e;
	  }

	  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
	            (message ? ' ' + message : '.');

	  if (shouldThrow && !actual) {
	    fail(actual, expected, 'Missing expected exception' + message);
	  }

	  if (!shouldThrow && expectedException(actual, expected)) {
	    fail(actual, expected, 'Got unwanted exception' + message);
	  }

	  if ((shouldThrow && actual && expected &&
	      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
	    throw actual;
	  }
	}

	// 11. Expected to throw an error:
	// assert.throws(block, Error_opt, message_opt);

	assert.throws = function(block, /*optional*/error, /*optional*/message) {
	  _throws.apply(this, [true].concat(pSlice.call(arguments)));
	};

	// EXTENSION! This is annoying to write outside this module.
	assert.doesNotThrow = function(block, /*optional*/message) {
	  _throws.apply(this, [false].concat(pSlice.call(arguments)));
	};

	assert.ifError = function(err) { if (err) {throw err;}};

	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) {
	    if (hasOwn.call(obj, key)) keys.push(key);
	  }
	  return keys;
	};


/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }

	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};


	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }

	  if (process.noDeprecation === true) {
	    return fn;
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	};


	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};


	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;


	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};

	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};


	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];

	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}


	function stylizeNoColor(str, styleType) {
	  return str;
	}


	function arrayToHash(array) {
	  var hash = {};

	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });

	  return hash;
	}


	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }

	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }

	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);

	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }

	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }

	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }

	  var base = '', array = false, braces = ['{', '}'];

	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }

	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }

	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }

	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }

	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }

	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }

	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }

	  ctx.seen.push(value);

	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }

	  ctx.seen.pop();

	  return reduceToSingleString(output, base, braces);
	}


	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}


	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}


	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}


	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }

	  return name + ': ' + str;
	}


	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);

	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }

	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}


	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	exports.isBuffer = __webpack_require__(214);

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}


	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}


	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];

	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}


	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};


	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = __webpack_require__(215);

	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;

	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};

	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(3)))

/***/ },
/* 214 */
/***/ function(module, exports) {

	module.exports = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}

/***/ },
/* 215 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 216 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Ensures that the results of typeof are compared against a valid string
	 * @author Ian Christian Myers
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var VALID_TYPES = ["symbol", "undefined", "object", "boolean", "number", "string", "function"],
	        OPERATORS = ["==", "===", "!=", "!=="];

	    //--------------------------------------------------------------------------
	    // Public
	    //--------------------------------------------------------------------------

	    return {

	        "UnaryExpression": function(node) {
	            var parent, sibling;

	            if (node.operator === "typeof") {
	                parent = context.getAncestors().pop();

	                if (parent.type === "BinaryExpression" && OPERATORS.indexOf(parent.operator) !== -1) {
	                    sibling = parent.left === node ? parent.right : parent.left;

	                    if (sibling.type === "Literal" && VALID_TYPES.indexOf(sibling.value) === -1) {
	                        context.report(sibling, "Invalid typeof comparison value");
	                    }
	                }
	            }
	        }

	    };

	};

	module.exports.schema = [];


/***/ },
/* 217 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to spot scenarios where a newline looks like it is ending a statement, but is not.
	 * @author Glen Mailer
	 * @copyright 2015 Glen Mailer
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	module.exports = function(context) {

	    var FUNCTION_MESSAGE = "Unexpected newline between function and ( of function call.";
	    var PROPERTY_MESSAGE = "Unexpected newline between object and [ of property access.";

	    /**
	     * Check to see if the bracket prior to the node is continuing the previous
	     * line's expression
	     * @param {ASTNode} node The node to check.
	     * @param {string} msg The error message to use.
	     * @returns {void}
	     * @private
	     */
	    function checkForBreakBefore(node, msg) {
	        var tokens = context.getTokensBefore(node, 2);
	        var paren = tokens[1];
	        var before = tokens[0];
	        if (paren.loc.start.line !== before.loc.end.line) {
	            context.report(node, paren.loc.start, msg, { char: paren.value });
	        }
	    }

	    //--------------------------------------------------------------------------
	    // Public API
	    //--------------------------------------------------------------------------

	    return {

	        "MemberExpression": function(node) {
	            if (!node.computed) {
	                return;
	            }

	            checkForBreakBefore(node.property, PROPERTY_MESSAGE);
	        },

	        "CallExpression": function(node) {
	            if (node.arguments.length === 0) {
	                return;
	            }

	            checkForBreakBefore(node.arguments[0], FUNCTION_MESSAGE);
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 218 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag wrapping non-iife in parens
	 * @author Gyandeep Singh
	 * @copyright 2015 Gyandeep Singh. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------

	/**
	 * Checks whether or not a given node is an `Identifier` node which was named a given name.
	 * @param {ASTNode} node - A node to check.
	 * @param {string} name - An expected name of the node.
	 * @returns {boolean} `true` if the node is an `Identifier` node which was named as expected.
	 */
	function isIdentifier(node, name) {
	    return node.type === "Identifier" && node.name === name;
	}

	/**
	 * Checks whether or not a given node is an argument of a specified method call.
	 * @param {ASTNode} node - A node to check.
	 * @param {number} index - An expected index of the node in arguments.
	 * @param {string} object - An expected name of the object of the method.
	 * @param {string} property - An expected name of the method.
	 * @returns {boolean} `true` if the node is an argument of the specified method call.
	 */
	function isArgumentOfMethodCall(node, index, object, property) {
	    var parent = node.parent;
	    return (
	        parent.type === "CallExpression" &&
	        parent.callee.type === "MemberExpression" &&
	        parent.callee.computed === false &&
	        isIdentifier(parent.callee.object, object) &&
	        isIdentifier(parent.callee.property, property) &&
	        parent.arguments[index] === node
	    );
	}

	/**
	 * Checks whether or not a given node is a property descriptor.
	 * @param {ASTNode} node - A node to check.
	 * @returns {boolean} `true` if the node is a property descriptor.
	 */
	function isPropertyDescriptor(node) {
	    // Object.defineProperty(obj, "foo", {set: ...})
	    if (isArgumentOfMethodCall(node, 2, "Object", "defineProperty") ||
	        isArgumentOfMethodCall(node, 2, "Reflect", "defineProperty")
	    ) {
	        return true;
	    }

	    // Object.defineProperties(obj, {foo: {set: ...}})
	    // Object.create(proto, {foo: {set: ...}})
	    node = node.parent.parent;
	    return node.type === "ObjectExpression" && (
	        isArgumentOfMethodCall(node, 1, "Object", "create") ||
	        isArgumentOfMethodCall(node, 1, "Object", "defineProperties")
	    );
	}

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {
	    var config = context.options[0] || {};
	    var checkGetWithoutSet = config.getWithoutSet === true;
	    var checkSetWithoutGet = config.setWithoutGet !== false;

	    /**
	     * Checks a object expression to see if it has setter and getter both present or none.
	     * @param {ASTNode} node The node to check.
	     * @returns {void}
	     * @private
	     */
	    function checkLonelySetGet(node) {
	        var isSetPresent = false;
	        var isGetPresent = false;
	        var isDescriptor = isPropertyDescriptor(node);

	        for (var i = 0, end = node.properties.length; i < end; i++) {
	            var property = node.properties[i];

	            var propToCheck = "";
	            if (property.kind === "init") {
	                if (isDescriptor && !property.computed) {
	                    propToCheck = property.key.name;
	                }
	            } else {
	                propToCheck = property.kind;
	            }

	            switch (propToCheck) {
	                case "set":
	                    isSetPresent = true;
	                    break;

	                case "get":
	                    isGetPresent = true;
	                    break;

	                default:
	                    // Do nothing
	            }

	            if (isSetPresent && isGetPresent) {
	                break;
	            }
	        }

	        if (checkSetWithoutGet && isSetPresent && !isGetPresent) {
	            context.report(node, "Getter is not present");
	        } else if (checkGetWithoutSet && isGetPresent && !isSetPresent) {
	            context.report(node, "Setter is not present");
	        }
	    }

	    return {
	        "ObjectExpression": function(node) {
	            if (checkSetWithoutGet || checkGetWithoutSet) {
	                checkLonelySetGet(node);
	            }
	        }
	    };

	};

	module.exports.schema = [
	    {
	        "type": "object",
	        "properties": {
	            "getWithoutSet": {
	                "type": "boolean"
	            },
	            "setWithoutGet": {
	                "type": "boolean"
	            }
	        },
	        "additionalProperties": false
	    }
	];


/***/ },
/* 219 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to check for "block scoped" variables by binding context
	 * @author Matt DuVall <http://www.mattduvall.com>
	 * @copyright 2015 Toru Nagashima. All rights reserved.
	 * @copyright 2015 Mathieu M-Gosselin. All rights reserved.
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------

	/**
	 * Collects unresolved references from the global scope, then creates a map to references from its name.
	 * @param {RuleContext} context - The current context.
	 * @returns {object} A map object. Its key is the variable names. Its value is the references of each variable.
	 */
	function collectUnresolvedReferences(context) {
	    var unresolved = Object.create(null);
	    var references = context.getScope().through;

	    for (var i = 0; i < references.length; ++i) {
	        var reference = references[i];
	        var name = reference.identifier.name;

	        if (name in unresolved === false) {
	            unresolved[name] = [];
	        }
	        unresolved[name].push(reference);
	    }

	    return unresolved;
	}

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {
	    var unresolvedReferences = Object.create(null);
	    var stack = [];

	    /**
	     * Makes a block scope.
	     * @param {ASTNode} node - A node of a scope.
	     * @returns {void}
	     */
	    function enterScope(node) {
	        stack.push(node.range);
	    }

	    /**
	     * Pops the last block scope.
	     * @returns {void}
	     */
	    function exitScope() {
	        stack.pop();
	    }

	    /**
	     * Reports a given reference.
	     * @param {escope.Reference} reference - A reference to report.
	     * @returns {void}
	     */
	    function report(reference) {
	        var identifier = reference.identifier;
	        context.report(
	            identifier,
	            "\"{{name}}\" used outside of binding context.",
	            {name: identifier.name});
	    }

	    /**
	     * Finds and reports references which are outside of valid scopes.
	     * @param {ASTNode} node - A node to get variables.
	     * @returns {void}
	     */
	    function checkForVariables(node) {
	        if (node.kind !== "var") {
	            return;
	        }

	        var isGlobal = context.getScope().type === "global";

	        // Defines a predicate to check whether or not a given reference is outside of valid scope.
	        var scopeRange = stack[stack.length - 1];
	        function isOutsideOfScope(reference) {
	            var idRange = reference.identifier.range;
	            return idRange[0] < scopeRange[0] || idRange[1] > scopeRange[1];
	        }

	        // Gets declared variables, and checks its references.
	        var variables = context.getDeclaredVariables(node);
	        for (var i = 0; i < variables.length; ++i) {
	            var variable = variables[i];
	            var references = variable.references;

	            // Global variables are not resolved.
	            // In this case, use unresolved references.
	            if (isGlobal && variable.name in unresolvedReferences) {
	                references = unresolvedReferences[variable.name];
	            }

	            // Reports.
	            references.filter(isOutsideOfScope).forEach(report);
	        }
	    }

	    return {
	        "Program": function(node) {
	            unresolvedReferences = collectUnresolvedReferences(context);
	            stack = [node.range];
	        },

	        // Manages scopes.
	        "BlockStatement": enterScope,
	        "BlockStatement:exit": exitScope,
	        "ForStatement": enterScope,
	        "ForStatement:exit": exitScope,
	        "ForInStatement": enterScope,
	        "ForInStatement:exit": exitScope,
	        "ForOfStatement": enterScope,
	        "ForOfStatement:exit": exitScope,
	        "SwitchStatement": enterScope,
	        "SwitchStatement:exit": exitScope,
	        "CatchClause": enterScope,
	        "CatchClause:exit": exitScope,

	        // Finds and reports references which are outside of valid scope.
	        "VariableDeclaration": checkForVariables
	    };

	};

	module.exports.schema = [];


/***/ },
/* 220 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Counts the cyclomatic complexity of each function of the script. See http://en.wikipedia.org/wiki/Cyclomatic_complexity.
	 * Counts the number of if, conditional, for, whilte, try, switch/case,
	 * @author Patrick Brosset
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var THRESHOLD = context.options[0];

	    //--------------------------------------------------------------------------
	    // Helpers
	    //--------------------------------------------------------------------------

	    // Using a stack to store complexity (handling nested functions)
	    var fns = [];

	    // When parsing a new function, store it in our function stack
	    function startFunction() {
	        fns.push(1);
	    }

	    function endFunction(node) {
	        var complexity = fns.pop(),
	            name = "anonymous";

	        if (node.id) {
	            name = node.id.name;
	        } else if (node.parent.type === "MethodDefinition") {
	            name = node.parent.key.name;
	        }

	        if (complexity > THRESHOLD) {
	            context.report(node, "Function '{{name}}' has a complexity of {{complexity}}.", { name: name, complexity: complexity });
	        }
	    }

	    function increaseComplexity() {
	        if (fns.length) {
	            fns[fns.length - 1] ++;
	        }
	    }

	    function increaseSwitchComplexity(node) {
	        // Avoiding `default`
	        if (node.test) {
	            increaseComplexity(node);
	        }
	    }

	    function increaseLogicalComplexity(node) {
	        // Avoiding &&
	        if (node.operator === "||") {
	            increaseComplexity(node);
	        }
	    }

	    //--------------------------------------------------------------------------
	    // Public API
	    //--------------------------------------------------------------------------

	    return {
	        "FunctionDeclaration": startFunction,
	        "FunctionExpression": startFunction,
	        "ArrowFunctionExpression": startFunction,
	        "FunctionDeclaration:exit": endFunction,
	        "FunctionExpression:exit": endFunction,
	        "ArrowFunctionExpression:exit": endFunction,

	        "CatchClause": increaseComplexity,
	        "ConditionalExpression": increaseComplexity,
	        "LogicalExpression": increaseLogicalComplexity,
	        "ForStatement": increaseComplexity,
	        "ForInStatement": increaseComplexity,
	        "ForOfStatement": increaseComplexity,
	        "IfStatement": increaseComplexity,
	        "SwitchCase": increaseSwitchComplexity,
	        "WhileStatement": increaseComplexity,
	        "DoWhileStatement": increaseComplexity
	    };

	};

	module.exports.schema = [
	    {
	        "type": "integer"
	    }
	];


/***/ },
/* 221 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag consistent return values
	 * @author Nicholas C. Zakas
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var functions = [];

	    //--------------------------------------------------------------------------
	    // Helpers
	    //--------------------------------------------------------------------------

	    /**
	     * Marks entrance into a function by pushing a new object onto the functions
	     * stack.
	     * @returns {void}
	     * @private
	     */
	    function enterFunction() {
	        functions.push({});
	    }

	    /**
	     * Marks exit of a function by popping off the functions stack.
	     * @returns {void}
	     * @private
	     */
	    function exitFunction() {
	        functions.pop();
	    }


	    //--------------------------------------------------------------------------
	    // Public
	    //--------------------------------------------------------------------------

	    return {

	        "Program": enterFunction,
	        "FunctionDeclaration": enterFunction,
	        "FunctionExpression": enterFunction,
	        "ArrowFunctionExpression": enterFunction,

	        "Program:exit": exitFunction,
	        "FunctionDeclaration:exit": exitFunction,
	        "FunctionExpression:exit": exitFunction,
	        "ArrowFunctionExpression:exit": exitFunction,

	        "ReturnStatement": function(node) {

	            var returnInfo = functions[functions.length - 1],
	                returnTypeDefined = "type" in returnInfo;

	            if (returnTypeDefined) {

	                if (returnInfo.type !== !!node.argument) {
	                    context.report(node, "Expected " + (returnInfo.type ? "a" : "no") + " return value.");
	                }

	            } else {
	                returnInfo.type = !!node.argument;
	            }

	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 222 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag statements without curly braces
	 * @author Nicholas C. Zakas
	 * @copyright 2015 Ivan Nikulin. All rights reserved.
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var multiOnly = (context.options[0] === "multi");
	    var multiLine = (context.options[0] === "multi-line");
	    var multiOrNest = (context.options[0] === "multi-or-nest");

	    //--------------------------------------------------------------------------
	    // Helpers
	    //--------------------------------------------------------------------------

	    /**
	     * Determines if a given node is a one-liner that's on the same line as it's preceding code.
	     * @param {ASTNode} node The node to check.
	     * @returns {boolean} True if the node is a one-liner that's on the same line as it's preceding code.
	     * @private
	     */
	    function isCollapsedOneLiner(node) {
	        var before = context.getTokenBefore(node),
	            last = context.getLastToken(node);
	        return before.loc.start.line === last.loc.end.line;
	    }

	    /**
	     * Determines if a given node is a one-liner.
	     * @param {ASTNode} node The node to check.
	     * @returns {boolean} True if the node is a one-liner.
	     * @private
	     */
	    function isOneLiner(node) {
	        var first = context.getFirstToken(node),
	            last = context.getLastToken(node);

	        return first.loc.start.line === last.loc.end.line;
	    }

	    /**
	     * Reports "Expected { after ..." error
	     * @param {ASTNode} node The node to report.
	     * @param {string} name The name to report.
	     * @param {string} suffix Additional string to add to the end of a report.
	     * @returns {void}
	     * @private
	     */
	    function reportExpectedBraceError(node, name, suffix) {
	        context.report(node, "Expected { after '{{name}}'{{suffix}}.",
	            {
	                name: name,
	                suffix: (suffix ? " " + suffix : "")
	            });
	    }

	    /**
	     * Reports "Unnecessary { after ..." error
	     * @param {ASTNode} node The node to report.
	     * @param {string} name The name to report.
	     * @param {string} suffix Additional string to add to the end of a report.
	     * @returns {void}
	     * @private
	     */
	    function reportUnnecessaryBraceError(node, name, suffix) {
	        context.report(node, "Unnecessary { after '{{name}}'{{suffix}}.",
	            {
	                name: name,
	                suffix: (suffix ? " " + suffix : "")
	            }
	        );
	    }

	    /**
	     * Checks the body of a node to see if it's a block statement. Depending on
	     * the rule options, reports the appropriate problems.
	     * @param {ASTNode} node The node to report if there's a problem.
	     * @param {ASTNode} body The body node to check for blocks.
	     * @param {string} name The name to report if there's a problem.
	     * @param {string} suffix Additional string to add to the end of a report.
	     * @returns {void}
	     */
	    function checkBody(node, body, name, suffix) {
	        var hasBlock = (body.type === "BlockStatement");

	        if (multiOnly) {
	            if (hasBlock && body.body.length === 1) {
	                reportUnnecessaryBraceError(node, name, suffix);
	            }
	        } else if (multiLine) {
	            if (!hasBlock && !isCollapsedOneLiner(body)) {
	                reportExpectedBraceError(node, name, suffix);
	            }
	        } else if (multiOrNest) {
	            if (hasBlock && body.body.length === 1 && isOneLiner(body.body[0])) {
	                reportUnnecessaryBraceError(node, name, suffix);
	            } else if (!hasBlock && !isOneLiner(body)) {
	                reportExpectedBraceError(node, name, suffix);
	            }
	        } else {
	            if (!hasBlock) {
	                reportExpectedBraceError(node, name, suffix);
	            }
	        }
	    }

	    //--------------------------------------------------------------------------
	    // Public
	    //--------------------------------------------------------------------------

	    return {

	        "IfStatement": function(node) {

	            checkBody(node, node.consequent, "if", "condition");

	            if (node.alternate && node.alternate.type !== "IfStatement") {
	                checkBody(node, node.alternate, "else");
	            }

	        },

	        "WhileStatement": function(node) {
	            checkBody(node, node.body, "while", "condition");
	        },

	        "DoWhileStatement": function(node) {
	            checkBody(node, node.body, "do");
	        },

	        "ForStatement": function(node) {
	            checkBody(node, node.body, "for", "condition");
	        }
	    };

	};

	module.exports.schema = [
	    {
	        "enum": ["all", "multi", "multi-line", "multi-or-nest"]
	    }
	];


/***/ },
/* 223 */
/***/ function(module, exports) {

	/**
	 * @fileoverview require default case in switch statements
	 * @author Aliaksei Shytkin
	 */
	"use strict";

	var COMMENT_VALUE = "no default";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    //--------------------------------------------------------------------------
	    // Helpers
	    //--------------------------------------------------------------------------

	    /**
	     * Shortcut to get last element of array
	     * @param  {*[]} collection Array
	     * @returns {*} Last element
	     */
	    function last(collection) {
	        return collection[collection.length - 1];
	    }

	    //--------------------------------------------------------------------------
	    // Public
	    //--------------------------------------------------------------------------

	    return {

	        "SwitchStatement": function(node) {

	            if (!node.cases.length) {
	                // skip check of empty switch because there is no easy way
	                // to extract comments inside it now
	                return;
	            }

	            var hasDefault = node.cases.some(function(v) {
	                return v.test === null;
	            });

	            if (!hasDefault) {

	                var comment;
	                var comments;

	                var lastCase = last(node.cases);
	                comments = context.getComments(lastCase).trailing;

	                if (comments.length) {
	                    comment = last(comments);
	                }

	                if (!comment || comment.value.trim() !== COMMENT_VALUE) {
	                    context.report(node, "Expected a default case.");
	                }
	            }
	        }
	    };
	};

	module.exports.schema = [];


/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to warn about using dot notation instead of square bracket notation when possible.
	 * @author Josh Perez
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	var validIdentifier = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/;
	var keywords = __webpack_require__(225);

	module.exports = function(context) {
	    var options = context.options[0] || {};
	    var allowKeywords = options.allowKeywords === void 0 || !!options.allowKeywords;

	    var allowPattern;
	    if (options.allowPattern) {
	        allowPattern = new RegExp(options.allowPattern);
	    }

	    return {
	        "MemberExpression": function(node) {
	            if (
	                node.computed &&
	                node.property.type === "Literal" &&
	                validIdentifier.test(node.property.value) &&
	                (allowKeywords || keywords.indexOf("" + node.property.value) === -1)
	            ) {
	                if (!(allowPattern && allowPattern.test(node.property.value))) {
	                    context.report(node, "[" + JSON.stringify(node.property.value) + "] is better written in dot notation.");
	                }
	            }
	            if (
	                !allowKeywords &&
	                !node.computed &&
	                keywords.indexOf("" + node.property.name) !== -1
	            ) {
	                context.report(node, "." + node.property.name + " is a syntax error.");
	            }
	        }
	    };
	};

	module.exports.schema = [
	    {
	        "type": "object",
	        "properties": {
	            "allowKeywords": {
	                "type": "boolean"
	            },
	            "allowPattern": {
	                "type": "string"
	            }
	        },
	        "additionalProperties": false
	    }
	];


/***/ },
/* 225 */
/***/ function(module, exports) {

	/**
	 * @fileoverview A shared list of ES3 keywords.
	 * @author Josh Perez
	 * @copyright 2015 Jose Roberto Vidal. All rights reserved.
	 */
	"use strict";

	module.exports = [
	    "abstract",
	    "boolean",
	    "break",
	    "byte",
	    "case",
	    "catch",
	    "char",
	    "class",
	    "const",
	    "continue",
	    "debugger",
	    "default",
	    "delete",
	    "do",
	    "double",
	    "else",
	    "enum",
	    "export",
	    "extends",
	    "false",
	    "final",
	    "finally",
	    "float",
	    "for",
	    "function",
	    "goto",
	    "if",
	    "implements",
	    "import",
	    "in",
	    "instanceof",
	    "int",
	    "interface",
	    "long",
	    "native",
	    "new",
	    "null",
	    "package",
	    "private",
	    "protected",
	    "public",
	    "return",
	    "short",
	    "static",
	    "super",
	    "switch",
	    "synchronized",
	    "this",
	    "throw",
	    "throws",
	    "transient",
	    "true",
	    "try",
	    "typeof",
	    "var",
	    "void",
	    "volatile",
	    "while",
	    "with"
	];


/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Validates newlines before and after dots
	 * @author Greg Cochard
	 * @copyright 2015 Greg Cochard
	 */

	"use strict";

	var astUtils = __webpack_require__(177);

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var config = context.options[0],
	        // default to onObject if no preference is passed
	        onObject = config === "object" || !config;

	    /**
	     * Reports if the dot between object and property is on the correct loccation.
	     * @param {ASTNode} obj The object owning the property.
	     * @param {ASTNode} prop The property of the object.
	     * @param {ASTNode} node The corresponding node of the token.
	     * @returns {void}
	     */
	    function checkDotLocation(obj, prop, node) {
	        var dot = context.getTokenBefore(prop);

	        if (dot.type === "Punctuator" && dot.value === ".") {
	            if (onObject) {
	                if (!astUtils.isTokenOnSameLine(obj, dot)) {
	                    context.report(node, dot.loc.start, "Expected dot to be on same line as object.");
	                }
	            } else if (!astUtils.isTokenOnSameLine(dot, prop)) {
	                context.report(node, dot.loc.start, "Expected dot to be on same line as property.");
	            }
	        }
	    }

	    /**
	     * Checks the spacing of the dot within a member expression.
	     * @param {ASTNode} node The node to check.
	     * @returns {void}
	     */
	    function checkNode(node) {
	        checkDotLocation(node.object, node.property, node);
	    }

	    return {
	        "MemberExpression": checkNode
	    };
	};

	module.exports.schema = [
	    {
	        "enum": ["object", "property"]
	    }
	];


/***/ },
/* 227 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag statements that use != and == instead of !== and ===
	 * @author Nicholas C. Zakas
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    /**
	     * Checks if an expression is a typeof expression
	     * @param  {ASTNode} node The node to check
	     * @returns {boolean} if the node is a typeof expression
	     */
	    function isTypeOf(node) {
	        return node.type === "UnaryExpression" && node.operator === "typeof";
	    }

	    /**
	     * Checks if either operand of a binary expression is a typeof operation
	     * @param {ASTNode} node The node to check
	     * @returns {boolean} if one of the operands is typeof
	     * @private
	     */
	    function isTypeOfBinary(node) {
	        return isTypeOf(node.left) || isTypeOf(node.right);
	    }

	    /**
	     * Checks if operands are literals of the same type (via typeof)
	     * @param {ASTNode} node The node to check
	     * @returns {boolean} if operands are of same type
	     * @private
	     */
	    function areLiteralsAndSameType(node) {
	        return node.left.type === "Literal" && node.right.type === "Literal" &&
	                typeof node.left.value === typeof node.right.value;
	    }

	    /**
	     * Checks if one of the operands is a literal null
	     * @param {ASTNode} node The node to check
	     * @returns {boolean} if operands are null
	     * @private
	     */
	    function isNullCheck(node) {
	        return (node.right.type === "Literal" && node.right.value === null) ||
	                (node.left.type === "Literal" && node.left.value === null);
	    }

	    /**
	     * Gets the location (line and column) of the binary expression's operator
	     * @param {ASTNode} node The binary expression node to check
	     * @param {String} operator The operator to find
	     * @returns {Object} { line, column } location of operator
	     * @private
	     */
	    function getOperatorLocation(node) {
	        var opToken = context.getTokenAfter(node.left);
	        return {line: opToken.loc.start.line, column: opToken.loc.start.column};
	    }

	    return {
	        "BinaryExpression": function(node) {
	            if (node.operator !== "==" && node.operator !== "!=") {
	                return;
	            }

	            if (context.options[0] === "smart" && (isTypeOfBinary(node) ||
	                    areLiteralsAndSameType(node)) || isNullCheck(node)) {
	                return;
	            }

	            if (context.options[0] === "allow-null" && isNullCheck(node)) {
	                return;
	            }

	            context.report(
	                node, getOperatorLocation(node),
	                "Expected '{{op}}=' and instead saw '{{op}}'.",
	                {op: node.operator}
	            );
	        }
	    };

	};

	module.exports.schema = [
	    {
	        "enum": ["smart", "allow-null"]
	    }
	];


/***/ },
/* 228 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag for-in loops without if statements inside
	 * @author Nicholas C. Zakas
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {

	        "ForInStatement": function(node) {

	            /*
	             * If the for-in statement has {}, then the real body is the body
	             * of the BlockStatement. Otherwise, just use body as provided.
	             */
	            var body = node.body.type === "BlockStatement" ? node.body.body[0] : node.body;

	            if (body && body.type !== "IfStatement") {
	                context.report(node, "The body of a for-in should be wrapped in an if statement to filter unwanted properties from the prototype.");
	            }
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 229 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag use of alert, confirm, prompt
	 * @author Nicholas C. Zakas
	 * @copyright 2015 Mathias Schreck
	 * @copyright 2013 Nicholas C. Zakas
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------

	/**
	 * Checks if the given name is a prohibited identifier.
	 * @param {string} name The name to check
	 * @returns {boolean} Whether or not the name is prohibited.
	 */
	function isProhibitedIdentifier(name) {
	    return /^(alert|confirm|prompt)$/.test(name);
	}

	/**
	 * Reports the given node and identifier name.
	 * @param {RuleContext} context The ESLint rule context.
	 * @param {ASTNode} node The node to report on.
	 * @param {string} identifierName The name of the identifier.
	 * @returns {void}
	 */
	function report(context, node, identifierName) {
	    context.report(node, "Unexpected {{name}}.", { name: identifierName });
	}

	/**
	 * Returns the property name of a MemberExpression.
	 * @param {ASTNode} memberExpressionNode The MemberExpression node.
	 * @returns {string|undefined} Returns the property name if available, undefined else.
	 */
	function getPropertyName(memberExpressionNode) {
	    if (memberExpressionNode.computed) {
	        if (memberExpressionNode.property.type === "Literal") {
	            return memberExpressionNode.property.value;
	        }
	    } else {
	        return memberExpressionNode.property.name;
	    }
	}

	/**
	 * Finds the escope reference in the given scope.
	 * @param {Object} scope The scope to search.
	 * @param {ASTNode} node The identifier node.
	 * @returns {Reference|undefined} Returns the found reference or undefined if none were found.
	 */
	function findReference(scope, node) {
	    var references = scope.references.filter(function(reference) {
	        return reference.identifier.range[0] === node.range[0] &&
	            reference.identifier.range[1] === node.range[1];
	    });

	    if (references.length === 1) {
	        return references[0];
	    }
	}

	/**
	 * Checks if the given identifier name is shadowed in the given global scope.
	 * @param {Object} globalScope The global scope.
	 * @param {string} identifierName The identifier name to check
	 * @returns {boolean} Whether or not the name is shadowed globally.
	 */
	function isGloballyShadowed(globalScope, identifierName) {
	    return globalScope.variables.some(function(variable) {
	        return variable.name === identifierName && variable.defs.length > 0;
	    });
	}

	/**
	 * Checks if the given identifier node is shadowed in the given scope.
	 * @param {Object} scope The current scope.
	 * @param {Object} globalScope The global scope.
	 * @param {string} node The identifier node to check
	 * @returns {boolean} Whether or not the name is shadowed.
	 */
	function isShadowed(scope, globalScope, node) {
	    var reference = findReference(scope, node),
	        identifierName = node.name;

	    if (reference) {
	        if (reference.resolved || isGloballyShadowed(globalScope, identifierName)) {
	            return true;
	        }
	    }

	    return false;
	}

	/**
	 * Checks if the given identifier node is a ThisExpression in the global scope or the global window property.
	 * @param {Object} scope The current scope.
	 * @param {Object} globalScope The global scope.
	 * @param {string} node The identifier node to check
	 * @returns {boolean} Whether or not the node is a reference to the global object.
	 */
	function isGlobalThisReferenceOrGlobalWindow(scope, globalScope, node) {
	    if (scope.type === "global" && node.type === "ThisExpression") {
	        return true;
	    } else if (node.name === "window") {
	        return !isShadowed(scope, globalScope, node);
	    }

	    return false;
	}

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {
	    var globalScope;

	    return {

	        "Program": function() {
	            globalScope = context.getScope();
	        },

	        "CallExpression": function(node) {
	            var callee = node.callee,
	                identifierName,
	                currentScope = context.getScope();

	            // without window.
	            if (callee.type === "Identifier") {
	                identifierName = callee.name;

	                if (!isShadowed(currentScope, globalScope, callee) && isProhibitedIdentifier(callee.name)) {
	                    report(context, node, identifierName);
	                }

	            } else if (callee.type === "MemberExpression" && isGlobalThisReferenceOrGlobalWindow(currentScope, globalScope, callee.object)) {
	                identifierName = getPropertyName(callee);

	                if (isProhibitedIdentifier(identifierName)) {
	                    report(context, node, identifierName);
	                }
	            }

	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 230 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag use of arguments.callee and arguments.caller.
	 * @author Nicholas C. Zakas
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {

	        "MemberExpression": function(node) {
	            var objectName = node.object.name,
	                propertyName = node.property.name;

	            if (objectName === "arguments" && !node.computed && propertyName && propertyName.match(/^calle[er]$/)) {
	                context.report(node, "Avoid arguments.{{property}}.", { property: propertyName });
	            }

	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 231 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to check for ambiguous div operator in regexes
	 * @author Matt DuVall <http://www.mattduvall.com>
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {

	        "Literal": function(node) {
	            var token = context.getFirstToken(node);

	            if (token.type === "RegularExpression" && token.value[1] === "=") {
	                context.report(node, "A regular expression literal can be confused with '/='.");
	            }
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 232 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag `else` after a `return` in `if`
	 * @author Ian Christian Myers
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    //--------------------------------------------------------------------------
	    // Helpers
	    //--------------------------------------------------------------------------

	    /**
	     * Display the context report if rule is violated
	     *
	     * @param {Node} node The 'else' node
	     * @returns {void}
	     */
	    function displayReport(node) {
	        context.report(node, "Unexpected 'else' after 'return'.");
	    }

	    /**
	     * Check to see if the node is a ReturnStatement
	     *
	     * @param {Node} node The node being evaluated
	     * @returns {boolean} True if node is a return
	     */
	    function checkForReturn(node) {
	        return node.type === "ReturnStatement";
	    }

	    /**
	     * Naive return checking, does not iterate through the whole
	     * BlockStatement because we make the assumption that the ReturnStatement
	     * will be the last node in the body of the BlockStatement.
	     *
	     * @param {Node} node The consequent/alternate node
	     * @returns {boolean} True if it has a return
	     */
	    function naiveHasReturn(node) {
	        if (node.type === "BlockStatement") {
	            var body = node.body,
	                lastChildNode = body[body.length - 1];

	            return lastChildNode && checkForReturn(lastChildNode);
	        }
	        return checkForReturn(node);
	    }

	    /**
	     * Check to see if the node is valid for evaluation,
	     * meaning it has an else and not an else-if
	     *
	     * @param {Node} node The node being evaluated
	     * @returns {boolean} True if the node is valid
	     */
	    function hasElse(node) {
	        return node.alternate && node.consequent && node.alternate.type !== "IfStatement";
	    }

	    /**
	     * If the consequent is an IfStatement, check to see if it has an else
	     * and both its consequent and alternate path return, meaning this is
	     * a nested case of rule violation.  If-Else not considered currently.
	     *
	     * @param {Node} node The consequent node
	     * @returns {boolean} True if this is a nested rule violation
	     */
	    function checkForIf(node) {
	        return node.type === "IfStatement" && hasElse(node) &&
	            naiveHasReturn(node.alternate) && naiveHasReturn(node.consequent);
	    }

	    /**
	     * Check the consequent/body node to make sure it is not
	     * a ReturnStatement or an IfStatement that returns on both
	     * code paths.
	     *
	     * @param {Node} node The consequent or body node
	     * @param {Node} alternate The alternate node
	     * @returns {boolean} `true` if it is a Return/If node that always returns.
	     */
	    function checkForReturnOrIf(node) {
	        return checkForReturn(node) || checkForIf(node);
	    }


	    /**
	     * Check whether a node returns in every codepath.
	     * @param {Node} node The node to be checked
	     * @returns {boolean} `true` if it returns on every codepath.
	     */
	    function alwaysReturns(node) {
	        // If we have a BlockStatement, check each consequent body node.
	        if (node.type === "BlockStatement") {
	            return node.body.some(checkForReturnOrIf);
	        // If not a block statement, make sure the consequent isn't a ReturnStatement
	        // or an IfStatement with returns on both paths
	        } else {
	            return checkForReturnOrIf(node);
	        }
	    }

	    //--------------------------------------------------------------------------
	    // Public API
	    //--------------------------------------------------------------------------

	    return {

	        "IfStatement": function(node) {
	            var parent = context.getAncestors().pop(),
	                consequents,
	                alternate;

	            // Only "top-level" if statements are checked, meaning the first `if`
	            // in a `if-else-if-...` chain.
	            if (parent.type === "IfStatement" && parent.alternate === node) {
	                return;
	            }

	            for (consequents = []; node.type === "IfStatement"; node = node.alternate) {
	                if (!node.alternate) {
	                    return;
	                }
	                consequents.push(node.consequent);
	                alternate = node.alternate;
	            }

	            if (consequents.every(alwaysReturns)) {
	                displayReport(alternate);
	            }
	        }

	    };

	};

	module.exports.schema = [];


/***/ },
/* 233 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag when label is not used for a loop or switch
	 * @author Ilya Volodin
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {

	        "LabeledStatement": function(node) {
	            var type = node.body.type;

	            if (type !== "ForStatement" && type !== "WhileStatement" && type !== "DoWhileStatement" && type !== "SwitchStatement" && type !== "ForInStatement" && type !== "ForOfStatement") {
	                context.report(node, "Unexpected label {{l}}", {l: node.label.name});
	            }
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 234 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag comparisons to null without a type-checking
	 * operator.
	 * @author Ian Christian Myers
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {

	        "BinaryExpression": function(node) {
	            var badOperator = node.operator === "==" || node.operator === "!=";

	            if (node.right.type === "Literal" && node.right.raw === "null" && badOperator ||
	                    node.left.type === "Literal" && node.left.raw === "null" && badOperator) {
	                context.report(node, "Use === to compare with null.");
	            }
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 235 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag use of eval() statement
	 * @author Nicholas C. Zakas
	 * @copyright 2015 Mathias Schreck. All rights reserved.
	 * @copyright 2013 Nicholas C. Zakas. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {
	        "CallExpression": function(node) {
	            if (node.callee.name === "eval") {
	                context.report(node, "eval can be harmful.");
	            }
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to flag adding properties to native object's prototypes.
	 * @author David Nelson
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------

	var globals = __webpack_require__(237);

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var config = context.options[0] || {};
	    var exceptions = config.exceptions || [];
	    var modifiedBuiltins = Object.keys(globals.builtin).filter(function(builtin) {
	        return builtin[0].toUpperCase() === builtin[0];
	    });

	    if (exceptions.length) {
	        modifiedBuiltins = modifiedBuiltins.filter(function(builtIn) {
	            return exceptions.indexOf(builtIn) === -1;
	        });
	    }

	    return {

	        // handle the Array.prototype.extra style case
	        "AssignmentExpression": function(node) {
	            var lhs = node.left, affectsProto;

	            if (lhs.type !== "MemberExpression" || lhs.object.type !== "MemberExpression") {
	                return;
	            }

	            affectsProto = lhs.object.computed ?
	                lhs.object.property.type === "Literal" && lhs.object.property.value === "prototype" :
	                lhs.object.property.name === "prototype";

	            if (!affectsProto) {
	                return;
	            }

	            modifiedBuiltins.forEach(function(builtin) {
	                if (lhs.object.object.name === builtin) {
	                    context.report(node, builtin + " prototype is read only, properties should not be added.");
	                }
	            });
	        },

	        // handle the Object.defineProperty(Array.prototype) case
	        "CallExpression": function(node) {

	            var callee = node.callee,
	                subject,
	                object;

	            // only worry about Object.defineProperty
	            if (callee.type === "MemberExpression" &&
	                callee.object.name === "Object" &&
	                callee.property.name === "defineProperty") {

	                // verify the object being added to is a native prototype
	                subject = node.arguments[0];
	                object = subject.object;

	                if (object &&
	                    object.type === "Identifier" &&
	                    (modifiedBuiltins.indexOf(object.name) > -1) &&
	                    subject.property.name === "prototype") {

	                    context.report(node, object.name + " prototype is read only, properties should not be added.");
	                }
	            }

	        }
	    };

	};

	module.exports.schema = [
	    {
	        "type": "object",
	        "properties": {
	            "exceptions": {
	                "type": "array",
	                "items": {
	                    "type": "string"
	                },
	                "uniqueItems": true
	            }
	        },
	        "additionalProperties": false
	    }
	];


/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(238);


/***/ },
/* 238 */
/***/ function(module, exports) {

	module.exports = {
		"builtin": {
			"Array": false,
			"ArrayBuffer": false,
			"Boolean": false,
			"constructor": false,
			"DataView": false,
			"Date": false,
			"decodeURI": false,
			"decodeURIComponent": false,
			"encodeURI": false,
			"encodeURIComponent": false,
			"Error": false,
			"escape": false,
			"eval": false,
			"EvalError": false,
			"Float32Array": false,
			"Float64Array": false,
			"Function": false,
			"hasOwnProperty": false,
			"Infinity": false,
			"Int16Array": false,
			"Int32Array": false,
			"Int8Array": false,
			"isFinite": false,
			"isNaN": false,
			"isPrototypeOf": false,
			"JSON": false,
			"Map": false,
			"Math": false,
			"NaN": false,
			"Number": false,
			"Object": false,
			"parseFloat": false,
			"parseInt": false,
			"Promise": false,
			"propertyIsEnumerable": false,
			"Proxy": false,
			"RangeError": false,
			"ReferenceError": false,
			"Reflect": false,
			"RegExp": false,
			"Set": false,
			"String": false,
			"Symbol": false,
			"SyntaxError": false,
			"System": false,
			"toLocaleString": false,
			"toString": false,
			"TypeError": false,
			"Uint16Array": false,
			"Uint32Array": false,
			"Uint8Array": false,
			"Uint8ClampedArray": false,
			"undefined": false,
			"unescape": false,
			"URIError": false,
			"valueOf": false,
			"WeakMap": false,
			"WeakSet": false
		},
		"browser": {
			"addEventListener": false,
			"alert": false,
			"AnalyserNode": false,
			"AnimationEvent": false,
			"applicationCache": false,
			"ApplicationCache": false,
			"ApplicationCacheErrorEvent": false,
			"atob": false,
			"Attr": false,
			"Audio": false,
			"AudioBuffer": false,
			"AudioBufferSourceNode": false,
			"AudioContext": false,
			"AudioDestinationNode": false,
			"AudioListener": false,
			"AudioNode": false,
			"AudioParam": false,
			"AudioProcessingEvent": false,
			"AutocompleteErrorEvent": false,
			"BarProp": false,
			"BatteryManager": false,
			"BeforeUnloadEvent": false,
			"BiquadFilterNode": false,
			"Blob": false,
			"blur": false,
			"btoa": false,
			"Cache": false,
			"caches": false,
			"CacheStorage": false,
			"cancelAnimationFrame": false,
			"CanvasGradient": false,
			"CanvasPattern": false,
			"CanvasRenderingContext2D": false,
			"CDATASection": false,
			"ChannelMergerNode": false,
			"ChannelSplitterNode": false,
			"CharacterData": false,
			"clearInterval": false,
			"clearTimeout": false,
			"clientInformation": false,
			"ClientRect": false,
			"ClientRectList": false,
			"ClipboardEvent": false,
			"close": false,
			"closed": false,
			"CloseEvent": false,
			"Comment": false,
			"CompositionEvent": false,
			"confirm": false,
			"console": false,
			"ConvolverNode": false,
			"crypto": false,
			"Crypto": false,
			"CryptoKey": false,
			"CSS": false,
			"CSSFontFaceRule": false,
			"CSSImportRule": false,
			"CSSKeyframeRule": false,
			"CSSKeyframesRule": false,
			"CSSMediaRule": false,
			"CSSPageRule": false,
			"CSSRule": false,
			"CSSRuleList": false,
			"CSSStyleDeclaration": false,
			"CSSStyleRule": false,
			"CSSStyleSheet": false,
			"CSSSupportsRule": false,
			"CSSUnknownRule": false,
			"CSSViewportRule": false,
			"CustomEvent": false,
			"DataTransfer": false,
			"DataTransferItem": false,
			"DataTransferItemList": false,
			"Debug": false,
			"defaultStatus": false,
			"defaultstatus": false,
			"DelayNode": false,
			"DeviceMotionEvent": false,
			"DeviceOrientationEvent": false,
			"devicePixelRatio": false,
			"dispatchEvent": false,
			"document": false,
			"Document": false,
			"DocumentFragment": false,
			"DocumentType": false,
			"DOMError": false,
			"DOMException": false,
			"DOMImplementation": false,
			"DOMParser": false,
			"DOMSettableTokenList": false,
			"DOMStringList": false,
			"DOMStringMap": false,
			"DOMTokenList": false,
			"DragEvent": false,
			"DynamicsCompressorNode": false,
			"Element": false,
			"ElementTimeControl": false,
			"ErrorEvent": false,
			"event": false,
			"Event": false,
			"EventSource": false,
			"EventTarget": false,
			"external": false,
			"fetch": false,
			"File": false,
			"FileError": false,
			"FileList": false,
			"FileReader": false,
			"find": false,
			"focus": false,
			"FocusEvent": false,
			"FontFace": false,
			"FormData": false,
			"frameElement": false,
			"frames": false,
			"GainNode": false,
			"Gamepad": false,
			"GamepadButton": false,
			"GamepadEvent": false,
			"getComputedStyle": false,
			"getSelection": false,
			"HashChangeEvent": false,
			"Headers": false,
			"history": false,
			"History": false,
			"HTMLAllCollection": false,
			"HTMLAnchorElement": false,
			"HTMLAppletElement": false,
			"HTMLAreaElement": false,
			"HTMLAudioElement": false,
			"HTMLBaseElement": false,
			"HTMLBlockquoteElement": false,
			"HTMLBodyElement": false,
			"HTMLBRElement": false,
			"HTMLButtonElement": false,
			"HTMLCanvasElement": false,
			"HTMLCollection": false,
			"HTMLContentElement": false,
			"HTMLDataListElement": false,
			"HTMLDetailsElement": false,
			"HTMLDialogElement": false,
			"HTMLDirectoryElement": false,
			"HTMLDivElement": false,
			"HTMLDListElement": false,
			"HTMLDocument": false,
			"HTMLElement": false,
			"HTMLEmbedElement": false,
			"HTMLFieldSetElement": false,
			"HTMLFontElement": false,
			"HTMLFormControlsCollection": false,
			"HTMLFormElement": false,
			"HTMLFrameElement": false,
			"HTMLFrameSetElement": false,
			"HTMLHeadElement": false,
			"HTMLHeadingElement": false,
			"HTMLHRElement": false,
			"HTMLHtmlElement": false,
			"HTMLIFrameElement": false,
			"HTMLImageElement": false,
			"HTMLInputElement": false,
			"HTMLIsIndexElement": false,
			"HTMLKeygenElement": false,
			"HTMLLabelElement": false,
			"HTMLLayerElement": false,
			"HTMLLegendElement": false,
			"HTMLLIElement": false,
			"HTMLLinkElement": false,
			"HTMLMapElement": false,
			"HTMLMarqueeElement": false,
			"HTMLMediaElement": false,
			"HTMLMenuElement": false,
			"HTMLMetaElement": false,
			"HTMLMeterElement": false,
			"HTMLModElement": false,
			"HTMLObjectElement": false,
			"HTMLOListElement": false,
			"HTMLOptGroupElement": false,
			"HTMLOptionElement": false,
			"HTMLOptionsCollection": false,
			"HTMLOutputElement": false,
			"HTMLParagraphElement": false,
			"HTMLParamElement": false,
			"HTMLPictureElement": false,
			"HTMLPreElement": false,
			"HTMLProgressElement": false,
			"HTMLQuoteElement": false,
			"HTMLScriptElement": false,
			"HTMLSelectElement": false,
			"HTMLShadowElement": false,
			"HTMLSourceElement": false,
			"HTMLSpanElement": false,
			"HTMLStyleElement": false,
			"HTMLTableCaptionElement": false,
			"HTMLTableCellElement": false,
			"HTMLTableColElement": false,
			"HTMLTableElement": false,
			"HTMLTableRowElement": false,
			"HTMLTableSectionElement": false,
			"HTMLTemplateElement": false,
			"HTMLTextAreaElement": false,
			"HTMLTitleElement": false,
			"HTMLTrackElement": false,
			"HTMLUListElement": false,
			"HTMLUnknownElement": false,
			"HTMLVideoElement": false,
			"IDBCursor": false,
			"IDBCursorWithValue": false,
			"IDBDatabase": false,
			"IDBEnvironment": false,
			"IDBFactory": false,
			"IDBIndex": false,
			"IDBKeyRange": false,
			"IDBObjectStore": false,
			"IDBOpenDBRequest": false,
			"IDBRequest": false,
			"IDBTransaction": false,
			"IDBVersionChangeEvent": false,
			"Image": false,
			"ImageBitmap": false,
			"ImageData": false,
			"indexedDB": false,
			"innerHeight": false,
			"innerWidth": false,
			"InputEvent": false,
			"InputMethodContext": false,
			"Intl": false,
			"KeyboardEvent": false,
			"length": false,
			"localStorage": false,
			"location": false,
			"Location": false,
			"locationbar": false,
			"matchMedia": false,
			"MediaElementAudioSourceNode": false,
			"MediaEncryptedEvent": false,
			"MediaError": false,
			"MediaKeyError": false,
			"MediaKeyEvent": false,
			"MediaKeyMessageEvent": false,
			"MediaKeys": false,
			"MediaKeySession": false,
			"MediaKeyStatusMap": false,
			"MediaKeySystemAccess": false,
			"MediaList": false,
			"MediaQueryList": false,
			"MediaQueryListEvent": false,
			"MediaSource": false,
			"MediaStreamAudioDestinationNode": false,
			"MediaStreamAudioSourceNode": false,
			"MediaStreamEvent": false,
			"MediaStreamTrack": false,
			"menubar": false,
			"MessageChannel": false,
			"MessageEvent": false,
			"MessagePort": false,
			"MIDIAccess": false,
			"MIDIConnectionEvent": false,
			"MIDIInput": false,
			"MIDIInputMap": false,
			"MIDIMessageEvent": false,
			"MIDIOutput": false,
			"MIDIOutputMap": false,
			"MIDIPort": false,
			"MimeType": false,
			"MimeTypeArray": false,
			"MouseEvent": false,
			"moveBy": false,
			"moveTo": false,
			"MutationEvent": false,
			"MutationObserver": false,
			"MutationRecord": false,
			"name": false,
			"NamedNodeMap": false,
			"navigator": false,
			"Navigator": false,
			"Node": false,
			"NodeFilter": false,
			"NodeIterator": false,
			"NodeList": false,
			"Notification": false,
			"OfflineAudioCompletionEvent": false,
			"OfflineAudioContext": false,
			"offscreenBuffering": false,
			"onbeforeunload": true,
			"onblur": true,
			"onerror": true,
			"onfocus": true,
			"onload": true,
			"onresize": true,
			"onunload": true,
			"open": false,
			"openDatabase": false,
			"opener": false,
			"opera": false,
			"Option": false,
			"OscillatorNode": false,
			"outerHeight": false,
			"outerWidth": false,
			"PageTransitionEvent": false,
			"pageXOffset": false,
			"pageYOffset": false,
			"parent": false,
			"Path2D": false,
			"performance": false,
			"Performance": false,
			"PerformanceEntry": false,
			"PerformanceMark": false,
			"PerformanceMeasure": false,
			"PerformanceNavigation": false,
			"PerformanceResourceTiming": false,
			"PerformanceTiming": false,
			"PeriodicWave": false,
			"Permissions": false,
			"PermissionStatus": false,
			"personalbar": false,
			"Plugin": false,
			"PluginArray": false,
			"PopStateEvent": false,
			"postMessage": false,
			"print": false,
			"ProcessingInstruction": false,
			"ProgressEvent": false,
			"prompt": false,
			"PushManager": false,
			"PushSubscription": false,
			"RadioNodeList": false,
			"Range": false,
			"ReadableByteStream": false,
			"ReadableStream": false,
			"removeEventListener": false,
			"Request": false,
			"requestAnimationFrame": false,
			"resizeBy": false,
			"resizeTo": false,
			"Response": false,
			"RTCIceCandidate": false,
			"RTCSessionDescription": false,
			"screen": false,
			"Screen": false,
			"screenLeft": false,
			"ScreenOrientation": false,
			"screenTop": false,
			"screenX": false,
			"screenY": false,
			"ScriptProcessorNode": false,
			"scroll": false,
			"scrollbars": false,
			"scrollBy": false,
			"scrollTo": false,
			"scrollX": false,
			"scrollY": false,
			"SecurityPolicyViolationEvent": false,
			"Selection": false,
			"self": false,
			"ServiceWorker": false,
			"ServiceWorkerContainer": false,
			"ServiceWorkerRegistration": false,
			"sessionStorage": false,
			"setInterval": false,
			"setTimeout": false,
			"ShadowRoot": false,
			"SharedWorker": false,
			"showModalDialog": false,
			"speechSynthesis": false,
			"SpeechSynthesisEvent": false,
			"SpeechSynthesisUtterance": false,
			"status": false,
			"statusbar": false,
			"stop": false,
			"Storage": false,
			"StorageEvent": false,
			"styleMedia": false,
			"StyleSheet": false,
			"StyleSheetList": false,
			"SubtleCrypto": false,
			"SVGAElement": false,
			"SVGAltGlyphDefElement": false,
			"SVGAltGlyphElement": false,
			"SVGAltGlyphItemElement": false,
			"SVGAngle": false,
			"SVGAnimateColorElement": false,
			"SVGAnimatedAngle": false,
			"SVGAnimatedBoolean": false,
			"SVGAnimatedEnumeration": false,
			"SVGAnimatedInteger": false,
			"SVGAnimatedLength": false,
			"SVGAnimatedLengthList": false,
			"SVGAnimatedNumber": false,
			"SVGAnimatedNumberList": false,
			"SVGAnimatedPathData": false,
			"SVGAnimatedPoints": false,
			"SVGAnimatedPreserveAspectRatio": false,
			"SVGAnimatedRect": false,
			"SVGAnimatedString": false,
			"SVGAnimatedTransformList": false,
			"SVGAnimateElement": false,
			"SVGAnimateMotionElement": false,
			"SVGAnimateTransformElement": false,
			"SVGAnimationElement": false,
			"SVGCircleElement": false,
			"SVGClipPathElement": false,
			"SVGColor": false,
			"SVGColorProfileElement": false,
			"SVGColorProfileRule": false,
			"SVGComponentTransferFunctionElement": false,
			"SVGCSSRule": false,
			"SVGCursorElement": false,
			"SVGDefsElement": false,
			"SVGDescElement": false,
			"SVGDiscardElement": false,
			"SVGDocument": false,
			"SVGElement": false,
			"SVGElementInstance": false,
			"SVGElementInstanceList": false,
			"SVGEllipseElement": false,
			"SVGEvent": false,
			"SVGExternalResourcesRequired": false,
			"SVGFEBlendElement": false,
			"SVGFEColorMatrixElement": false,
			"SVGFEComponentTransferElement": false,
			"SVGFECompositeElement": false,
			"SVGFEConvolveMatrixElement": false,
			"SVGFEDiffuseLightingElement": false,
			"SVGFEDisplacementMapElement": false,
			"SVGFEDistantLightElement": false,
			"SVGFEDropShadowElement": false,
			"SVGFEFloodElement": false,
			"SVGFEFuncAElement": false,
			"SVGFEFuncBElement": false,
			"SVGFEFuncGElement": false,
			"SVGFEFuncRElement": false,
			"SVGFEGaussianBlurElement": false,
			"SVGFEImageElement": false,
			"SVGFEMergeElement": false,
			"SVGFEMergeNodeElement": false,
			"SVGFEMorphologyElement": false,
			"SVGFEOffsetElement": false,
			"SVGFEPointLightElement": false,
			"SVGFESpecularLightingElement": false,
			"SVGFESpotLightElement": false,
			"SVGFETileElement": false,
			"SVGFETurbulenceElement": false,
			"SVGFilterElement": false,
			"SVGFilterPrimitiveStandardAttributes": false,
			"SVGFitToViewBox": false,
			"SVGFontElement": false,
			"SVGFontFaceElement": false,
			"SVGFontFaceFormatElement": false,
			"SVGFontFaceNameElement": false,
			"SVGFontFaceSrcElement": false,
			"SVGFontFaceUriElement": false,
			"SVGForeignObjectElement": false,
			"SVGGElement": false,
			"SVGGeometryElement": false,
			"SVGGlyphElement": false,
			"SVGGlyphRefElement": false,
			"SVGGradientElement": false,
			"SVGGraphicsElement": false,
			"SVGHKernElement": false,
			"SVGICCColor": false,
			"SVGImageElement": false,
			"SVGLangSpace": false,
			"SVGLength": false,
			"SVGLengthList": false,
			"SVGLinearGradientElement": false,
			"SVGLineElement": false,
			"SVGLocatable": false,
			"SVGMarkerElement": false,
			"SVGMaskElement": false,
			"SVGMatrix": false,
			"SVGMetadataElement": false,
			"SVGMissingGlyphElement": false,
			"SVGMPathElement": false,
			"SVGNumber": false,
			"SVGNumberList": false,
			"SVGPaint": false,
			"SVGPathElement": false,
			"SVGPathSeg": false,
			"SVGPathSegArcAbs": false,
			"SVGPathSegArcRel": false,
			"SVGPathSegClosePath": false,
			"SVGPathSegCurvetoCubicAbs": false,
			"SVGPathSegCurvetoCubicRel": false,
			"SVGPathSegCurvetoCubicSmoothAbs": false,
			"SVGPathSegCurvetoCubicSmoothRel": false,
			"SVGPathSegCurvetoQuadraticAbs": false,
			"SVGPathSegCurvetoQuadraticRel": false,
			"SVGPathSegCurvetoQuadraticSmoothAbs": false,
			"SVGPathSegCurvetoQuadraticSmoothRel": false,
			"SVGPathSegLinetoAbs": false,
			"SVGPathSegLinetoHorizontalAbs": false,
			"SVGPathSegLinetoHorizontalRel": false,
			"SVGPathSegLinetoRel": false,
			"SVGPathSegLinetoVerticalAbs": false,
			"SVGPathSegLinetoVerticalRel": false,
			"SVGPathSegList": false,
			"SVGPathSegMovetoAbs": false,
			"SVGPathSegMovetoRel": false,
			"SVGPatternElement": false,
			"SVGPoint": false,
			"SVGPointList": false,
			"SVGPolygonElement": false,
			"SVGPolylineElement": false,
			"SVGPreserveAspectRatio": false,
			"SVGRadialGradientElement": false,
			"SVGRect": false,
			"SVGRectElement": false,
			"SVGRenderingIntent": false,
			"SVGScriptElement": false,
			"SVGSetElement": false,
			"SVGStopElement": false,
			"SVGStringList": false,
			"SVGStylable": false,
			"SVGStyleElement": false,
			"SVGSVGElement": false,
			"SVGSwitchElement": false,
			"SVGSymbolElement": false,
			"SVGTests": false,
			"SVGTextContentElement": false,
			"SVGTextElement": false,
			"SVGTextPathElement": false,
			"SVGTextPositioningElement": false,
			"SVGTitleElement": false,
			"SVGTransform": false,
			"SVGTransformable": false,
			"SVGTransformList": false,
			"SVGTRefElement": false,
			"SVGTSpanElement": false,
			"SVGUnitTypes": false,
			"SVGURIReference": false,
			"SVGUseElement": false,
			"SVGViewElement": false,
			"SVGViewSpec": false,
			"SVGVKernElement": false,
			"SVGZoomAndPan": false,
			"SVGZoomEvent": false,
			"Text": false,
			"TextDecoder": false,
			"TextEncoder": false,
			"TextEvent": false,
			"TextMetrics": false,
			"TextTrack": false,
			"TextTrackCue": false,
			"TextTrackCueList": false,
			"TextTrackList": false,
			"TimeEvent": false,
			"TimeRanges": false,
			"toolbar": false,
			"top": false,
			"Touch": false,
			"TouchEvent": false,
			"TouchList": false,
			"TrackEvent": false,
			"TransitionEvent": false,
			"TreeWalker": false,
			"UIEvent": false,
			"URL": false,
			"ValidityState": false,
			"VTTCue": false,
			"WaveShaperNode": false,
			"WebGLActiveInfo": false,
			"WebGLBuffer": false,
			"WebGLContextEvent": false,
			"WebGLFramebuffer": false,
			"WebGLProgram": false,
			"WebGLRenderbuffer": false,
			"WebGLRenderingContext": false,
			"WebGLShader": false,
			"WebGLShaderPrecisionFormat": false,
			"WebGLTexture": false,
			"WebGLUniformLocation": false,
			"WebSocket": false,
			"WheelEvent": false,
			"window": false,
			"Window": false,
			"Worker": false,
			"XDomainRequest": false,
			"XMLDocument": false,
			"XMLHttpRequest": false,
			"XMLHttpRequestEventTarget": false,
			"XMLHttpRequestProgressEvent": false,
			"XMLHttpRequestUpload": false,
			"XMLSerializer": false,
			"XPathEvaluator": false,
			"XPathException": false,
			"XPathExpression": false,
			"XPathNamespace": false,
			"XPathNSResolver": false,
			"XPathResult": false,
			"XSLTProcessor": false
		},
		"worker": {
			"importScripts": true,
			"postMessage": true,
			"self": true
		},
		"node": {
			"__dirname": false,
			"__filename": false,
			"arguments": false,
			"Buffer": false,
			"clearImmediate": false,
			"clearInterval": false,
			"clearTimeout": false,
			"console": false,
			"exports": true,
			"GLOBAL": false,
			"global": false,
			"module": false,
			"process": false,
			"require": false,
			"root": false,
			"setImmediate": false,
			"setInterval": false,
			"setTimeout": false
		},
		"amd": {
			"define": false,
			"require": false
		},
		"mocha": {
			"after": false,
			"afterEach": false,
			"before": false,
			"beforeEach": false,
			"context": false,
			"describe": false,
			"it": false,
			"mocha": false,
			"setup": false,
			"specify": false,
			"suite": false,
			"suiteSetup": false,
			"suiteTeardown": false,
			"teardown": false,
			"test": false,
			"xcontext": false,
			"xdescribe": false,
			"xit": false,
			"xspecify": false
		},
		"jasmine": {
			"afterAll": false,
			"afterEach": false,
			"beforeAll": false,
			"beforeEach": false,
			"describe": false,
			"expect": false,
			"fail": false,
			"fdescribe": false,
			"fit": false,
			"it": false,
			"jasmine": false,
			"pending": false,
			"runs": false,
			"spyOn": false,
			"waits": false,
			"waitsFor": false,
			"xdescribe": false,
			"xit": false
		},
		"jest": {
			"afterEach": false,
			"beforeEach": false,
			"describe": false,
			"it": false,
			"jest": false,
			"pit": false,
			"require": false,
			"xdescribe": false,
			"xit": false
		},
		"qunit": {
			"asyncTest": false,
			"deepEqual": false,
			"equal": false,
			"expect": false,
			"module": false,
			"notDeepEqual": false,
			"notEqual": false,
			"notPropEqual": false,
			"notStrictEqual": false,
			"ok": false,
			"propEqual": false,
			"QUnit": false,
			"raises": false,
			"start": false,
			"stop": false,
			"strictEqual": false,
			"test": false,
			"throws": false
		},
		"phantomjs": {
			"console": true,
			"exports": true,
			"phantom": true,
			"require": true,
			"WebPage": true
		},
		"couch": {
			"emit": false,
			"exports": false,
			"getRow": false,
			"log": false,
			"module": false,
			"provides": false,
			"require": false,
			"respond": false,
			"send": false,
			"start": false,
			"sum": false
		},
		"rhino": {
			"defineClass": false,
			"deserialize": false,
			"gc": false,
			"help": false,
			"importClass": false,
			"importPackage": false,
			"java": false,
			"load": false,
			"loadClass": false,
			"Packages": false,
			"print": false,
			"quit": false,
			"readFile": false,
			"readUrl": false,
			"runCommand": false,
			"seal": false,
			"serialize": false,
			"spawn": false,
			"sync": false,
			"toint32": false,
			"version": false
		},
		"wsh": {
			"ActiveXObject": true,
			"Enumerator": true,
			"GetObject": true,
			"ScriptEngine": true,
			"ScriptEngineBuildVersion": true,
			"ScriptEngineMajorVersion": true,
			"ScriptEngineMinorVersion": true,
			"VBArray": true,
			"WScript": true,
			"WSH": true,
			"XDomainRequest": true
		},
		"jquery": {
			"$": false,
			"jQuery": false
		},
		"yui": {
			"Y": false,
			"YUI": false,
			"YUI_config": false
		},
		"shelljs": {
			"cat": false,
			"cd": false,
			"chmod": false,
			"config": false,
			"cp": false,
			"dirs": false,
			"echo": false,
			"env": false,
			"error": false,
			"exec": false,
			"exit": false,
			"find": false,
			"grep": false,
			"ls": false,
			"mkdir": false,
			"mv": false,
			"popd": false,
			"pushd": false,
			"pwd": false,
			"rm": false,
			"sed": false,
			"target": false,
			"tempdir": false,
			"test": false,
			"which": false
		},
		"prototypejs": {
			"$": false,
			"$$": false,
			"$A": false,
			"$break": false,
			"$continue": false,
			"$F": false,
			"$H": false,
			"$R": false,
			"$w": false,
			"Abstract": false,
			"Ajax": false,
			"Autocompleter": false,
			"Builder": false,
			"Class": false,
			"Control": false,
			"Draggable": false,
			"Draggables": false,
			"Droppables": false,
			"Effect": false,
			"Element": false,
			"Enumerable": false,
			"Event": false,
			"Field": false,
			"Form": false,
			"Hash": false,
			"Insertion": false,
			"ObjectRange": false,
			"PeriodicalExecuter": false,
			"Position": false,
			"Prototype": false,
			"Scriptaculous": false,
			"Selector": false,
			"Sortable": false,
			"SortableObserver": false,
			"Sound": false,
			"Template": false,
			"Toggle": false,
			"Try": false
		},
		"meteor": {
			"$": false,
			"_": false,
			"Accounts": false,
			"App": false,
			"Assets": false,
			"Blaze": false,
			"check": false,
			"Cordova": false,
			"DDP": false,
			"DDPServer": false,
			"Deps": false,
			"EJSON": false,
			"Email": false,
			"HTTP": false,
			"Log": false,
			"Match": false,
			"Meteor": false,
			"Mongo": false,
			"MongoInternals": false,
			"Npm": false,
			"Package": false,
			"Plugin": false,
			"process": false,
			"Random": false,
			"ReactiveDict": false,
			"ReactiveVar": false,
			"Router": false,
			"Session": false,
			"share": false,
			"Spacebars": false,
			"Template": false,
			"Tinytest": false,
			"Tracker": false,
			"UI": false,
			"Utils": false,
			"WebApp": false,
			"WebAppInternals": false
		},
		"mongo": {
			"_isWindows": false,
			"_rand": false,
			"BulkWriteResult": false,
			"cat": false,
			"cd": false,
			"connect": false,
			"db": false,
			"getHostName": false,
			"getMemInfo": false,
			"hostname": false,
			"listFiles": false,
			"load": false,
			"ls": false,
			"md5sumFile": false,
			"mkdir": false,
			"Mongo": false,
			"ObjectId": false,
			"PlanCache": false,
			"pwd": false,
			"quit": false,
			"removeFile": false,
			"rs": false,
			"sh": false,
			"UUID": false,
			"version": false,
			"WriteResult": false
		},
		"applescript": {
			"$": false,
			"Application": false,
			"Automation": false,
			"console": false,
			"delay": false,
			"Library": false,
			"ObjC": false,
			"ObjectSpecifier": false,
			"Path": false,
			"Progress": false,
			"Ref": false
		},
		"serviceworker": {
			"caches": false,
			"Cache": false,
			"CacheStorage": false,
			"Client": false,
			"Clients": false,
			"ExtendableEvent": false,
			"ExtendableMessageEvent": false,
			"FetchEvent": false,
			"importScripts": false,
			"self": false,
			"ServiceWorker": false,
			"ServiceWorkerContainer": false,
			"ServiceWorkerGlobalScope": false,
			"ServiceWorkerMessageEvent": false,
			"ServiceWorkerRegistration": false,
			"WindowClient": false
		},
		"embertest": {
			"andThen": false,
			"click": false,
			"currentPath": false,
			"currentRouteName": false,
			"currentUrl": false,
			"fillIn": false,
			"find": false,
			"keyEvent": false,
			"triggerEvent": false,
			"visit": false
		}
	}

/***/ },
/* 239 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag unnecessary bind calls
	 * @author Bence Dnyi <bence@danyi.me>
	 * @copyright 2014 Bence Dnyi. All rights reserved.
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var scope = [{
	        depth: -1,
	        found: 0
	    }];

	    /**
	     * Get the topmost scope
	     * @returns {Object} The topmost scope
	     */
	    function getTopScope() {
	        return scope[scope.length - 1];
	    }

	    /**
	     * Increment the depth of the top scope
	     * @returns {void}
	     */
	    function incrementScopeDepth() {
	        var top = getTopScope();
	        top.depth++;
	    }

	    /**
	     * Decrement the depth of the top scope
	     * @returns {void}
	     */
	    function decrementScopeDepth() {
	        var top = getTopScope();
	        top.depth--;
	    }

	    return {
	        "CallExpression": function(node) {
	            if (node.arguments.length === 1 &&
	                node.callee.type === "MemberExpression" &&
	                node.callee.property.name === "bind" &&
	                /FunctionExpression$/.test(node.callee.object.type)) {
	                scope.push({
	                    call: node,
	                    depth: -1,
	                    found: 0
	                });
	            }
	        },
	        "CallExpression:exit": function(node) {
	            var top = getTopScope();
	            if (top.call === node && top.found === 0) {
	                context.report(node, "The function binding is unnecessary.");
	                scope.pop();
	            }
	        },
	        "ArrowFunctionExpression": incrementScopeDepth,
	        "ArrowFunctionExpression:exit": decrementScopeDepth,
	        "FunctionExpression": incrementScopeDepth,
	        "FunctionExpression:exit": decrementScopeDepth,
	        "FunctionDeclaration": incrementScopeDepth,
	        "FunctionDeclaration:exit": decrementScopeDepth,
	        "ThisExpression": function() {
	            var top = getTopScope();
	            if (top.depth === 0) {
	                top.found++;
	            }
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 240 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag fall-through cases in switch statements.
	 * @author Matt DuVall <http://mattduvall.com/>
	 */
	"use strict";


	var FALLTHROUGH_COMMENT = /falls?\s?through/i;

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var switches = [];

	    return {

	        "SwitchCase": function(node) {

	            var consequent = node.consequent,
	                switchData = switches[switches.length - 1],
	                i,
	                comments,
	                comment;

	            /*
	             * Some developers wrap case bodies in blocks, so if there is just one
	             * node and it's a block statement, check inside.
	             */
	            if (consequent.length === 1 && consequent[0].type === "BlockStatement") {
	                consequent = consequent[0];
	            }

	            // checking on previous case
	            if (!switchData.lastCaseClosed) {

	                // a fall through comment will be the last trailing comment of the last case
	                comments = context.getComments(switchData.lastCase).trailing;
	                comment = comments[comments.length - 1];

	                // unless the user doesn't like semicolons, in which case it's first leading comment of this case
	                if (!comment) {
	                    comments = context.getComments(node).leading;
	                    comment = comments[comments.length - 1];
	                }

	                // check for comment
	                if (!comment || !FALLTHROUGH_COMMENT.test(comment.value)) {

	                    context.report(switchData.lastCase,
	                        "Expected a \"break\" statement before \"{{code}}\".",
	                        { code: node.test ? "case" : "default" });
	                }
	            }

	            // now dealing with the current case
	            switchData.lastCaseClosed = false;
	            switchData.lastCase = node;

	            // try to verify using statements - go backwards as a fast path for the search
	            if (consequent.length) {
	                for (i = consequent.length - 1; i >= 0; i--) {
	                    if (/(?:Break|Continue|Return|Throw)Statement/.test(consequent[i].type)) {
	                        switchData.lastCaseClosed = true;
	                        break;
	                    }
	                }
	            } else {
	                // the case statement has no statements, so it must logically fall through
	                switchData.lastCaseClosed = true;
	            }

	            /*
	             * Any warnings are triggered when the next SwitchCase occurs.
	             * There is no need to warn on the last SwitchCase, since it can't
	             * fall through to anything.
	             */
	        },

	        "SwitchStatement": function(node) {
	            switches.push({
	                node: node,
	                lastCaseClosed: true,
	                lastCase: null
	            });
	        },

	        "SwitchStatement:exit": function() {
	            switches.pop();
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 241 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag use of a leading/trailing decimal point in a numeric literal
	 * @author James Allardice
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {
	        "Literal": function(node) {

	            if (typeof node.value === "number") {
	                if (node.raw.indexOf(".") === 0) {
	                    context.report(node, "A leading decimal point can be confused with a dot.");
	                }
	                if (node.raw.indexOf(".") === node.raw.length - 1) {
	                    context.report(node, "A trailing decimal point can be confused with a dot.");
	                }
	            }
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 242 */
/***/ function(module, exports) {

	/**
	 * @fileoverview A rule to disallow the type conversions with shorter notations.
	 * @author Toru Nagashima
	 * @copyright 2015 Toru Nagashima. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------

	var INDEX_OF_PATTERN = /^(?:i|lastI)ndexOf$/;

	/**
	 * Parses and normalizes an option object.
	 * @param {object} options - An option object to parse.
	 * @returns {object} The parsed and normalized option object.
	 */
	function parseOptions(options) {
	    options = options || {};
	    return {
	        boolean: "boolean" in options ? Boolean(options.boolean) : true,
	        number: "number" in options ? Boolean(options.number) : true,
	        string: "string" in options ? Boolean(options.string) : true
	    };
	}

	/**
	 * Checks whether or not a node is a double logical nigating.
	 * @param {ASTNode} node - An UnaryExpression node to check.
	 * @returns {boolean} Whether or not the node is a double logical nigating.
	 */
	function isDoubleLogicalNegating(node) {
	    return (
	        node.operator === "!" &&
	        node.argument.type === "UnaryExpression" &&
	        node.argument.operator === "!"
	    );
	}

	/**
	 * Checks whether or not a node is a binary negating of `.indexOf()` method calling.
	 * @param {ASTNode} node - An UnaryExpression node to check.
	 * @returns {boolean} Whether or not the node is a binary negating of `.indexOf()` method calling.
	 */
	function isBinaryNegatingOfIndexOf(node) {
	    return (
	        node.operator === "~" &&
	        node.argument.type === "CallExpression" &&
	        node.argument.callee.type === "MemberExpression" &&
	        node.argument.callee.property.type === "Identifier" &&
	        INDEX_OF_PATTERN.test(node.argument.callee.property.name)
	    );
	}

	/**
	 * Checks whether or not a node is a multiplying by one.
	 * @param {ASTNode} node - A BinaryExpression node to check.
	 * @returns {boolean} Whether or not the node is a multiplying by one.
	 */
	function isMultiplyByOne(node) {
	    return node.operator === "*" && (
	        (node.left.type === "Literal" && node.left.value === 1) ||
	        (node.right.type === "Literal" && node.right.value === 1)
	    );
	}

	/**
	 * Checks whether or not a node is a concatenating with an empty string.
	 * @param {ASTNode} node - A BinaryExpression node to check.
	 * @returns {boolean} Whether or not the node is a concatenating with an empty string.
	 */
	function isConcatWithEmptyString(node) {
	    return node.operator === "+" && (
	        (node.left.type === "Literal" && node.left.value === "") ||
	        (node.right.type === "Literal" && node.right.value === "")
	    );
	}

	/**
	 * Gets a node that is the left or right operand of a node, is not the specified literal.
	 * @param {ASTNode} node - A BinaryExpression node to get.
	 * @param {any} value - A literal value to check.
	 * @returns {ASTNode} A node that is the left or right operand of the node, is not the specified literal.
	 */
	function getOtherOperand(node, value) {
	    if (node.left.type === "Literal" && node.left.value === value) {
	        return node.right;
	    }
	    return node.left;
	}

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {
	    var options = parseOptions(context.options[0]);

	    return {
	        "UnaryExpression": function(node) {
	            // !!foo
	            if (options.boolean && isDoubleLogicalNegating(node)) {
	                context.report(
	                    node,
	                    "use `Boolean({{code}})` instead.",
	                    {code: context.getSource(node.argument.argument)});
	            }

	            // ~foo.indexOf(bar)
	            if (options.boolean && isBinaryNegatingOfIndexOf(node)) {
	                context.report(
	                    node,
	                    "use `{{code}} !== -1` instead.",
	                    {code: context.getSource(node.argument)});
	            }

	            // +foo
	            if (options.number && node.operator === "+") {
	                context.report(
	                    node,
	                    "use `Number({{code}})` instead.",
	                    {code: context.getSource(node.argument)});
	            }
	        },

	        "BinaryExpression": function(node) {
	            // 1 * foo
	            if (options.number && isMultiplyByOne(node)) {
	                context.report(
	                    node,
	                    "use `Number({{code}})` instead.",
	                    {code: context.getSource(getOtherOperand(node, 1))});
	            }

	            // "" + foo
	            if (options.string && isConcatWithEmptyString(node)) {
	                context.report(
	                    node,
	                    "use `String({{code}})` instead.",
	                    {code: context.getSource(getOtherOperand(node, ""))});
	            }
	        }
	    };
	};

	module.exports.schema = [
	    {
	        "type": "object",
	        "properties": {
	            "boolean": {
	                "type": "boolean"
	            },
	            "number": {
	                "type": "boolean"
	            },
	            "string": {
	                "type": "boolean"
	            }
	        },
	        "additionalProperties": false
	    }
	];


/***/ },
/* 243 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag use of implied eval via setTimeout and setInterval
	 * @author James Allardice
	 * @copyright 2015 Mathias Schreck. All rights reserved.
	 * @copyright 2013 James Allardice. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {
	    var CALLEE_RE = /set(?:Timeout|Interval)|execScript/;

	    // Figures out if we should inspect a given binary expression. Is a stack of
	    // stacks, where the first element in each substack is a CallExpression.
	    var impliedEvalAncestorsStack = [];

	    //--------------------------------------------------------------------------
	    // Helpers
	    //--------------------------------------------------------------------------

	    /**
	     * Get the last element of an array, without modifying arr, like pop(), but non-destructive.
	     * @param {array} arr What to inspect
	     * @returns {*} The last element of arr
	     * @private
	     */
	    function last(arr) {
	        return arr ? arr[arr.length - 1] : null;
	    }

	    /**
	     * Checks if the given MemberExpression node is a potentially implied eval identifier on window.
	     * @param {ASTNode} node The MemberExpression node to check.
	     * @returns {boolean} Whether or not the given node is potentially an implied eval.
	     * @private
	     */
	    function isImpliedEvalMemberExpression(node) {
	        var object = node.object,
	            property = node.property,
	            hasImpliedEvalName = CALLEE_RE.test(property.name) || CALLEE_RE.test(property.value);

	        return object.name === "window" && hasImpliedEvalName;
	    }

	    /**
	     * Determines if a node represents a call to a potentially implied eval.
	     *
	     * This checks the callee name and that there's an argument, but not the type of the argument.
	     *
	     * @param {ASTNode} node The CallExpression to check.
	     * @returns {boolean} True if the node matches, false if not.
	     * @private
	     */
	    function isImpliedEvalCallExpression(node) {
	        var isMemberExpression = (node.callee.type === "MemberExpression"),
	            isIdentifier = (node.callee.type === "Identifier"),
	            isImpliedEvalCallee =
	                (isIdentifier && CALLEE_RE.test(node.callee.name)) ||
	                (isMemberExpression && isImpliedEvalMemberExpression(node.callee));

	        return isImpliedEvalCallee && node.arguments.length;
	    }

	    /**
	     * Checks that the parent is a direct descendent of an potential implied eval CallExpression, and if the parent is a CallExpression, that we're the first argument.
	     * @param {ASTNode} node The node to inspect the parent of.
	     * @returns {boolean} Was the parent a direct descendent, and is the child therefore potentially part of a dangerous argument?
	     * @private
	     */
	    function hasImpliedEvalParent(node) {
	        // make sure our parent is marked
	        return node.parent === last(last(impliedEvalAncestorsStack)) &&
	            // if our parent is a CallExpression, make sure we're the first argument
	            (node.parent.type !== "CallExpression" || node === node.parent.arguments[0]);
	    }

	    /**
	     * Checks if our parent is marked as part of an implied eval argument. If
	     * so, collapses the top of impliedEvalAncestorsStack and reports on the
	     * original CallExpression.
	     * @param {ASTNode} node The CallExpression to check.
	     * @returns {boolean} True if the node matches, false if not.
	     * @private
	     */
	    function checkString(node) {
	        if (hasImpliedEvalParent(node)) {
	            // remove the entire substack, to avoid duplicate reports
	            var substack = impliedEvalAncestorsStack.pop();
	            context.report(substack[0], "Implied eval. Consider passing a function instead of a string.");
	        }
	    }

	    //--------------------------------------------------------------------------
	    // Public
	    //--------------------------------------------------------------------------

	    return {
	        "CallExpression": function(node) {
	            if (isImpliedEvalCallExpression(node)) {
	                // call expressions create a new substack
	                impliedEvalAncestorsStack.push([node]);
	            }
	        },

	        "CallExpression:exit": function(node) {
	            if (node === last(last(impliedEvalAncestorsStack))) {
	                // destroys the entire sub-stack, rather than just using
	                // last(impliedEvalAncestorsStack).pop(), as a CallExpression is
	                // always the bottom of a impliedEvalAncestorsStack substack.
	                impliedEvalAncestorsStack.pop();
	            }
	        },

	        "BinaryExpression": function(node) {
	            if (node.operator === "+" && hasImpliedEvalParent(node)) {
	                last(impliedEvalAncestorsStack).push(node);
	            }
	        },

	        "BinaryExpression:exit": function(node) {
	            if (node === last(last(impliedEvalAncestorsStack))) {
	                last(impliedEvalAncestorsStack).pop();
	            }
	        },

	        "Literal": function(node) {
	            if (typeof node.value === "string") {
	                checkString(node);
	            }
	        },

	        "TemplateLiteral": function(node) {
	            checkString(node);
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview A rule to disallow `this` keywords outside of classes or class-like objects.
	 * @author Toru Nagashima
	 * @copyright 2015 Toru Nagashima. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------

	var thisTagPattern = /^[\s\*]*@this/m;
	var anyFunctionPattern = /^(?:Function(?:Declaration|Expression)|ArrowFunctionExpression)$/;
	var bindOrCallOrApplyPattern = /^(?:bind|call|apply)$/;
	var arrayOrTypedArrayPattern = /Array$/;
	var arrayMethodPattern = /^(?:every|filter|find|findIndex|forEach|map|some)$/;
	var astUtils = __webpack_require__(177);

	/**
	 * Checks whether or not a node is a constructor.
	 * @param {ASTNode} node - A function node to check.
	 * @returns {boolean} Wehether or not a node is a constructor.
	 */
	function isES5Constructor(node) {
	    return (
	        node.id != null &&
	        node.id.name[0] === node.id.name[0].toLocaleUpperCase()
	    );
	}

	/**
	 * Checks whether or not a node has a `@this` tag in its comments.
	 * @param {ASTNode} node - A node to check.
	 * @returns {boolean} Whether or not the node has a `@this` tag in its comments.
	 */
	function hasJSDocThisTag(node) {
	    var jsdocComment = astUtils.getJSDocComment(node);
	    if (jsdocComment != null && thisTagPattern.test(jsdocComment.value)) {
	        return true;
	    }

	    // Checks `@this` in its leading comments for callbacks,
	    // because callbacks don't have its JSDoc comment.
	    // e.g.
	    //     sinon.test(/* @this sinon.Sandbox */function() { this.spy(); });
	    return astUtils.getComments(node).leading.some(function(comment) {
	        return thisTagPattern.test(comment.value);
	    });
	}

	/**
	 * Finds a function node from ancestors of a node.
	 * @param {ASTNode} node - A start node to find.
	 * @returns {Node|null} A found function node.
	 */
	function getUpperFunction(node) {
	    while (node != null) {
	        if (anyFunctionPattern.test(node.type)) {
	            return node;
	        }
	        node = node.parent;
	    }
	    return null;
	}

	/**
	 * Checks whether or not a node is callee.
	 * @param {ASTNode} node - A node to check.
	 * @returns {boolean} Whether or not the node is callee.
	 */
	function isCallee(node) {
	    return node.parent.type === "CallExpression" && node.parent.callee === node;
	}

	/**
	 * Checks whether or not a node is `Reclect.apply`.
	 * @param {ASTNode} node - A node to check.
	 * @returns {boolean} Whether or not the node is a `Reclect.apply`.
	 */
	function isReflectApply(node) {
	    return (
	        node.type === "MemberExpression" &&
	        node.object.type === "Identifier" &&
	        node.object.name === "Reflect" &&
	        node.property.type === "Identifier" &&
	        node.property.name === "apply" &&
	        node.computed === false
	    );
	}

	/**
	 * Checks whether or not a node is `Array.from`.
	 * @param {ASTNode} node - A node to check.
	 * @returns {boolean} Whether or not the node is a `Array.from`.
	 */
	function isArrayFrom(node) {
	    return (
	        node.type === "MemberExpression" &&
	        node.object.type === "Identifier" &&
	        arrayOrTypedArrayPattern.test(node.object.name) &&
	        node.property.type === "Identifier" &&
	        node.property.name === "from" &&
	        node.computed === false
	    );
	}

	/**
	 * Checks whether or not a node is a method which has `thisArg`.
	 * @param {ASTNode} node - A node to check.
	 * @returns {boolean} Whether or not the node is a method which has `thisArg`.
	 */
	function isMethodWhichHasThisArg(node) {
	    while (node != null) {
	        if (node.type === "Identifier") {
	            return arrayMethodPattern.test(node.name);
	        }
	        if (node.type === "MemberExpression" && !node.computed) {
	            node = node.property;
	            continue;
	        }

	        break;
	    }

	    return false;
	}

	/**
	 * Checks whether or not a node has valid `this`.
	 *
	 * First, this checks the node:
	 *
	 * - The function name starts with uppercase (it's a constructor).
	 * - The function has a JSDoc comment that has a @this tag.
	 *
	 * Next, this checks the location of the node.
	 * If the location is below, this judges `this` is valid.
	 *
	 * - The location is on an object literal.
	 * - The location assigns to a property.
	 * - The location is on an ES2015 class.
	 * - The location calls its `bind`/`call`/`apply` method directly.
	 * - The function is a callback of array methods (such as `.forEach()`) if `thisArg` is given.
	 *
	 * @param {ASTNode} node - A node to check.
	 * @returns {boolean} A found function node.
	 */
	function hasValidThis(node) {
	    if (isES5Constructor(node) || hasJSDocThisTag(node)) {
	        return true;
	    }

	    while (node != null) {
	        var parent = node.parent;
	        switch (parent.type) {
	            // Looks up the destination.
	            // e.g.
	            //   obj.foo = nativeFoo || function foo() { ... };
	            case "LogicalExpression":
	            case "ConditionalExpression":
	                node = parent;
	                break;

	            // If the upper function is IIFE, checks the destination of the return value.
	            // e.g.
	            //   obj.foo = (function() {
	            //     // setup...
	            //     return function foo() { ... };
	            //   })();
	            case "ReturnStatement":
	                var func = getUpperFunction(parent);
	                if (func === null || !isCallee(func)) {
	                    return false;
	                }
	                node = func.parent;
	                break;

	            // e.g.
	            //   var obj = { foo() { ... } };
	            //   var obj = { foo: function() { ... } };
	            case "Property":
	                return true;

	            // e.g.
	            //   obj.foo = foo() { ... };
	            case "AssignmentExpression":
	                return (
	                    parent.right === node &&
	                    parent.left.type === "MemberExpression"
	                );

	            // e.g.
	            //   class A { constructor() { ... } }
	            //   class A { foo() { ... } }
	            //   class A { get foo() { ... } }
	            //   class A { set foo() { ... } }
	            //   class A { static foo() { ... } }
	            case "MethodDefinition":
	                return !parent.static;

	            // e.g.
	            //   var foo = function foo() { ... }.bind(obj);
	            //   (function foo() { ... }).call(obj);
	            //   (function foo() { ... }).apply(obj, []);
	            case "MemberExpression":
	                return (
	                    parent.object === node &&
	                    parent.property.type === "Identifier" &&
	                    bindOrCallOrApplyPattern.test(parent.property.name) &&
	                    isCallee(parent) &&
	                    parent.parent.arguments.length > 0 &&
	                    !astUtils.isNullOrUndefined(parent.parent.arguments[0])
	                );

	            // e.g.
	            //   Reflect.apply(function() {}, obj, []);
	            //   Array.from([], function() {}, obj);
	            //   list.forEach(function() {}, obj);
	            case "CallExpression":
	                if (isReflectApply(parent.callee)) {
	                    return (
	                        parent.arguments.length === 3 &&
	                        parent.arguments[0] === node &&
	                        !astUtils.isNullOrUndefined(parent.arguments[1])
	                    );
	                }
	                if (isArrayFrom(parent.callee)) {
	                    return (
	                        parent.arguments.length === 3 &&
	                        parent.arguments[1] === node &&
	                        !astUtils.isNullOrUndefined(parent.arguments[2])
	                    );
	                }
	                if (isMethodWhichHasThisArg(parent.callee)) {
	                    return (
	                        parent.arguments.length === 2 &&
	                        parent.arguments[0] === node &&
	                        !astUtils.isNullOrUndefined(parent.arguments[1])
	                    );
	                }
	                return false;

	            // Otherwise `this` is invalid.
	            default:
	                return false;
	        }
	    }

	    /* istanbul ignore next */
	    throw new Error("unreachable");
	}

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {
	    var stack = [];

	    /**
	     * Gets the current checking context.
	     *
	     * The return value has a flag that whether or not `this` keyword is valid.
	     * The flag is initialized when got at the first time.
	     *
	     * @returns {{valid: boolean}}
	     *   an object which has a flag that whether or not `this` keyword is valid.
	     */
	    stack.getCurrent = function() {
	        var current = this[this.length - 1];
	        if (!current.init) {
	            current.init = true;
	            current.valid = hasValidThis(current.node);
	        }
	        return current;
	    };

	    /**
	     * Pushs new checking context into the stack.
	     *
	     * The checking context is not initialized yet.
	     * Because most functions don't have `this` keyword.
	     * When `this` keyword was found, the checking context is initialized.
	     *
	     * @param {ASTNode} node - A function node that was entered.
	     * @returns {void}
	     */
	    function enterFunction(node) {
	        // `this` can be invalid only under strict mode.
	        stack.push({
	            init: !context.getScope().isStrict,
	            node: node,
	            valid: true
	        });
	    }

	    /**
	     * Pops the current checking context from the stack.
	     * @returns {void}
	     */
	    function exitFunction() {
	        stack.pop();
	    }

	    return {
	        // `this` is invalid only under strict mode.
	        // Modules is always strict mode.
	        "Program": function(node) {
	            stack.push({
	                init: true,
	                node: node,
	                valid: !(context.ecmaFeatures.modules || context.getScope().isStrict)
	            });
	        },
	        "Program:exit": function() {
	            stack.pop();
	        },

	        "FunctionDeclaration": enterFunction,
	        "FunctionDeclaration:exit": exitFunction,
	        "FunctionExpression": enterFunction,
	        "FunctionExpression:exit": exitFunction,

	        // Reports if `this` of the current context is invalid.
	        "ThisExpression": function(node) {
	            var current = stack.getCurrent();
	            if (current != null && !current.valid) {
	                context.report(node, "Unexpected `this`.");
	            }
	        }
	    };
	};

	module.exports.schema = [];


/***/ },
/* 245 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag usage of __iterator__ property
	 * @author Ian Christian Myers
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {

	        "MemberExpression": function(node) {

	            if (node.property &&
	                    (node.property.type === "Identifier" && node.property.name === "__iterator__" && !node.computed) ||
	                    (node.property.type === "Literal" && node.property.value === "__iterator__")) {
	                context.report(node, "Reserved name '__iterator__'.");
	            }
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 246 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Disallow Labeled Statements
	 * @author Nicholas C. Zakas
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    //--------------------------------------------------------------------------
	    // Public
	    //--------------------------------------------------------------------------

	    return {

	        "LabeledStatement": function(node) {
	            context.report(node, "Unexpected labeled statement.");
	        },

	        "BreakStatement": function(node) {

	            if (node.label) {
	                context.report(node, "Unexpected label in break statement.");
	            }

	        },

	        "ContinueStatement": function(node) {

	            if (node.label) {
	                context.report(node, "Unexpected label in continue statement.");
	            }

	        }


	    };

	};

	module.exports.schema = [];


/***/ },
/* 247 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag blocks with no reason to exist
	 * @author Brandon Mills
	 * @copyright 2015 Roberto Vidal. All rights reserved.
	 * @copyright 2014 Brandon Mills. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    // A stack of lone blocks to be checked for block-level bindings
	    var loneBlocks = [],
	        ruleDef;

	    /**
	     * Reports a node as invalid.
	     * @param {ASTNode} node - The node to be reported.
	     * @returns {void}
	    */
	    function report(node) {
	        var parent = context.getAncestors().pop();
	        context.report(node, parent.type === "Program" ?
	            "Block is redundant." :
	            "Nested block is redundant."
	        );
	    }

	    /**
	     * Checks for any ocurrence of BlockStatement > BlockStatement or Program > BlockStatement
	     * @returns {boolean} True if the current node is a lone block.
	    */
	    function isLoneBlock() {
	        var parent = context.getAncestors().pop();
	        return parent.type === "BlockStatement" || parent.type === "Program";
	    }

	    /**
	     * Checks the enclosing block of the current node for block-level bindings,
	     * and "marks it" as valid if any.
	     * @returns {void}
	    */
	    function markLoneBlock() {
	        if (loneBlocks.length === 0) {
	            return;
	        }

	        var block = context.getAncestors().pop();

	        if (loneBlocks[loneBlocks.length - 1] === block) {
	            loneBlocks.pop();
	        }
	    }

	    // Default rule definition: report all lone blocks
	    ruleDef = {
	        BlockStatement: function(node) {
	            if (isLoneBlock(node)) {
	                report(node);
	            }
	        }
	    };

	    // ES6: report blocks without block-level bindings
	    if (context.ecmaFeatures.blockBindings || context.ecmaFeatures.classes) {
	        ruleDef = {
	            "BlockStatement": function(node) {
	                if (isLoneBlock(node)) {
	                    loneBlocks.push(node);
	                }
	            },
	            "BlockStatement:exit": function(node) {
	                if (loneBlocks.length > 0 && loneBlocks[loneBlocks.length - 1] === node) {
	                    loneBlocks.pop();
	                    report(node);
	                }
	            }
	        };
	    }

	    if (context.ecmaFeatures.blockBindings) {
	        ruleDef.VariableDeclaration = function(node) {
	            if (node.kind === "let" || node.kind === "const") {
	                markLoneBlock(node);
	            }
	        };

	        ruleDef.FunctionDeclaration = function(node) {
	            if (context.getScope().isStrict) {
	                markLoneBlock(node);
	            }
	        };
	    }

	    if (context.ecmaFeatures.classes) {
	        ruleDef.ClassDeclaration = markLoneBlock;
	    }

	    return ruleDef;
	};

	module.exports.schema = [];


/***/ },
/* 248 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag creation of function inside a loop
	 * @author Ilya Volodin
	 * @copyright 2013 Ilya Volodin. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------

	/**
	 * Gets the containing loop node of a specified node.
	 *
	 * We don't need to check nested functions, so this ignores those.
	 * `Scope.through` contains references of nested functions.
	 *
	 * @param {ASTNode} node - An AST node to get.
	 * @returns {ASTNode|null} The containing loop node of the specified node, or `null`.
	 */
	function getContainingLoopNode(node) {
	    var parent = node.parent;
	    while (parent != null) {
	        switch (parent.type) {
	            case "WhileStatement":
	            case "DoWhileStatement":
	                return parent;

	            case "ForStatement":
	                // `init` is outside of the loop.
	                if (parent.init !== node) {
	                    return parent;
	                }
	                break;

	            case "ForInStatement":
	            case "ForOfStatement":
	                // `right` is outside of the loop.
	                if (parent.right !== node) {
	                    return parent;
	                }
	                break;

	            case "ArrowFunctionExpression":
	            case "FunctionExpression":
	            case "FunctionDeclaration":
	                // We don't need to check nested functions.
	                return null;

	            default:
	                break;
	        }

	        node = parent;
	        parent = node.parent;
	    }

	    return null;
	}

	/**
	 * Checks whether or not a reference refers to a variable that is block-binding in the loop.
	 * @param {ASTNode} loopNode - A containing loop node.
	 * @param {escope.Reference} reference - A reference to check.
	 * @returns {boolean} Whether or not a reference refers to a variable that is block-binding in the loop.
	 */
	function isBlockBindingsInLoop(loopNode, reference) {
	    // A reference to a `let`/`const` variable always has a resolved variable.
	    var variable = reference.resolved;
	    var definition = variable && variable.defs[0];
	    var declaration = definition && definition.parent;

	    return (
	        // Checks whether this is `let`/`const`.
	        declaration != null &&
	        declaration.type === "VariableDeclaration" &&
	        (declaration.kind === "let" || declaration.kind === "const") &&
	        // Checks whether this is in the loop.
	        declaration.range[0] > loopNode.range[0] &&
	        declaration.range[1] < loopNode.range[1]
	    );
	}

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {
	    /**
	     * Reports such functions:
	     *
	     * - has an ancestor node which is a loop.
	     * - has a reference that refers to a variable that is block-binding in the loop.
	     *
	     * @param {ASTNode} node The AST node to check.
	     * @returns {boolean} Whether or not the node is within a loop.
	     */
	    function checkForLoops(node) {
	        var loopNode = getContainingLoopNode(node);
	        if (loopNode == null) {
	            return;
	        }

	        var references = context.getScope().through;
	        if (references.length > 0 && !references.every(isBlockBindingsInLoop.bind(null, loopNode))) {
	            context.report(node, "Don't make functions within a loop");
	        }
	    }

	    return {
	        "ArrowFunctionExpression": checkForLoops,
	        "FunctionExpression": checkForLoops,
	        "FunctionDeclaration": checkForLoops
	    };
	};

	module.exports.schema = [];


/***/ },
/* 249 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Disallow use of multiple spaces.
	 * @author Nicholas C. Zakas
	 * @copyright 2015 Brandon Mills. All rights reserved.
	 * @copyright 2015 Nicholas C. Zakas. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    // the index of the last comment that was checked
	    var exceptions = { "Property": true },
	        hasExceptions = true,
	        options = context.options[0],
	        lastCommentIndex = 0;

	    if (options && options.exceptions) {
	        Object.keys(options.exceptions).forEach(function(key) {
	            if (options.exceptions[key]) {
	                exceptions[key] = true;
	            } else {
	                delete exceptions[key];
	            }
	        });
	        hasExceptions = Object.keys(exceptions).length > 0;
	    }

	    /**
	     * Determines if a given source index is in a comment or not by checking
	     * the index against the comment range. Since the check goes straight
	     * through the file, once an index is passed a certain comment, we can
	     * go to the next comment to check that.
	     * @param {int} index The source index to check.
	     * @param {ASTNode[]} comments An array of comment nodes.
	     * @returns {boolean} True if the index is within a comment, false if not.
	     * @private
	     */
	    function isIndexInComment(index, comments) {

	        var comment;

	        while (lastCommentIndex < comments.length) {

	            comment = comments[lastCommentIndex];

	            if (comment.range[0] <= index && index < comment.range[1]) {
	                return true;
	            } else if (index > comment.range[1]) {
	                lastCommentIndex++;
	            } else {
	                break;
	            }

	        }

	        return false;
	    }

	    //--------------------------------------------------------------------------
	    // Public
	    //--------------------------------------------------------------------------

	    return {
	        "Program": function() {

	            var source = context.getSource(),
	                allComments = context.getAllComments(),
	                pattern = /[^\n\r\u2028\u2029 ] {2,}/g,  // note: repeating space
	                token,
	                parent;

	            while (pattern.test(source)) {

	                // do not flag anything inside of comments
	                if (!isIndexInComment(pattern.lastIndex, allComments)) {

	                    token = context.getTokenByRangeStart(pattern.lastIndex);

	                    if (token) {
	                        if (hasExceptions) {
	                            parent = context.getNodeByRangeIndex(pattern.lastIndex - 1);
	                        }

	                        if (!parent || !exceptions[parent.type]) {
	                            context.report(token, token.loc.start,
	                                "Multiple spaces found before '{{value}}'.",
	                                { value: token.value });
	                        }
	                    }

	                }
	            }
	        }
	    };

	};

	module.exports.schema = [
	    {
	        "type": "object",
	        "properties": {
	            "exceptions": {
	                "type": "object",
	                "patternProperties": {
	                    "^([A-Z][a-z]*)+$": {
	                        "type": "boolean"
	                    }
	                },
	                "additionalProperties": false
	            }
	        },
	        "additionalProperties": false
	    }
	];


/***/ },
/* 250 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag when using multiline strings
	 * @author Ilya Volodin
	 * @copyright 2014 Nicholas C. Zakas. All rights reserved.
	 * @copyright 2013 Ilya Volodin. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    /**
	     * Determines if a given node is part of JSX syntax.
	     * @param {ASTNode} node The node to check.
	     * @returns {boolean} True if the node is a JSX node, false if not.
	     * @private
	     */
	    function isJSXElement(node) {
	        return node.type.indexOf("JSX") === 0;
	    }

	    //--------------------------------------------------------------------------
	    // Public API
	    //--------------------------------------------------------------------------

	    return {

	        "Literal": function(node) {
	            var lineBreak = /\n/;

	            if (lineBreak.test(node.raw) && !isJSXElement(node.parent)) {
	                context.report(node, "Multiline support is limited to browsers supporting ES5 only.");
	            }
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 251 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag when re-assigning native objects
	 * @author Ilya Volodin
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var config = context.options[0];
	    var exceptions = (config && config.exceptions) || [];

	    /**
	     * Gets the names of writeable built-in variables.
	     * @param {escope.Scope} scope - A scope to get.
	     * @returns {object} A map that its key is variable names.
	     */
	    function getBuiltinGlobals(scope) {
	        return scope.variables.reduce(function(retv, variable) {
	            if (variable.writeable === false && variable.name !== "__proto__") {
	                retv[variable.name] = true;
	            }
	            return retv;
	        }, Object.create(null));
	    }

	    /**
	     * Reports if a given reference's name is same as native object's.
	     * @param {object} builtins - A map that its key is a variable name.
	     * @param {Reference} reference - A reference to check.
	     * @param {int} index - The index of the reference in the references.
	     * @param {Reference[]} references - The array that the reference belongs to.
	     * @returns {void}
	     */
	    function checkThroughReference(builtins, reference, index, references) {
	        var identifier = reference.identifier;

	        if (identifier != null &&
	            builtins[identifier.name] &&
	            exceptions.indexOf(identifier.name) === -1 &&
	            reference.init === false &&
	            reference.isWrite() &&
	            // Destructuring assignments can have multiple default value,
	            // so possibly there are multiple writeable references for the same identifier.
	            (index === 0 || references[index - 1].identifier !== identifier)
	        ) {
	            context.report(
	                identifier,
	                "{{name}} is a read-only native object.",
	                {name: identifier.name});
	        }
	    }

	    return {
	        // Checks assignments of global variables.
	        // References to implicit global variables are not resolved,
	        // so those are in the `through` of the global scope.
	        "Program": function() {
	            var globalScope = context.getScope();
	            var builtins = getBuiltinGlobals(globalScope);
	            globalScope.through.forEach(checkThroughReference.bind(null, builtins));
	        }
	    };

	};

	module.exports.schema = [
	    {
	        "type": "object",
	        "properties": {
	            "exceptions": {
	                "type": "array",
	                "items": {"type": "string"},
	                "uniqueItems": true
	            }
	        },
	        "additionalProperties": false
	    }
	];


/***/ },
/* 252 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag when using new Function
	 * @author Ilya Volodin
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    //--------------------------------------------------------------------------
	    // Helpers
	    //--------------------------------------------------------------------------

	    /**
	     * Checks if the callee if the Function constructor, and if so, reports an issue.
	     * @param {ASTNode} node The node to check and report on
	     * @returns {void}
	     * @private
	     */
	    function validateCallee(node) {
	        if (node.callee.name === "Function") {
	            context.report(node, "The Function constructor is eval.");
	        }
	    }

	    return {
	        "NewExpression": validateCallee,
	        "CallExpression": validateCallee
	    };

	};

	module.exports.schema = [];


/***/ },
/* 253 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag when using constructor for wrapper objects
	 * @author Ilya Volodin
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {

	        "NewExpression": function(node) {
	            var wrapperObjects = ["String", "Number", "Boolean", "Math", "JSON"];
	            if (wrapperObjects.indexOf(node.callee.name) > -1) {
	                context.report(node, "Do not use {{fn}} as a constructor.", { fn: node.callee.name });
	            }
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 254 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag statements with function invocation preceded by
	 * "new" and not part of assignment
	 * @author Ilya Volodin
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {

	        "ExpressionStatement": function(node) {

	            if (node.expression.type === "NewExpression") {
	                context.report(node, "Do not use 'new' for side effects.");
	            }
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 255 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag octal escape sequences in string literals.
	 * @author Ian Christian Myers
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {

	        "Literal": function(node) {
	            if (typeof node.value !== "string") {
	                return;
	            }

	            var match = node.raw.match(/^([^\\]|\\[^0-7])*\\([0-3][0-7]{1,2}|[4-7][0-7]|[0-7])/),
	                octalDigit;

	            if (match) {
	                octalDigit = match[2];

	                // \0 is actually not considered an octal
	                if (match[2] !== "0" || typeof match[3] !== "undefined") {
	                    context.report(node, "Don't use octal: '\\{{octalDigit}}'. Use '\\u....' instead.",
	                            { octalDigit: octalDigit });
	                }
	            }
	        }

	    };

	};

	module.exports.schema = [];


/***/ },
/* 256 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag when initializing octal literal
	 * @author Ilya Volodin
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {

	        "Literal": function(node) {
	            if (typeof node.value === "number" && /^0[0-7]/.test(node.raw)) {
	                context.report(node, "Octal literals should not be used.");
	            }
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 257 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Disallow reassignment of function parameters.
	 * @author Nat Burns
	 * @copyright 2014 Nat Burns. All rights reserved.
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	var stopNodePattern = /(?:Statement|Declaration|Function(?:Expression)?|Program)$/;

	module.exports = function(context) {
	    var props = context.options[0] != null && Boolean(context.options[0].props);

	    /**
	     * Checks whether or not a reference modifies its variable.
	     * If the `props` option is `true`, this checks whether or not the reference modifies properties of its variable also.
	     * @param {Reference} reference - A reference to check.
	     * @returns {boolean} Whether or not the reference modifies its variable.
	     */
	    function isModifying(reference) {
	        if (reference.isWrite()) {
	            return true;
	        }

	        // Checks whether its property is modified.
	        if (props) {
	            var node = reference.identifier;
	            var parent = node.parent;
	            while (parent != null && !stopNodePattern.test(parent.type)) {
	                switch (parent.type) {
	                    // e.g. foo.a = 0;
	                    case "AssignmentExpression":
	                        return parent.left === node;

	                    // e.g. ++foo.a;
	                    case "UpdateExpression":
	                        return true;

	                    // e.g. delete foo.a;
	                    case "UnaryExpression":
	                        if (parent.operator === "delete") {
	                            return true;
	                        }
	                        break;

	                    // EXCLUDES: e.g. cache.get(foo.a).b = 0;
	                    case "CallExpression":
	                        if (parent.callee !== node) {
	                            return false;
	                        }
	                        break;

	                    // EXCLUDES: e.g. cache[foo.a] = 0;
	                    case "MemberExpression":
	                        if (parent.property === node) {
	                            return false;
	                        }
	                        break;

	                    default:
	                        break;
	                }

	                node = parent;
	                parent = parent.parent;
	            }
	        }

	        return false;
	    }

	    /**
	     * Reports a reference if is non initializer and writable.
	     * @param {Reference} reference - A reference to check.
	     * @param {int} index - The index of the reference in the references.
	     * @param {Reference[]} references - The array that the reference belongs to.
	     * @returns {void}
	     */
	    function checkReference(reference, index, references) {
	        var identifier = reference.identifier;

	        if (identifier != null &&
	            !reference.init &&
	            isModifying(reference) &&
	            // Destructuring assignments can have multiple default value,
	            // so possibly there are multiple writeable references for the same identifier.
	            (index === 0 || references[index - 1].identifier !== identifier)
	        ) {
	            context.report(
	                identifier,
	                "Assignment to function parameter '{{name}}'.",
	                {name: identifier.name});
	        }
	    }

	    /**
	     * Finds and reports references that are non initializer and writable.
	     * @param {Variable} variable - A variable to check.
	     * @returns {void}
	     */
	    function checkVariable(variable) {
	        if (variable.defs[0].type === "Parameter") {
	            variable.references.forEach(checkReference);
	        }
	    }

	    /**
	     * Checks parameters of a given function node.
	     * @param {ASTNode} node - A function node to check.
	     * @returns {void}
	     */
	    function checkForFunction(node) {
	        context.getDeclaredVariables(node).forEach(checkVariable);
	    }

	    return {
	        // `:exit` is needed for the `node.parent` property of identifier nodes.
	        "FunctionDeclaration:exit": checkForFunction,
	        "FunctionExpression:exit": checkForFunction,
	        "ArrowFunctionExpression:exit": checkForFunction
	    };

	};

	module.exports.schema = [
	    {
	        "type": "object",
	        "properties": {
	            "props": {"type": "boolean"}
	        },
	        "additionalProperties": false
	    }
	];


/***/ },
/* 258 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Disallow the use of process.env()
	 * @author Vignesh Anand
	 * @copyright 2014 Vignesh Anand. All rights reserved.
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {

	        "MemberExpression": function(node) {
	            var objectName = node.object.name,
	                propertyName = node.property.name;

	            if (objectName === "process" && !node.computed && propertyName && propertyName === "env") {
	                context.report(node, "Unexpected use of process.env.");
	            }

	        }

	    };

	};

	module.exports.schema = [];


/***/ },
/* 259 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag usage of __proto__ property
	 * @author Ilya Volodin
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {

	        "MemberExpression": function(node) {

	            if (node.property &&
	                    (node.property.type === "Identifier" && node.property.name === "__proto__" && !node.computed) ||
	                    (node.property.type === "Literal" && node.property.value === "__proto__")) {
	                context.report(node, "The '__proto__' property is deprecated.");
	            }
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 260 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag when the same variable is declared more then once.
	 * @author Ilya Volodin
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {
	    var options = {
	        builtinGlobals: Boolean(context.options[0] && context.options[0].builtinGlobals)
	    };

	    /**
	     * Gets the names of writeable built-in variables.
	     * @param {escope.Scope} scope - A scope to get.
	     * @returns {object} A map that its key is a variable name.
	     */
	    function getBuiltinGlobals(scope) {
	        return scope.variables.reduce(function(retv, variable) {
	            if ("writeable" in variable && variable.name !== "__proto__") {
	                retv[variable.name] = true;
	            }
	            return retv;
	        }, Object.create(null));
	    }

	    /**
	     * Find variables in a given scope and flag redeclared ones.
	     * @param {Scope} scope - An escope scope object.
	     * @param {object} builtins - A map that its key is a variable name.
	     * @returns {void}
	     * @private
	     */
	    function findVariablesInScope(scope, builtins) {
	        scope.variables.forEach(function(variable) {
	            var hasBuiltin = (
	                options.builtinGlobals &&
	                ("writeable" in variable || Boolean(builtins && builtins[variable.name]))
	            );
	            var count = (hasBuiltin ? 1 : 0) + variable.identifiers.length;

	            if (count >= 2) {
	                variable.identifiers.sort(function(a, b) {
	                    return a.range[1] - b.range[1];
	                });

	                for (var i = (hasBuiltin ? 0 : 1), l = variable.identifiers.length; i < l; i++) {
	                    context.report(
	                        variable.identifiers[i],
	                        "{{a}} is already defined",
	                        {a: variable.name});
	                }
	            }
	        });

	    }

	    /**
	     * Find variables in the current scope.
	     * @returns {void}
	     * @private
	     */
	    function checkForGlobal() {
	        var scope = context.getScope();

	        // Nodejs env or modules has a special scope.
	        // But built-in global variables are not there.
	        if (context.ecmaFeatures.globalReturn || context.ecmaFeatures.modules) {
	            var builtins = (options.builtinGlobals ? getBuiltinGlobals(scope) : null);
	            findVariablesInScope(scope.childScopes[0], builtins);
	        } else {
	            findVariablesInScope(scope);
	        }
	    }

	    /**
	     * Find variables in the current scope.
	     * @returns {void}
	     * @private
	     */
	    function checkForBlock() {
	        findVariablesInScope(context.getScope());
	    }

	    if (context.ecmaFeatures.blockBindings) {
	        return {
	            "Program": checkForGlobal,
	            "BlockStatement": checkForBlock,
	            "SwitchStatement": checkForBlock
	        };
	    } else {
	        return {
	            "Program": checkForGlobal,
	            "FunctionDeclaration": checkForBlock,
	            "FunctionExpression": checkForBlock,
	            "ArrowFunctionExpression": checkForBlock
	        };
	    }
	};

	module.exports.schema = [
	    {
	        "type": "object",
	        "properties": {
	            "builtinGlobals": {"type": "boolean"}
	        },
	        "additionalProperties": false
	    }
	];


/***/ },
/* 261 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag when return statement contains assignment
	 * @author Ilya Volodin
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------

	/**
	 * Checks whether or not a node is an `AssignmentExpression`.
	 * @param {Node|null} node - A node to check.
	 * @returns {boolean} Whether or not the node is an `AssignmentExpression`.
	 */
	function isAssignment(node) {
	    return node != null && node.type === "AssignmentExpression";
	}

	/**
	 * Checks whether or not a node is enclosed in parentheses.
	 * @param {Node|null} node - A node to check.
	 * @param {RuleContext} context - The current context.
	 * @returns {boolean} Whether or not the node is enclosed in parentheses.
	 */
	function isEnclosedInParens(node, context) {
	    var prevToken = context.getTokenBefore(node);
	    var nextToken = context.getTokenAfter(node);

	    return prevToken.value === "(" && nextToken.value === ")";
	}

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {
	    var always = (context.options[0] || "except-parens") !== "except-parens";

	    return {
	        "ReturnStatement": function(node) {
	            if (isAssignment(node.argument) && (always || !isEnclosedInParens(node.argument, context))) {
	                context.report(node, "Return statement should not contain assignment.");
	            }
	        }
	    };
	};

	module.exports.schema = [
	    {
	        "enum": ["except-parens", "always"]
	    }
	];


/***/ },
/* 262 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag when using javascript: urls
	 * @author Ilya Volodin
	 */
	/* jshint scripturl: true */
	/* eslint no-script-url: 0 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {

	        "Literal": function(node) {

	            var value;

	            if (node.value && typeof node.value === "string") {
	                value = node.value.toLowerCase();

	                if (value.indexOf("javascript:") === 0) {
	                    context.report(node, "Script URL is a form of eval.");
	                }
	            }
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 263 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag comparison where left part is the same as the right
	 * part.
	 * @author Ilya Volodin
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {

	        "BinaryExpression": function(node) {
	            var operators = ["===", "==", "!==", "!=", ">", "<", ">=", "<="];
	            if (operators.indexOf(node.operator) > -1 &&
	                (node.left.type === "Identifier" && node.right.type === "Identifier" && node.left.name === node.right.name ||
	                node.left.type === "Literal" && node.right.type === "Literal" && node.left.value === node.right.value)) {
	                context.report(node, "Comparing to itself is potentially pointless.");
	            }
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 264 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag use of comma operator
	 * @author Brandon Mills
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    /**
	     * Parts of the grammar that are required to have parens.
	     */
	    var parenthesized = {
	        "DoWhileStatement": "test",
	        "IfStatement": "test",
	        "SwitchStatement": "discriminant",
	        "WhileStatement": "test",
	        "WithStatement": "object"

	        // Omitting CallExpression - commas are parsed as argument separators
	        // Omitting NewExpression - commas are parsed as argument separators
	        // Omitting ForInStatement - parts aren't individually parenthesised
	        // Omitting ForStatement - parts aren't individually parenthesised
	    };

	    /**
	     * Determines whether a node is required by the grammar to be wrapped in
	     * parens, e.g. the test of an if statement.
	     * @param {ASTNode} node - The AST node
	     * @returns {boolean} True if parens around node belong to parent node.
	     */
	    function requiresExtraParens(node) {
	        return node.parent && parenthesized[node.parent.type] != null &&
	                node === node.parent[parenthesized[node.parent.type]];
	    }

	    /**
	     * Check if a node is wrapped in parens.
	     * @param {ASTNode} node - The AST node
	     * @returns {boolean} True if the node has a paren on each side.
	     */
	    function isParenthesised(node) {
	        var previousToken = context.getTokenBefore(node),
	            nextToken = context.getTokenAfter(node);

	        return previousToken && nextToken &&
	            previousToken.value === "(" && previousToken.range[1] <= node.range[0] &&
	            nextToken.value === ")" && nextToken.range[0] >= node.range[1];
	    }

	    /**
	     * Check if a node is wrapped in two levels of parens.
	     * @param {ASTNode} node - The AST node
	     * @returns {boolean} True if two parens surround the node on each side.
	     */
	    function isParenthesisedTwice(node) {
	        var previousToken = context.getTokenBefore(node, 1),
	            nextToken = context.getTokenAfter(node, 1);

	        return isParenthesised(node) && previousToken && nextToken &&
	            previousToken.value === "(" && previousToken.range[1] <= node.range[0] &&
	            nextToken.value === ")" && nextToken.range[0] >= node.range[1];
	    }

	    return {
	        "SequenceExpression": function(node) {
	            // Always allow sequences in for statement update
	            if (node.parent.type === "ForStatement" &&
	                    (node === node.parent.init || node === node.parent.update)) {
	                return;
	            }

	            // Wrapping a sequence in extra parens indicates intent
	            if (requiresExtraParens(node)) {
	                if (isParenthesisedTwice(node)) {
	                    return;
	                }
	            } else {
	                if (isParenthesised(node)) {
	                    return;
	                }
	            }

	            context.report(node, "Unexpected use of comma operator.");
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 265 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to restrict what can be thrown as an exception.
	 * @author Dieter Oberkofler
	 * @copyright 2015 Ian VanSchooten. All rights reserved.
	 * @copyright 2015 Dieter Oberkofler. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------

	/**
	 * Determine if a node has a possiblity to be an Error object
	 * @param  {ASTNode}  node  ASTNode to check
	 * @returns {boolean}       True if there is a chance it contains an Error obj
	 */
	function couldBeError(node) {
	    switch (node.type) {
	        case "Identifier":
	        case "CallExpression":
	        case "NewExpression":
	        case "MemberExpression":
	        case "TaggedTemplateExpression":
	        case "YieldExpression":
	            return true; // possibly an error object.

	        case "AssignmentExpression":
	            return couldBeError(node.right);

	        case "SequenceExpression":
	            var exprs = node.expressions;
	            return exprs.length !== 0 && couldBeError(exprs[exprs.length - 1]);

	        case "LogicalExpression":
	            return couldBeError(node.left) || couldBeError(node.right);

	        case "ConditionalExpression":
	            return couldBeError(node.consequent) || couldBeError(node.alternate);

	        default:
	            return false;
	    }
	}

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {

	        "ThrowStatement": function(node) {
	            if (!couldBeError(node.argument)) {
	                context.report(node, "Expected an object to be thrown.");
	            } else if (node.argument.type === "Identifier") {
	                if (node.argument.name === "undefined") {
	                    context.report(node, "Do not throw undefined.");
	                }
	            }

	        }

	    };

	};

	module.exports.schema = [];


/***/ },
/* 266 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Flag expressions in statement position that do not side effect
	 * @author Michael Ficarra
	 * @copyright 2013 Michael Ficarra. All rights reserved.
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    /**
	     * @param {ASTNode} node - any node
	     * @returns {Boolean} whether the given node structurally represents a directive
	     */
	    function looksLikeDirective(node) {
	        return node.type === "ExpressionStatement" &&
	            node.expression.type === "Literal" && typeof node.expression.value === "string";
	    }

	    /**
	     * @param {Function} predicate - ([a] -> Boolean) the function used to make the determination
	     * @param {a[]} list - the input list
	     * @returns {a[]} the leading sequence of members in the given list that pass the given predicate
	     */
	    function takeWhile(predicate, list) {
	        for (var i = 0, l = list.length; i < l; ++i) {
	            if (!predicate(list[i])) {
	                break;
	            }
	        }
	        return [].slice.call(list, 0, i);
	    }

	    /**
	     * @param {ASTNode} node - a Program or BlockStatement node
	     * @returns {ASTNode[]} the leading sequence of directive nodes in the given node's body
	     */
	    function directives(node) {
	        return takeWhile(looksLikeDirective, node.body);
	    }

	    /**
	     * @param {ASTNode} node - any node
	     * @param {ASTNode[]} ancestors - the given node's ancestors
	     * @returns {Boolean} whether the given node is considered a directive in its current position
	     */
	    function isDirective(node, ancestors) {
	        var parent = ancestors[ancestors.length - 1],
	            grandparent = ancestors[ancestors.length - 2];
	        return (parent.type === "Program" || parent.type === "BlockStatement" &&
	                (/Function/.test(grandparent.type))) &&
	                directives(parent).indexOf(node) >= 0;
	    }

	    return {
	        "ExpressionStatement": function(node) {

	            var type = node.expression.type,
	                ancestors = context.getAncestors();

	            if (
	                !/^(?:Assignment|Call|New|Update|Yield)Expression$/.test(type) &&
	                (type !== "UnaryExpression" || ["delete", "void"].indexOf(node.expression.operator) < 0) &&
	                !isDirective(node, ancestors)
	            ) {
	                context.report(node, "Expected an assignment or function call and instead saw an expression.");
	            }
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview A rule to disallow unnecessary `.call()` and `.apply()`.
	 * @author Toru Nagashima
	 * @copyright 2015 Toru Nagashima. All rights reserved.
	 */

	"use strict";

	var astUtils = __webpack_require__(177);

	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------

	/**
	 * Checks whether or not a node is a `.call()`/`.apply()`.
	 * @param {ASTNode} node - A CallExpression node to check.
	 * @returns {boolean} Whether or not the node is a `.call()`/`.apply()`.
	 */
	function isCallOrNonVariadicApply(node) {
	    return (
	        node.callee.type === "MemberExpression" &&
	        node.callee.property.type === "Identifier" &&
	        node.callee.computed === false &&
	        (
	            (node.callee.property.name === "call" && node.arguments.length >= 1) ||
	            (node.callee.property.name === "apply" && node.arguments.length === 2 && node.arguments[1].type === "ArrayExpression")
	        )
	    );
	}

	/**
	 * Checks whether or not the tokens of two given nodes are same.
	 * @param {ASTNode} left - A node 1 to compare.
	 * @param {ASTNode} right - A node 2 to compare.
	 * @param {RuleContext} context - The ESLint rule context object.
	 * @returns {boolean} the source code for the given node.
	 */
	function equalTokens(left, right, context) {
	    var tokensL = context.getTokens(left);
	    var tokensR = context.getTokens(right);

	    if (tokensL.length !== tokensR.length) {
	        return false;
	    }
	    for (var i = 0; i < tokensL.length; ++i) {
	        if (tokensL[i].type !== tokensR[i].type ||
	            tokensL[i].value !== tokensR[i].value
	        ) {
	            return false;
	        }
	    }

	    return true;
	}

	/**
	 * Checks whether or not `thisArg` is not changed by `.call()`/`.apply()`.
	 * @param {ASTNode|null} expectedThis - The node that is the owner of the applied function.
	 * @param {ASTNode} thisArg - The node that is given to the first argument of the `.call()`/`.apply()`.
	 * @param {RuleContext} context - The ESLint rule context object.
	 * @returns {boolean} Whether or not `thisArg` is not changed by `.call()`/`.apply()`.
	 */
	function isValidThisArg(expectedThis, thisArg, context) {
	    if (expectedThis == null) {
	        return astUtils.isNullOrUndefined(thisArg);
	    }
	    return equalTokens(expectedThis, thisArg, context);
	}

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {
	    return {
	        "CallExpression": function(node) {
	            if (!isCallOrNonVariadicApply(node)) {
	                return;
	            }

	            var applied = node.callee.object;
	            var expectedThis = (applied.type === "MemberExpression") ? applied.object : null;
	            var thisArg = node.arguments[0];

	            if (isValidThisArg(expectedThis, thisArg, context)) {
	                context.report(
	                    node,
	                    "unnecessary \".{{name}}()\".",
	                    {name: node.callee.property.name});
	            }
	        }
	    };
	};

	module.exports.schema = [];


/***/ },
/* 268 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to disallow use of void operator.
	 * @author Mike Sidorov
	 * @copyright 2014 Mike Sidorov. All rights reserved.
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    //--------------------------------------------------------------------------
	    // Public
	    //--------------------------------------------------------------------------

	    return {
	        "UnaryExpression": function(node) {
	            if (node.operator === "void") {
	                context.report(node, "Expected 'undefined' and instead saw 'void'.");
	            }
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 269 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule that warns about used warning comments
	 * @author Alexander Schmidt <https://github.com/lxanders>
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var configuration = context.options[0] || {},
	        warningTerms = configuration.terms || ["todo", "fixme", "xxx"],
	        location = configuration.location || "start",
	        warningRegExps;

	    /**
	     * Convert a warning term into a RegExp which will match a comment containing that whole word in the specified
	     * location ("start" or "anywhere"). If the term starts or ends with non word characters, then the match will not
	     * require word boundaries on that side.
	     *
	     * @param {String} term A term to convert to a RegExp
	     * @returns {RegExp} The term converted to a RegExp
	     */
	    function convertToRegExp(term) {
	        var escaped = term.replace(/[-\/\\$\^*+?.()|\[\]{}]/g, "\\$&"),
	            // If the term ends in a word character (a-z0-9_), ensure a word boundary at the end, so that substrings do
	            // not get falsely matched. eg "todo" in a string such as "mastodon".
	            // If the term ends in a non-word character, then \b won't match on the boundary to the next non-word
	            // character, which would likely be a space. For example `/\bFIX!\b/.test('FIX! blah') === false`.
	            // In these cases, use no bounding match. Same applies for the prefix, handled below.
	            suffix = /\w$/.test(term) ? "\\b" : "",
	            prefix;

	        if (location === "start") {
	            // When matching at the start, ignore leading whitespace, and there's no need to worry about word boundaries
	            prefix = "^\\s*";
	        } else if (/^\w/.test(term)) {
	            prefix = "\\b";
	        } else {
	            prefix = "";
	        }

	        return new RegExp(prefix + escaped + suffix, "i");
	    }

	    /**
	     * Checks the specified comment for matches of the configured warning terms and returns the matches.
	     * @param {String} comment The comment which is checked.
	     * @returns {Array} All matched warning terms for this comment.
	     */
	    function commentContainsWarningTerm(comment) {
	        var matches = [];

	        warningRegExps.forEach(function(regex, index) {
	            if (regex.test(comment)) {
	                matches.push(warningTerms[index]);
	            }
	        });

	        return matches;
	    }

	    /**
	     * Checks the specified node for matching warning comments and reports them.
	     * @param {ASTNode} node The AST node being checked.
	     * @returns {void} undefined.
	     */
	    function checkComment(node) {
	        var matches = commentContainsWarningTerm(node.value);

	        matches.forEach(function(matchedTerm) {
	            context.report(node, "Unexpected " + matchedTerm + " comment.");
	        });
	    }

	    warningRegExps = warningTerms.map(convertToRegExp);
	    return {
	        "BlockComment": checkComment,
	        "LineComment": checkComment
	    };
	};

	module.exports.schema = [
	    {
	        "type": "object",
	        "properties": {
	            "terms": {
	                "type": "array",
	                "items": {
	                    "type": "string"
	                }
	            },
	            "location": {
	                "enum": ["start", "anywhere"]
	            }
	        },
	        "additionalProperties": false
	    }
	];


/***/ },
/* 270 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag use of with statement
	 * @author Nicholas C. Zakas
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {
	        "WithStatement": function(node) {
	            context.report(node, "Unexpected use of 'with' statement.");
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 271 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag use of parseInt without a radix argument
	 * @author James Allardice
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {
	        "CallExpression": function(node) {

	            var radix;

	            if (node.callee.name === "parseInt") {

	                if (node.arguments.length < 2) {
	                    context.report(node, "Missing radix parameter.");
	                } else {

	                    radix = node.arguments[1];

	                    // don't allow non-numeric literals or undefined
	                    if ((radix.type === "Literal" && typeof radix.value !== "number") ||
	                        (radix.type === "Identifier" && radix.name === "undefined")
	                    ) {
	                        context.report(node, "Invalid radix parameter.");
	                    }
	                }

	            }
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 272 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to enforce var declarations are only at the top of a function.
	 * @author Danny Fritz
	 * @author Gyandeep Singh
	 * @copyright 2014 Danny Fritz. All rights reserved.
	 * @copyright 2014 Gyandeep Singh. All rights reserved.
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {
	    var errorMessage = "All \"var\" declarations must be at the top of the function scope.";

	    //--------------------------------------------------------------------------
	    // Helpers
	    //--------------------------------------------------------------------------

	    /**
	     * @param {ASTNode} node - any node
	     * @returns {Boolean} whether the given node structurally represents a directive
	     */
	    function looksLikeDirective(node) {
	        return node.type === "ExpressionStatement" &&
	            node.expression.type === "Literal" && typeof node.expression.value === "string";
	    }

	    /**
	     * Check to see if its a ES6 import declaration
	     * @param {ASTNode} node - any node
	     * @returns {Boolean} whether the given node represents a import declaration
	     */
	    function looksLikeImport(node) {
	        return node.type === "ImportDeclaration" || node.type === "ImportSpecifier" ||
	            node.type === "ImportDefaultSpecifier" || node.type === "ImportNamespaceSpecifier";
	    }

	    /**
	     * Checks whether this variable is on top of the block body
	     * @param {ASTNode} node - The node to check
	     * @param {ASTNode[]} statements - collection of ASTNodes for the parent node block
	     * @returns {Boolean} True if var is on top otherwise false
	     */
	    function isVarOnTop(node, statements) {
	        var i = 0, l = statements.length;

	        // skip over directives
	        for (; i < l; ++i) {
	            if (!looksLikeDirective(statements[i]) && !looksLikeImport(statements[i])) {
	                break;
	            }
	        }

	        for (; i < l; ++i) {
	            if (statements[i].type !== "VariableDeclaration") {
	                return false;
	            }
	            if (statements[i] === node) {
	                return true;
	            }
	        }
	    }

	    /**
	     * Checks whether variable is on top at the global level
	     * @param {ASTNode} node - The node to check
	     * @param {ASTNode} parent - Parent of the node
	     * @returns {void}
	     */
	    function globalVarCheck(node, parent) {
	        if (!isVarOnTop(node, parent.body)) {
	            context.report(node, errorMessage);
	        }
	    }

	    /**
	     * Checks whether variable is on top at functional block scope level
	     * @param {ASTNode} node - The node to check
	     * @param {ASTNode} parent - Parent of the node
	     * @param {ASTNode} grandParent - Parent of the node's parent
	     * @returns {void}
	     */
	    function blockScopeVarCheck(node, parent, grandParent) {
	        if (!(/Function/.test(grandParent.type) &&
	                parent.type === "BlockStatement" &&
	                isVarOnTop(node, parent.body))) {
	            context.report(node, errorMessage);
	        }
	    }

	    //--------------------------------------------------------------------------
	    // Public API
	    //--------------------------------------------------------------------------

	    return {
	        "VariableDeclaration": function(node) {
	            var ancestors = context.getAncestors();
	            var parent = ancestors.pop();
	            var grandParent = ancestors.pop();

	            if (node.kind === "var") {// check variable is `var` type and not `let` or `const`
	                if (parent.type === "Program") {// That means its a global variable
	                    globalVarCheck(node, parent);
	                } else {
	                    blockScopeVarCheck(node, parent, grandParent);
	                }
	            }
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 273 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag when IIFE is not wrapped in parens
	 * @author Ilya Volodin
	 * @copyright 2013 Ilya Volodin. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var style = context.options[0] || "outside";

	    function wrapped(node) {
	        var previousToken = context.getTokenBefore(node),
	            nextToken = context.getTokenAfter(node);
	        return previousToken && previousToken.value === "(" &&
	            nextToken && nextToken.value === ")";
	    }

	    return {

	        "CallExpression": function(node) {
	            if (node.callee.type === "FunctionExpression") {
	                var callExpressionWrapped = wrapped(node),
	                    functionExpressionWrapped = wrapped(node.callee);

	                if (!callExpressionWrapped && !functionExpressionWrapped) {
	                    context.report(node, "Wrap an immediate function invocation in parentheses.");
	                } else if (style === "inside" && !functionExpressionWrapped) {
	                    context.report(node, "Wrap only the function expression in parens.");
	                } else if (style === "outside" && !callExpressionWrapped) {
	                    context.report(node, "Move the invocation into the parens that contain the function.");
	                }
	            }
	        }
	    };

	};

	module.exports.schema = [
	    {
	        "enum": ["outside", "inside", "any"]
	    }
	];


/***/ },
/* 274 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to require or disallow yoda comparisons
	 * @author Nicholas C. Zakas
	 * @copyright 2014 Nicholas C. Zakas. All rights reserved.
	 * @copyright 2014 Brandon Mills. All rights reserved.
	 */
	"use strict";

	//--------------------------------------------------------------------------
	// Helpers
	//--------------------------------------------------------------------------

	/**
	 * Determines whether an operator is a comparison operator.
	 * @param {String} operator The operator to check.
	 * @returns {boolean} Whether or not it is a comparison operator.
	 */
	function isComparisonOperator(operator) {
	    return (/^(==|===|!=|!==|<|>|<=|>=)$/).test(operator);
	}

	/**
	 * Determines whether an operator is an equality operator.
	 * @param {String} operator The operator to check.
	 * @returns {boolean} Whether or not it is an equality operator.
	 */
	function isEqualityOperator(operator) {
	    return (/^(==|===)$/).test(operator);
	}

	/**
	 * Determines whether an operator is one used in a range test.
	 * Allowed operators are `<` and `<=`.
	 * @param {String} operator The operator to check.
	 * @returns {boolean} Whether the operator is used in range tests.
	 */
	function isRangeTestOperator(operator) {
	    return ["<", "<="].indexOf(operator) >= 0;
	}

	/**
	 * Determines whether a non-Literal node is a negative number that should be
	 * treated as if it were a single Literal node.
	 * @param {ASTNode} node Node to test.
	 * @returns {boolean} True if the node is a negative number that looks like a
	 *                    real literal and should be treated as such.
	 */
	function looksLikeLiteral(node) {
	    return (node.type === "UnaryExpression" &&
	        node.operator === "-" &&
	        node.prefix &&
	        node.argument.type === "Literal" &&
	        typeof node.argument.value === "number");
	}

	/**
	 * Attempts to derive a Literal node from nodes that are treated like literals.
	 * @param {ASTNode} node Node to normalize.
	 * @returns {ASTNode} The original node if the node is already a Literal, or a
	 *                    normalized Literal node with the negative number as the
	 *                    value if the node represents a negative number literal,
	 *                    otherwise null if the node cannot be converted to a
	 *                    normalized literal.
	 */
	function getNormalizedLiteral(node) {
	    if (node.type === "Literal") {
	        return node;
	    }

	    if (looksLikeLiteral(node)) {
	        return {
	            type: "Literal",
	            value: -node.argument.value,
	            raw: "-" + node.argument.value
	        };
	    }

	    return null;
	}

	/**
	 * Checks whether two expressions reference the same value. For example:
	 *     a = a
	 *     a.b = a.b
	 *     a[0] = a[0]
	 *     a['b'] = a['b']
	 * @param   {ASTNode} a Left side of the comparison.
	 * @param   {ASTNode} b Right side of the comparison.
	 * @returns {boolean}   True if both sides match and reference the same value.
	 */
	function same(a, b) {
	    if (a.type !== b.type) {
	        return false;
	    }

	    switch (a.type) {
	        case "Identifier":
	            return a.name === b.name;
	        case "Literal":
	            return a.value === b.value;
	        case "MemberExpression":
	            // x[0] = x[0]
	            // x[y] = x[y]
	            // x.y = x.y
	            return same(a.object, b.object) && same(a.property, b.property);
	        case "ThisExpression":
	            return true;
	        default:
	            return false;
	    }
	}

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    // Default to "never" (!always) if no option
	    var always = (context.options[0] === "always");
	    var exceptRange = (context.options[1] && context.options[1].exceptRange);
	    var onlyEquality = (context.options[1] && context.options[1].onlyEquality);

	    /**
	     * Determines whether node represents a range test.
	     * A range test is a "between" test like `(0 <= x && x < 1)` or an "outside"
	     * test like `(x < 0 || 1 <= x)`. It must be wrapped in parentheses, and
	     * both operators must be `<` or `<=`. Finally, the literal on the left side
	     * must be less than or equal to the literal on the right side so that the
	     * test makes any sense.
	     * @param {ASTNode} node LogicalExpression node to test.
	     * @returns {Boolean} Whether node is a range test.
	     */
	    function isRangeTest(node) {
	        var left = node.left,
	            right = node.right;

	        /**
	         * Determines whether node is of the form `0 <= x && x < 1`.
	         * @returns {Boolean} Whether node is a "between" range test.
	         */
	        function isBetweenTest() {
	            var leftLiteral, rightLiteral;

	            return (node.operator === "&&" &&
	                (leftLiteral = getNormalizedLiteral(left.left)) &&
	                (rightLiteral = getNormalizedLiteral(right.right)) &&
	                leftLiteral.value <= rightLiteral.value &&
	                same(left.right, right.left));
	        }

	        /**
	         * Determines whether node is of the form `x < 0 || 1 <= x`.
	         * @returns {Boolean} Whether node is an "outside" range test.
	         */
	        function isOutsideTest() {
	            var leftLiteral, rightLiteral;

	            return (node.operator === "||" &&
	                (leftLiteral = getNormalizedLiteral(left.right)) &&
	                (rightLiteral = getNormalizedLiteral(right.left)) &&
	                leftLiteral.value <= rightLiteral.value &&
	                same(left.left, right.right));
	        }

	        /**
	         * Determines whether node is wrapped in parentheses.
	         * @returns {Boolean} Whether node is preceded immediately by an open
	         *                    paren token and followed immediately by a close
	         *                    paren token.
	         */
	        function isParenWrapped() {
	            var tokenBefore, tokenAfter;

	            return ((tokenBefore = context.getTokenBefore(node)) &&
	                tokenBefore.value === "(" &&
	                (tokenAfter = context.getTokenAfter(node)) &&
	                tokenAfter.value === ")");
	        }

	        return (node.type === "LogicalExpression" &&
	            left.type === "BinaryExpression" &&
	            right.type === "BinaryExpression" &&
	            isRangeTestOperator(left.operator) &&
	            isRangeTestOperator(right.operator) &&
	            (isBetweenTest() || isOutsideTest()) &&
	            isParenWrapped());
	    }

	    //--------------------------------------------------------------------------
	    // Public
	    //--------------------------------------------------------------------------

	    return {
	        "BinaryExpression": always ? function(node) {

	            // Comparisons must always be yoda-style: if ("blue" === color)
	            if (
	                (node.right.type === "Literal" || looksLikeLiteral(node.right)) &&
	                !(node.left.type === "Literal" || looksLikeLiteral(node.left)) &&
	                !(!isEqualityOperator(node.operator) && onlyEquality) &&
	                isComparisonOperator(node.operator) &&
	                !(exceptRange && isRangeTest(context.getAncestors().pop()))
	            ) {
	                context.report(node, "Expected literal to be on the left side of " + node.operator + ".");
	            }

	        } : function(node) {

	            // Comparisons must never be yoda-style (default)
	            if (
	                (node.left.type === "Literal" || looksLikeLiteral(node.left)) &&
	                !(node.right.type === "Literal" || looksLikeLiteral(node.right)) &&
	                !(!isEqualityOperator(node.operator) && onlyEquality) &&
	                isComparisonOperator(node.operator) &&
	                !(exceptRange && isRangeTest(context.getAncestors().pop()))
	            ) {
	                context.report(node, "Expected literal to be on the right side of " + node.operator + ".");
	            }

	        }
	    };

	};

	module.exports.schema = [
	    {
	        "enum": ["always", "never"]
	    },
	    {
	        "type": "object",
	        "properties": {
	            "exceptRange": {
	                "type": "boolean"
	            },
	            "onlyEquality": {
	                "type": "boolean"
	            }
	        },
	        "additionalProperties": false
	    }
	];


/***/ },
/* 275 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to control usage of strict mode directives.
	 * @author Brandon Mills
	 * @copyright 2015 Brandon Mills. All rights reserved.
	 * @copyright 2013-2014 Nicholas C. Zakas. All rights reserved.
	 * @copyright 2013 Ian Christian Myers. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------

	var messages = {
	    function: "Use the function form of \"use strict\".",
	    global: "Use the global form of \"use strict\".",
	    multiple: "Multiple \"use strict\" directives.",
	    never: "Strict mode is not permitted.",
	    unnecessary: "Unnecessary \"use strict\" directive.",
	    unnecessaryInModules: "\"use strict\" is unnecessary inside of modules.",
	    unnecessaryInClasses: "\"use strict\" is unnecessary inside of classes."
	};

	/**
	 * Gets all of the Use Strict Directives in the Directive Prologue of a group of
	 * statements.
	 * @param {ASTNode[]} statements Statements in the program or function body.
	 * @returns {ASTNode[]} All of the Use Strict Directives.
	 */
	function getUseStrictDirectives(statements) {
	    var directives = [],
	        i, statement;

	    for (i = 0; i < statements.length; i++) {
	        statement = statements[i];

	        if (
	            statement.type === "ExpressionStatement" &&
	            statement.expression.type === "Literal" &&
	            statement.expression.value === "use strict"
	        ) {
	            directives[i] = statement;
	        } else {
	            break;
	        }
	    }

	    return directives;
	}

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var mode = context.options[0];

	    /**
	     * Report a node or array of nodes with a given message.
	     * @param {(ASTNode|ASTNode[])} nodes Node or nodes to report.
	     * @param {string} message Message to display.
	     * @returns {void}
	     */
	    function report(nodes, message) {
	        var i;

	        if (Array.isArray(nodes)) {
	            for (i = 0; i < nodes.length; i++) {
	                context.report(nodes[i], message);
	            }
	        } else {
	            context.report(nodes, message);
	        }
	    }

	    //--------------------------------------------------------------------------
	    // "never" mode
	    //--------------------------------------------------------------------------

	    if (mode === "never") {
	        return {
	            "Program": function(node) {
	                report(getUseStrictDirectives(node.body), messages.never);
	            },
	            "FunctionDeclaration": function(node) {
	                report(getUseStrictDirectives(node.body.body), messages.never);
	            },
	            "FunctionExpression": function(node) {
	                report(getUseStrictDirectives(node.body.body), messages.never);
	            },
	            "ArrowFunctionExpression": function(node) {
	                if (node.body.type === "BlockStatement") {
	                    report(getUseStrictDirectives(node.body.body), messages.never);
	                }
	            }
	        };
	    }

	    //--------------------------------------------------------------------------
	    // If this is modules, all "use strict" directives are unnecessary.
	    //--------------------------------------------------------------------------

	    if (context.ecmaFeatures.modules) {
	        return {
	            "Program": function(node) {
	                report(getUseStrictDirectives(node.body), messages.unnecessaryInModules);
	            },
	            "FunctionDeclaration": function(node) {
	                report(getUseStrictDirectives(node.body.body), messages.unnecessaryInModules);
	            },
	            "FunctionExpression": function(node) {
	                report(getUseStrictDirectives(node.body.body), messages.unnecessaryInModules);
	            },
	            "ArrowFunctionExpression": function(node) {
	                if (node.body.type === "BlockStatement") {
	                    report(getUseStrictDirectives(node.body.body), messages.unnecessaryInModules);
	                }
	            }
	        };
	    }

	    //--------------------------------------------------------------------------
	    // "global" mode
	    //--------------------------------------------------------------------------

	    if (mode === "global") {
	        return {
	            "Program": function(node) {
	                var useStrictDirectives = getUseStrictDirectives(node.body);

	                if (node.body.length > 0 && useStrictDirectives.length === 0) {
	                    report(node, messages.global);
	                } else {
	                    report(useStrictDirectives.slice(1), messages.multiple);
	                }
	            },
	            "FunctionDeclaration": function(node) {
	                report(getUseStrictDirectives(node.body.body), messages.global);
	            },
	            "FunctionExpression": function(node) {
	                report(getUseStrictDirectives(node.body.body), messages.global);
	            },
	            "ArrowFunctionExpression": function(node) {
	                if (node.body.type === "BlockStatement") {
	                    report(getUseStrictDirectives(node.body.body), messages.global);
	                }
	            }
	        };
	    }

	    //--------------------------------------------------------------------------
	    // "function" mode (Default)
	    //--------------------------------------------------------------------------

	    var scopes = [],
	        classScopes = [];

	    /**
	     * Entering a function pushes a new nested scope onto the stack. The new
	     * scope is true if the nested function is strict mode code.
	     * @param {ASTNode} node The function declaration or expression.
	     * @returns {void}
	     */
	    function enterFunction(node) {
	        var isInClass = classScopes.length > 0,
	            isParentGlobal = scopes.length === 0 && classScopes.length === 0,
	            isParentStrict = scopes.length > 0 && scopes[scopes.length - 1],
	            isNotBlock = node.body.type !== "BlockStatement",
	            useStrictDirectives = isNotBlock ? [] : getUseStrictDirectives(node.body.body),
	            isStrict = useStrictDirectives.length > 0;

	        if (isStrict) {
	            if (isParentStrict) {
	                report(useStrictDirectives[0], messages.unnecessary);
	            } else if (isInClass) {
	                report(useStrictDirectives[0], messages.unnecessaryInClasses);
	            }

	            report(useStrictDirectives.slice(1), messages.multiple);
	        } else if (isParentGlobal) {
	            report(node, messages.function);
	        }

	        scopes.push(isParentStrict || isStrict);
	    }

	    /**
	     * Exiting a function pops its scope off the stack.
	     * @returns {void}
	     */
	    function exitFunction() {
	        scopes.pop();
	    }

	    return {
	        "Program": function(node) {
	            report(getUseStrictDirectives(node.body), messages.function);
	        },

	        // Inside of class bodies are always strict mode.
	        "ClassBody": function() {
	            classScopes.push(true);
	        },
	        "ClassBody:exit": function() {
	            classScopes.pop();
	        },

	        "FunctionDeclaration": enterFunction,
	        "FunctionExpression": enterFunction,
	        "ArrowFunctionExpression": enterFunction,

	        "FunctionDeclaration:exit": exitFunction,
	        "FunctionExpression:exit": exitFunction,
	        "ArrowFunctionExpression:exit": exitFunction
	    };
	};

	module.exports.schema = [
	    {
	        "enum": ["never", "global", "function"]
	    }
	];


/***/ },
/* 276 */
/***/ function(module, exports) {

	/**
	 * @fileoverview A rule to control the style of variable initializations.
	 * @author Colin Ihrig
	 * @copyright 2015 Colin Ihrig. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------

	/**
	 * Checks whether or not a given declarator node has its initializer.
	 * @param {ASTNode} node - A declarator node to check.
	 * @returns {boolean} `true` when the node has its initializer.
	 */
	function isInitialized(node) {
	    var declaration = node.parent;
	    var block = declaration.parent;

	    if (block.type === "ForInStatement" || block.type === "ForOfStatement") {
	        return block.left === declaration;
	    }
	    return node.init != null;
	}

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var MODE_ALWAYS = "always",
	        MODE_NEVER = "never";

	    var mode = context.options[0] || MODE_ALWAYS;

	    //--------------------------------------------------------------------------
	    // Public API
	    //--------------------------------------------------------------------------

	    return {
	        "VariableDeclaration:exit": function(node) {

	            var kind = node.kind,
	                declarations = node.declarations;

	            for (var i = 0; i < declarations.length; ++i) {
	                var declaration = declarations[i],
	                    id = declaration.id,
	                    initialized = isInitialized(declaration);

	                if (id.type !== "Identifier") {
	                    continue;
	                }

	                if (mode === MODE_ALWAYS && !initialized) {
	                    context.report(declaration, "Variable '" + id.name + "' should be initialized on declaration.");
	                } else if (mode === MODE_NEVER && kind !== "const" && initialized) {
	                    context.report(declaration, "Variable '" + id.name + "' should not be initialized on declaration.");
	                }
	            }
	        }
	    };

	};

	module.exports.schema = [
	    {
	        "enum": ["always", "never"]
	    }
	];


/***/ },
/* 277 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag variable leak in CatchClauses in IE 8 and earlier
	 * @author Ian Christian Myers
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    //--------------------------------------------------------------------------
	    // Helpers
	    //--------------------------------------------------------------------------

	    function paramIsShadowing(scope, name) {
	        var found = scope.variables.some(function(variable) {
	            return variable.name === name;
	        });

	        if (found) {
	            return true;
	        }

	        if (scope.upper) {
	            return paramIsShadowing(scope.upper, name);
	        }

	        return false;
	    }

	    //--------------------------------------------------------------------------
	    // Public API
	    //--------------------------------------------------------------------------

	    return {

	        "CatchClause": function(node) {
	            var scope = context.getScope();

	            if (paramIsShadowing(scope, node.param.name)) {
	                context.report(node, "Value of '{{name}}' may be overwritten in IE 8 and earlier.",
	                        { name: node.param.name });
	            }
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 278 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag when deleting variables
	 * @author Ilya Volodin
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {

	        "UnaryExpression": function(node) {
	            if (node.operator === "delete" && node.argument.type === "Identifier") {
	                context.report(node, "Variables should not be deleted.");
	            }
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 279 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Disallow shadowing of NaN, undefined, and Infinity (ES5 section 15.1.1)
	 * @author Michael Ficarra
	 * @copyright 2013 Michael Ficarra. All rights reserved.
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var RESTRICTED = ["undefined", "NaN", "Infinity", "arguments", "eval"];

	    function checkForViolation(id) {
	        if (RESTRICTED.indexOf(id.name) > -1) {
	            context.report(id, "Shadowing of global property \"" + id.name + "\".");
	        }
	    }

	    return {
	        "VariableDeclarator": function(node) {
	            checkForViolation(node.id);
	        },
	        "ArrowFunctionExpression": function(node) {
	            if (node.id) {
	                checkForViolation(node.id);
	            }
	            [].map.call(node.params, checkForViolation);
	        },
	        "FunctionExpression": function(node) {
	            if (node.id) {
	                checkForViolation(node.id);
	            }
	            [].map.call(node.params, checkForViolation);
	        },
	        "FunctionDeclaration": function(node) {
	            if (node.id) {
	                checkForViolation(node.id);
	                [].map.call(node.params, checkForViolation);
	            }
	        },
	        "CatchClause": function(node) {
	            checkForViolation(node.param);
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 280 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag on declaring variables already declared in the outer scope
	 * @author Ilya Volodin
	 * @copyright 2013 Ilya Volodin. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var options = {
	        builtinGlobals: Boolean(context.options[0] && context.options[0].builtinGlobals),
	        hoist: (context.options[0] && context.options[0].hoist) || "functions"
	    };

	    /**
	     * Checks if a variable of the class name in the class scope of ClassDeclaration.
	     *
	     * ClassDeclaration creates two variables of its name into its outer scope and its class scope.
	     * So we should ignore the variable in the class scope.
	     *
	     * @param {Object} variable The variable to check.
	     * @returns {boolean} Whether or not the variable of the class name in the class scope of ClassDeclaration.
	     */
	    function isDuplicatedClassNameVariable(variable) {
	        var block = variable.scope.block;
	        return block.type === "ClassDeclaration" && block.id === variable.identifiers[0];
	    }

	    /**
	     * Checks if a variable is inside the initializer of scopeVar.
	     *
	     * To avoid reporting at declarations such as `var a = function a() {};`.
	     * But it should report `var a = function(a) {};` or `var a = function() { function a() {} };`.
	     *
	     * @param {Object} variable The variable to check.
	     * @param {Object} scopeVar The scope variable to look for.
	     * @returns {boolean} Whether or not the variable is inside initializer of scopeVar.
	     */
	    function isOnInitializer(variable, scopeVar) {
	        var outerScope = scopeVar.scope;
	        var outerDef = scopeVar.defs[0];
	        var outer = outerDef && outerDef.parent && outerDef.parent.range;
	        var innerScope = variable.scope;
	        var innerDef = variable.defs[0];
	        var inner = innerDef && innerDef.name.range;

	        return (
	            outer != null &&
	            inner != null &&
	            outer[0] < inner[0] &&
	            inner[1] < outer[1] &&
	            ((innerDef.type === "FunctionName" && innerDef.node.type === "FunctionExpression") || innerDef.node.type === "ClassExpression") &&
	            outerScope === innerScope.upper
	        );
	    }

	    /**
	     * Get a range of a variable's identifier node.
	     * @param {Object} variable The variable to get.
	     * @returns {Array|undefined} The range of the variable's identifier node.
	     */
	    function getNameRange(variable) {
	        var def = variable.defs[0];
	        return def && def.name.range;
	    }

	    /**
	     * Checks if a variable is in TDZ of scopeVar.
	     * @param {Object} variable The variable to check.
	     * @param {Object} scopeVar The variable of TDZ.
	     * @returns {boolean} Whether or not the variable is in TDZ of scopeVar.
	     */
	    function isInTdz(variable, scopeVar) {
	        var outerDef = scopeVar.defs[0];
	        var inner = getNameRange(variable);
	        var outer = getNameRange(scopeVar);
	        return (
	            inner != null &&
	            outer != null &&
	            inner[1] < outer[0] &&
	            // Excepts FunctionDeclaration if is {"hoist":"function"}.
	            (options.hoist !== "functions" || outerDef == null || outerDef.node.type !== "FunctionDeclaration")
	        );
	    }

	    /**
	     * Checks if a variable is contained in the list of given scope variables.
	     * @param {Object} variable The variable to check.
	     * @param {Array} scopeVars The scope variables to look for.
	     * @returns {boolean} Whether or not the variable is contains in the list of scope variables.
	     */
	    function isContainedInScopeVars(variable, scopeVars) {
	        return scopeVars.some(function(scopeVar) {
	            return (
	                (scopeVar.identifiers.length > 0 || (options.builtinGlobals && "writeable" in scopeVar)) &&
	                variable.name === scopeVar.name &&
	                !isDuplicatedClassNameVariable(scopeVar) &&
	                !isOnInitializer(variable, scopeVar) &&
	                !(options.hoist !== "all" && isInTdz(variable, scopeVar))
	            );
	        });
	    }

	    /**
	     * Checks if the given variables are shadowed in the given scope.
	     * @param {Array} variables The variables to look for
	     * @param {Object} scope The scope to be checked.
	     * @returns {Array} Variables which are not declared in the given scope.
	     */
	    function checkShadowsInScope(variables, scope) {

	        var passedVars = [];

	        variables.forEach(function(variable) {
	            // "arguments" is a special case that has no identifiers (#1759)
	            if (variable.identifiers.length > 0 && isContainedInScopeVars(variable, scope.variables)) {
	                context.report(
	                    variable.identifiers[0],
	                    "{{name}} is already declared in the upper scope.",
	                    {name: variable.name});
	            } else {
	                passedVars.push(variable);
	            }
	        });

	        return passedVars;
	    }

	    /**
	     * Checks the current context for shadowed variables.
	     * @param {Scope} scope - Fixme
	     * @returns {void}
	     */
	    function checkForShadows(scope) {
	        var variables = scope.variables.filter(function(variable) {
	            return (
	                // Skip "arguments".
	                variable.identifiers.length > 0 &&
	                // Skip variables of a class name in the class scope of ClassDeclaration.
	                !isDuplicatedClassNameVariable(variable)
	            );
	        });

	        // iterate through the array of variables and find duplicates with the upper scope
	        var upper = scope.upper;
	        while (upper && variables.length) {
	            variables = checkShadowsInScope(variables, upper);
	            upper = upper.upper;
	        }
	    }

	    return {
	        "Program:exit": function() {
	            // Nodejs env or modules has a special scope for globals.
	            var globalScope = context.getScope();
	            if (context.ecmaFeatures.globalReturn || context.ecmaFeatures.modules) {
	                globalScope = globalScope.childScopes[0];
	            }

	            var stack = globalScope.childScopes.slice();
	            var scope;

	            while (stack.length) {
	                scope = stack.pop();
	                stack.push.apply(stack, scope.childScopes);
	                checkForShadows(scope);
	            }
	        }
	    };

	};

	module.exports.schema = [
	    {
	        "type": "object",
	        "properties": {
	            "builtinGlobals": {"type": "boolean"},
	            "hoist": {"enum": ["all", "functions", "never"]}
	        },
	        "additionalProperties": false
	    }
	];


/***/ },
/* 281 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag when initializing to undefined
	 * @author Ilya Volodin
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {

	        "VariableDeclarator": function(node) {
	            var name = node.id.name;
	            var init = node.init && node.init.name;

	            if (init === "undefined") {
	                context.report(node, "It's not necessary to initialize '{{name}}' to undefined.", { name: name });
	            }
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 282 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag references to undeclared variables.
	 * @author Mark Macdonald
	 * @copyright 2015 Nicholas C. Zakas. All rights reserved.
	 * @copyright 2013 Mark Macdonald. All rights reserved.
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------

	// none!

	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------

	function isImplicitGlobal(variable) {
	    return variable.defs.every(function(def) {
	        return def.type === "ImplicitGlobalVariable";
	    });
	}

	/**
	 * Gets the declared variable, defined in `scope`, that `ref` refers to.
	 * @param {Scope} scope The scope in which to search.
	 * @param {Reference} ref The reference to find in the scope.
	 * @returns {Variable} The variable, or null if ref refers to an undeclared variable.
	 */
	function getDeclaredGlobalVariable(scope, ref) {
	    var declaredGlobal = null;
	    scope.variables.some(function(variable) {
	        if (variable.name === ref.identifier.name) {
	            // If it's an implicit global, it must have a `writeable` field (indicating it was declared)
	            if (!isImplicitGlobal(variable) || {}.hasOwnProperty.call(variable, "writeable")) {
	                declaredGlobal = variable;
	                return true;
	            }
	        }
	        return false;
	    });
	    return declaredGlobal;
	}

	/**
	 * Checks if the given node is the argument of a typeof operator.
	 * @param {ASTNode} node The AST node being checked.
	 * @returns {boolean} Whether or not the node is the argument of a typeof operator.
	 */
	function hasTypeOfOperator(node) {
	    var parent = node.parent;
	    return parent.type === "UnaryExpression" && parent.operator === "typeof";
	}

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var NOT_DEFINED_MESSAGE = "\"{{name}}\" is not defined.",
	        READ_ONLY_MESSAGE = "\"{{name}}\" is read only.";

	    return {

	        "Program:exit": function(/* node */) {

	            var globalScope = context.getScope();

	            globalScope.through.forEach(function(ref) {
	                var variable = getDeclaredGlobalVariable(globalScope, ref),
	                    name = ref.identifier.name;

	                if (hasTypeOfOperator(ref.identifier)) {
	                    return;
	                }

	                if (!variable) {
	                    context.report(ref.identifier, NOT_DEFINED_MESSAGE, { name: name });
	                } else if (ref.isWrite() && variable.writeable === false) {
	                    context.report(ref.identifier, READ_ONLY_MESSAGE, { name: name });
	                }
	            });

	        }

	    };

	};

	module.exports.schema = [];


/***/ },
/* 283 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag references to the undefined variable.
	 * @author Michael Ficarra
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {

	        "Identifier": function(node) {
	            if (node.name === "undefined") {
	                var parent = context.getAncestors().pop();
	                if (!parent || parent.type !== "MemberExpression" || node !== parent.property || parent.computed) {
	                    context.report(node, "Unexpected use of undefined.");
	                }
	            }
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 284 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag declared but unused variables
	 * @author Ilya Volodin
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var MESSAGE = "{{name}} is defined but never used";

	    var config = {
	        vars: "all",
	        args: "after-used"
	    };

	    if (context.options[0]) {
	        if (typeof context.options[0] === "string") {
	            config.vars = context.options[0];
	        } else {
	            config.vars = context.options[0].vars || config.vars;
	            config.args = context.options[0].args || config.args;
	        }
	    }

	    //--------------------------------------------------------------------------
	    // Helpers
	    //--------------------------------------------------------------------------


	    /**
	     * Determines if a given variable is being exported from a module.
	     * @param {Variable} variable - EScope variable object.
	     * @returns {boolean} True if the variable is exported, false if not.
	     * @private
	     */
	    function isExported(variable) {

	        var definition = variable.defs[0];

	        if (definition) {

	            var node = definition.node;
	            if (node.type === "VariableDeclarator") {
	                node = node.parent;
	            } else if (definition.type === "Parameter" && node.type === "FunctionDeclaration") {
	                return false;
	            }

	            return node.parent.type.indexOf("Export") === 0;
	        } else {
	            return false;
	        }
	    }

	    /**
	     * Determines if a reference is a read operation.
	     * @param {Reference} ref - An escope Reference
	     * @returns {Boolean} whether the given reference represents a read operation
	     * @private
	     */
	    function isReadRef(ref) {
	        return ref.isRead();
	    }

	    /**
	     * Determine if an identifier is referencing an enclosing function name.
	     * @param {Reference} ref - The reference to check.
	     * @param {ASTNode[]} nodes - The candidate function nodes.
	     * @returns {boolean} True if it's a self-reference, false if not.
	     * @private
	     */
	    function isSelfReference(ref, nodes) {
	        var scope = ref.from;

	        while (scope != null) {
	            if (nodes.indexOf(scope.block) >= 0) {
	                return true;
	            }

	            scope = scope.upper;
	        }

	        return false;
	    }

	    /**
	     * Determines if the variable is used.
	     * @param {Variable} variable - The variable to check.
	     * @param {Reference[]} references - The variable references to check.
	     * @returns {boolean} True if the variable is used
	     */
	    function isUsedVariable(variable, references) {
	        var functionNodes = variable.defs.filter(function(def) {
	            return def.type === "FunctionName";
	        }).map(function(def) {
	            return def.node;
	        }),
	            isFunctionDefinition = functionNodes.length > 0;

	        return references.some(function(ref) {
	            return isReadRef(ref) && !(isFunctionDefinition && isSelfReference(ref, functionNodes));
	        });
	    }

	    /**
	     * Gets unresolved references.
	     * They contains var's, function's, and explicit global variable's.
	     * If `config.vars` is not "all", returns empty map.
	     * @param {Scope} scope - the global scope.
	     * @returns {object} Unresolved references. Keys of the object is its variable name. Values of the object is an array of its references.
	     * @private
	     */
	    function collectUnresolvedReferences(scope) {
	        var unresolvedRefs = Object.create(null);

	        if (config.vars === "all") {
	            for (var i = 0, l = scope.through.length; i < l; ++i) {
	                var ref = scope.through[i];
	                var name = ref.identifier.name;

	                if (isReadRef(ref)) {
	                    if (!unresolvedRefs[name]) {
	                        unresolvedRefs[name] = [];
	                    }
	                    unresolvedRefs[name].push(ref);
	                }
	            }
	        }

	        return unresolvedRefs;
	    }

	    /**
	     * Gets an array of variables without read references.
	     * @param {Scope} scope - an escope Scope object.
	     * @param {object} unresolvedRefs - a map of each variable name and its references.
	     * @param {Variable[]} unusedVars - an array that saving result.
	     * @returns {Variable[]} unused variables of the scope and descendant scopes.
	     * @private
	     */
	    function collectUnusedVariables(scope, unresolvedRefs, unusedVars) {
	        var variables = scope.variables;
	        var childScopes = scope.childScopes;
	        var i, l;

	        if (scope.type !== "TDZ" && (scope.type !== "global" || config.vars === "all")) {
	            for (i = 0, l = variables.length; i < l; ++i) {
	                var variable = variables[i];

	                // skip a variable of class itself name in the class scope
	                if (scope.type === "class" && scope.block.id === variable.identifiers[0]) {
	                    continue;
	                }
	                // skip function expression names and variables marked with markVariableAsUsed()
	                if (scope.functionExpressionScope || variable.eslintUsed) {
	                    continue;
	                }
	                // skip implicit "arguments" variable
	                if (scope.type === "function" && variable.name === "arguments" && variable.identifiers.length === 0) {
	                    continue;
	                }

	                // explicit global variables don't have definitions.
	                var def = variable.defs[0];
	                if (def != null) {
	                    var type = def.type;

	                    // skip catch variables
	                    if (type === "CatchClause") {
	                        continue;
	                    }

	                    // skip any setter argument
	                    if (type === "Parameter" && def.node.parent.type === "Property" && def.node.parent.kind === "set") {
	                        continue;
	                    }

	                    // if "args" option is "none", skip any parameter
	                    if (config.args === "none" && type === "Parameter") {
	                        continue;
	                    }

	                    // if "args" option is "after-used", skip all but the last parameter
	                    if (config.args === "after-used" && type === "Parameter" && def.index < def.node.params.length - 1) {
	                        continue;
	                    }
	                }

	                // On global, variables without let/const/class are unresolved.
	                var references = (scope.type === "global" ? unresolvedRefs[variable.name] : null) || variable.references;
	                if (!isUsedVariable(variable, references) && !isExported(variable)) {
	                    unusedVars.push(variable);
	                }
	            }
	        }

	        for (i = 0, l = childScopes.length; i < l; ++i) {
	            collectUnusedVariables(childScopes[i], unresolvedRefs, unusedVars);
	        }

	        return unusedVars;
	    }

	    //--------------------------------------------------------------------------
	    // Public
	    //--------------------------------------------------------------------------

	    return {
	        "Program:exit": function(programNode) {
	            var globalScope = context.getScope();
	            var unresolvedRefs = collectUnresolvedReferences(globalScope);
	            var unusedVars = collectUnusedVariables(globalScope, unresolvedRefs, []);

	            for (var i = 0, l = unusedVars.length; i < l; ++i) {
	                var unusedVar = unusedVars[i];

	                if (unusedVar.eslintUsed) {
	                    continue; // explicitly exported variables
	                } else if (unusedVar.eslintExplicitGlobal) {
	                    context.report(programNode, MESSAGE, unusedVar);
	                } else if (unusedVar.defs.length > 0) {
	                    context.report(unusedVar.identifiers[0], MESSAGE, unusedVar);
	                }
	            }
	        }
	    };

	};

	module.exports.schema = [
	    {
	        "oneOf": [
	            {
	                "enum": ["all", "local"]
	            },
	            {
	                "type": "object",
	                "properties": {
	                    "vars": {
	                        "enum": ["all", "local"]
	                    },
	                    "args": {
	                        "enum": ["all", "after-used", "none"]
	                    }
	                }
	            }
	        ]
	    }
	];


/***/ },
/* 285 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag use of variables before they are defined
	 * @author Ilya Volodin
	 * @copyright 2013 Ilya Volodin. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Constants
	//------------------------------------------------------------------------------

	var NO_FUNC = "nofunc";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    /**
	     * Finds variable declarations in a given scope.
	     * @param {string} name The variable name to find.
	     * @param {Scope} scope The scope to search in.
	     * @returns {Object} The variable declaration object.
	     * @private
	     */
	    function findDeclaration(name, scope) {
	        // try searching in the current scope first
	        for (var i = 0, l = scope.variables.length; i < l; i++) {
	            if (scope.variables[i].name === name) {
	                return scope.variables[i];
	            }
	        }
	        // check if there's upper scope and call recursivly till we find the variable
	        if (scope.upper) {
	            return findDeclaration(name, scope.upper);
	        }
	    }

	    /**
	     * Finds and validates all variables in a given scope.
	     * @param {Scope} scope The scope object.
	     * @returns {void}
	     * @private
	     */
	    function findVariablesInScope(scope) {
	        var typeOption = context.options[0];

	        function checkLocationAndReport(reference, declaration) {
	            if (typeOption !== NO_FUNC || declaration.defs[0].type !== "FunctionName") {
	                if (declaration.identifiers[0].range[1] > reference.identifier.range[1]) {
	                    context.report(reference.identifier, "{{a}} was used before it was defined", {a: reference.identifier.name});
	                }
	            }
	        }

	        scope.references.forEach(function(reference) {
	            // if the reference is resolved check for declaration location
	            // if not, it could be function invocation, try to find manually
	            if (reference.resolved && reference.resolved.identifiers.length > 0) {
	                checkLocationAndReport(reference, reference.resolved);
	            } else {
	                var declaration = findDeclaration(reference.identifier.name, scope);
	                // if there're no identifiers, this is a global environment variable
	                if (declaration && declaration.identifiers.length !== 0) {
	                    checkLocationAndReport(reference, declaration);
	                }
	            }
	        });
	    }


	    /**
	     * Validates variables inside of a node's scope.
	     * @param {ASTNode} node The node to check.
	     * @returns {void}
	     * @private
	     */
	    function findVariables() {
	        var scope = context.getScope();
	        findVariablesInScope(scope);
	    }

	    var ruleDefinition = {
	        "Program": function() {
	            var scope = context.getScope();
	            findVariablesInScope(scope);

	            // both Node.js and Modules have an extra scope
	            if (context.ecmaFeatures.globalReturn || context.ecmaFeatures.modules) {
	                findVariablesInScope(scope.childScopes[0]);
	            }
	        }
	    };

	    if (context.ecmaFeatures.blockBindings) {
	        ruleDefinition.BlockStatement = ruleDefinition.SwitchStatement = findVariables;

	        ruleDefinition.ArrowFunctionExpression = function(node) {
	            if (node.body.type !== "BlockStatement") {
	                findVariables(node);
	            }
	        };
	    } else {
	        ruleDefinition.FunctionExpression = ruleDefinition.FunctionDeclaration = ruleDefinition.ArrowFunctionExpression = findVariables;
	    }

	    return ruleDefinition;
	};

	module.exports.schema = [
	    {
	        "enum": ["nofunc"]
	    }
	];


/***/ },
/* 286 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Enforce return after a callback.
	 * @author Jamund Ferguson
	 * @copyright 2015 Jamund Ferguson. All rights reserved.
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var callbacks = context.options[0] || ["callback", "cb", "next"];

	    //--------------------------------------------------------------------------
	    // Helpers
	    //--------------------------------------------------------------------------

	    /**
	     * Find the closest parent matching a list of types.
	     * @param {ASTNode} node The node whose parents we are searching
	     * @param {Array} types The node types to match
	     * @returns {ASTNode} The matched node or undefined.
	     */
	    function findClosestParentOfType(node, types) {
	        if (!node.parent) {
	            return null;
	        }
	        if (types.indexOf(node.parent.type) === -1) {
	            return findClosestParentOfType(node.parent, types);
	        }
	        return node.parent;
	    }

	    /**
	     * Check to see if a CallExpression is in our callback list.
	     * @param {ASTNode} node The node to check against our callback names list.
	     * @returns {Boolean} Whether or not this function matches our callback name.
	     */
	    function isCallback(node) {
	        return node.callee.type === "Identifier" && callbacks.indexOf(node.callee.name) > -1;
	    }

	    /**
	     * Determines whether or not the callback is part of a callback expression.
	     * @param {ASTNode} node The callback node
	     * @param {ASTNode} parentNode The expression node
	     * @returns {boolean} Whether or not this is part of a callback expression
	     */
	    function isCallbackExpression(node, parentNode) {

	        // ensure the parent node exists and is an expression
	        if (!parentNode || parentNode.type !== "ExpressionStatement") {
	            return false;
	        }

	        // cb()
	        if (parentNode.expression === node) {
	            return true;
	        }

	        // special case for cb && cb() and similar
	        if (parentNode.expression.type === "BinaryExpression" || parentNode.expression.type === "LogicalExpression") {
	            if (parentNode.expression.right === node) {
	                return true;
	            }
	        }
	    }

	    //--------------------------------------------------------------------------
	    // Public
	    //--------------------------------------------------------------------------

	    return {
	        "CallExpression": function(node) {

	            // if we"re not a callback we can return
	            if (!isCallback(node)) {
	                return;
	            }

	            // find the closest block, return or loop
	            var closestBlock = findClosestParentOfType(node, ["BlockStatement", "ReturnStatement", "ArrowFunctionExpression"]) || {},
	                lastItem, parentType;

	            // if our parent is a return we know we're ok
	            if (closestBlock.type === "ReturnStatement" ) {
	                return;
	            }

	            // arrow functions don't always have blocks and implicitly return
	            if (closestBlock.type === "ArrowFunctionExpression") {
	                return;
	            }

	            // block statements are part of functions and most if statements
	            if (closestBlock.type === "BlockStatement") {

	                // find the last item in the block
	                lastItem = closestBlock.body[closestBlock.body.length - 1];

	                // if the callback is the last thing in a block that might be ok
	                if (isCallbackExpression(node, lastItem)) {

	                    parentType = closestBlock.parent.type;

	                    // but only if the block is part of a function
	                    if (parentType === "FunctionExpression" ||
	                        parentType === "FunctionDeclaration" ||
	                        parentType === "ArrowFunctionExpression"
	                    ) {
	                        return;
	                    }

	                }

	                // ending a block with a return is also ok
	                if (lastItem.type === "ReturnStatement") {

	                    // but only if the callback is immediately before
	                    if (isCallbackExpression(node, closestBlock.body[closestBlock.body.length - 2])) {
	                        return;
	                    }
	                }

	            }

	            // as long as you're the child of a function at this point you should be asked to return
	            if (findClosestParentOfType(node, ["FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"])) {
	                context.report(node, "Expected return with your callback function.");
	            }

	        }

	    };
	};

	module.exports.schema = [{
	    type: "array",
	    items: { type: "string" }
	}];


/***/ },
/* 287 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Ensure handling of errors when we know they exist.
	 * @author Jamund Ferguson
	 * @copyright 2015 Mathias Schreck.
	 * @copyright 2014 Jamund Ferguson. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var errorArgument = context.options[0] || "err";

	    /**
	     * Checks if the given argument should be interpreted as a regexp pattern.
	     * @param {string} stringToCheck The string which should be checked.
	     * @returns {boolean} Whether or not the string should be interpreted as a pattern.
	     */
	    function isPattern(stringToCheck) {
	        var firstChar = stringToCheck[0];
	        return firstChar === "^";
	    }

	    /**
	     * Checks if the given name matches the configured error argument.
	     * @param {string} name The name which should be compared.
	     * @returns {boolean} Whether or not the given name matches the configured error variable name.
	     */
	    function matchesConfiguredErrorName(name) {
	        if (isPattern(errorArgument)) {
	            var regexp = new RegExp(errorArgument);
	            return regexp.test(name);
	        }
	        return name === errorArgument;
	    }

	    /**
	     * Get the parameters of a given function scope.
	     * @param {object} scope The function scope.
	     * @returns {array} All parameters of the given scope.
	     */
	    function getParameters(scope) {
	        return scope.variables.filter(function(variable) {
	            return variable.defs[0] && variable.defs[0].type === "Parameter";
	        });
	    }

	    /**
	     * Check to see if we're handling the error object properly.
	     * @param {ASTNode} node The AST node to check.
	     * @returns {void}
	     */
	    function checkForError(node) {
	        var scope = context.getScope(),
	            parameters = getParameters(scope),
	            firstParameter = parameters[0];

	        if (firstParameter && matchesConfiguredErrorName(firstParameter.name)) {
	            if (firstParameter.references.length === 0) {
	                context.report(node, "Expected error to be handled.");
	            }
	        }
	    }

	    return {
	        "FunctionDeclaration": checkForError,
	        "FunctionExpression": checkForError,
	        "ArrowFunctionExpression": checkForError
	    };

	};

	module.exports.schema = [
	    {
	        "type": "string"
	    }
	];


/***/ },
/* 288 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to enforce grouped require statements for Node.JS
	 * @author Raphael Pigulla
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    /**
	     * Returns the list of built-in modules.
	     *
	     * @returns {string[]} An array of built-in Node.js modules.
	     */
	    function getBuiltinModules() {
	        // This list is generated using `require("repl")._builtinLibs.concat('repl').sort()`
	        // This particular list is as per nodejs v0.12.2 and iojs v0.7.1
	        return [
	            "assert", "buffer", "child_process", "cluster", "crypto",
	            "dgram", "dns", "domain", "events", "fs", "http", "https",
	            "net", "os", "path", "punycode", "querystring", "readline",
	            "repl", "smalloc", "stream", "string_decoder", "tls", "tty",
	            "url", "util", "v8", "vm", "zlib"
	        ];
	    }

	    var BUILTIN_MODULES = getBuiltinModules();

	    var DECL_REQUIRE = "require",
	        DECL_UNINITIALIZED = "uninitialized",
	        DECL_OTHER = "other";

	    var REQ_CORE = "core",
	        REQ_FILE = "file",
	        REQ_MODULE = "module",
	        REQ_COMPUTED = "computed";

	    /**
	     * Determines the type of a declaration statement.
	     * @param {ASTNode} initExpression The init node of the VariableDeclarator.
	     * @returns {string} The type of declaration represented by the expression.
	     */
	    function getDeclarationType(initExpression) {
	        if (!initExpression) {
	            // "var x;"
	            return DECL_UNINITIALIZED;
	        }

	        if (initExpression.type === "CallExpression" &&
	            initExpression.callee.type === "Identifier" &&
	            initExpression.callee.name === "require"
	        ) {
	            // "var x = require('util');"
	            return DECL_REQUIRE;
	        } else if (initExpression.type === "MemberExpression") {
	            // "var x = require('glob').Glob;"
	            return getDeclarationType(initExpression.object);
	        }

	        // "var x = 42;"
	        return DECL_OTHER;
	    }

	    /**
	     * Determines the type of module that is loaded via require.
	     * @param {ASTNode} initExpression The init node of the VariableDeclarator.
	     * @returns {string} The module type.
	     */
	    function inferModuleType(initExpression) {
	        if (initExpression.type === "MemberExpression") {
	            // "var x = require('glob').Glob;"
	            return inferModuleType(initExpression.object);
	        } else if (initExpression.arguments.length === 0) {
	            // "var x = require();"
	            return REQ_COMPUTED;
	        }

	        var arg = initExpression.arguments[0];

	        if (arg.type !== "Literal" || typeof arg.value !== "string") {
	            // "var x = require(42);"
	            return REQ_COMPUTED;
	        }

	        if (BUILTIN_MODULES.indexOf(arg.value) !== -1) {
	            // "var fs = require('fs');"
	            return REQ_CORE;
	        } else if (/^\.{0,2}\//.test(arg.value)) {
	            // "var utils = require('./utils');"
	            return REQ_FILE;
	        } else {
	            // "var async = require('async');"
	            return REQ_MODULE;
	        }
	    }

	    /**
	     * Check if the list of variable declarations is mixed, i.e. whether it
	     * contains both require and other declarations.
	     * @param {ASTNode} declarations The list of VariableDeclarators.
	     * @returns {boolean} True if the declarations are mixed, false if not.
	     */
	    function isMixed(declarations) {
	        var contains = {};

	        declarations.forEach(function(declaration) {
	            var type = getDeclarationType(declaration.init);
	            contains[type] = true;
	        });

	        return !!(
	            contains[DECL_REQUIRE] &&
	            (contains[DECL_UNINITIALIZED] || contains[DECL_OTHER])
	        );
	    }

	    /**
	     * Check if all require declarations in the given list are of the same
	     * type.
	     * @param {ASTNode} declarations The list of VariableDeclarators.
	     * @returns {boolean} True if the declarations are grouped, false if not.
	     */
	    function isGrouped(declarations) {
	        var found = {};

	        declarations.forEach(function(declaration) {
	            if (getDeclarationType(declaration.init) === DECL_REQUIRE) {
	                found[inferModuleType(declaration.init)] = true;
	            }
	        });

	        return Object.keys(found).length <= 1;
	    }


	    return {

	        "VariableDeclaration": function(node) {
	            var grouping = !!context.options[0];

	            if (isMixed(node.declarations)) {
	                context.report(
	                    node,
	                    "Do not mix 'require' and other declarations."
	                );
	            } else if (grouping && !isGrouped(node.declarations)) {
	                context.report(
	                    node,
	                    "Do not mix core, module, file and computed requires."
	                );
	            }
	        }
	    };

	};

	module.exports.schema = [
	    {
	        "type": "boolean"
	    }
	];


/***/ },
/* 289 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to disallow use of new operator with the `require` function
	 * @author Wil Moore III
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {

	        "NewExpression": function(node) {
	            if (node.callee.type === "Identifier" && node.callee.name === "require") {
	                context.report(node, "Unexpected use of new with require.");
	            }
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 290 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Disallow string concatenation when using __dirname and __filename
	 * @author Nicholas C. Zakas
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var MATCHER = /^__(?:dir|file)name$/;

	    //--------------------------------------------------------------------------
	    // Public
	    //--------------------------------------------------------------------------

	    return {

	        "BinaryExpression": function(node) {

	            var left = node.left,
	                right = node.right;

	            if (node.operator === "+" &&
	                    ((left.type === "Identifier" && MATCHER.test(left.name)) ||
	                    (right.type === "Identifier" && MATCHER.test(right.name)))
	            ) {

	                context.report(node, "Use path.join() or path.resolve() instead of + to create paths.");
	            }
	        }

	    };

	};

	module.exports.schema = [];


/***/ },
/* 291 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Disallow the use of process.exit()
	 * @author Nicholas C. Zakas
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    //--------------------------------------------------------------------------
	    // Public
	    //--------------------------------------------------------------------------

	    return {

	        "CallExpression": function(node) {
	            var callee = node.callee;

	            if (callee.type === "MemberExpression" && callee.object.name === "process" &&
	                callee.property.name === "exit"
	            ) {
	                context.report(node, "Don't use process.exit(); throw an error instead.");
	            }
	        }

	    };

	};

	module.exports.schema = [];


/***/ },
/* 292 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Restrict usage of specified node modules.
	 * @author Christian Schulz
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {
	    // trim restricted module names
	    var restrictedModules = context.options;

	    // if no modules are restricted we don't need to check the CallExpressions
	    if (restrictedModules.length === 0) {
	        return {};
	    }

	    /**
	     * Function to check if a node is a string literal.
	     * @param {ASTNode} node The node to check.
	     * @returns {boolean} If the node is a string literal.
	     */
	    function isString(node) {
	        return node && node.type === "Literal" && typeof node.value === "string";
	    }

	    /**
	     * Function to check if a node is a require call.
	     * @param {ASTNode} node The node to check.
	     * @returns {boolean} If the node is a require call.
	     */
	    function isRequireCall(node) {
	        return node.callee.type === "Identifier" && node.callee.name === "require";
	    }

	    /**
	     * Function to check if a node has an argument that is an restricted module and return its name.
	     * @param {ASTNode} node The node to check
	     * @returns {undefined|String} restricted module name or undefined if node argument isn't restricted.
	     */
	    function getRestrictedModuleName(node) {
	        var moduleName;

	        // node has arguments and first argument is string
	        if (node.arguments.length && isString(node.arguments[0])) {
	            var argumentValue = node.arguments[0].value.trim();

	            // check if argument value is in restricted modules array
	            if (restrictedModules.indexOf(argumentValue) !== -1) {
	                moduleName = argumentValue;
	            }
	        }

	        return moduleName;
	    }

	    return {
	        "CallExpression": function(node) {
	            if (isRequireCall(node)) {
	                var restrictedModuleName = getRestrictedModuleName(node);

	                if (restrictedModuleName) {
	                    context.report(node, "'{{moduleName}}' module is restricted from being used.", {
	                        moduleName: restrictedModuleName
	                    });
	                }
	            }
	        }
	    };
	};

	module.exports.schema = {
	    "type": "array",
	    "items": [
	        {
	            "enum": [0, 1, 2]
	        }
	    ],
	    "additionalItems": {
	        "type": "string"
	    },
	    "uniqueItems": true
	};


/***/ },
/* 293 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to check for properties whose identifier ends with the string Sync
	 * @author Matt DuVall<http://mattduvall.com/>
	 */

	/* jshint node:true */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {

	        "MemberExpression": function(node) {
	            var propertyName = node.property.name,
	                syncRegex = /.*Sync$/;

	            if (syncRegex.exec(propertyName) !== null) {
	                context.report(node, "Unexpected sync method: '" + propertyName + "'.");
	            }
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Disallows or enforces spaces inside of array brackets.
	 * @author Jamund Ferguson
	 * @copyright 2015 Jamund Ferguson. All rights reserved.
	 * @copyright 2014 Brandyn Bennett. All rights reserved.
	 * @copyright 2014 Michael Ficarra. No rights reserved.
	 * @copyright 2014 Vignesh Anand. All rights reserved.
	 */
	"use strict";

	var astUtils = __webpack_require__(177);

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {
	    var spaced = context.options[0] === "always";

	    /**
	     * Determines whether an option is set, relative to the spacing option.
	     * If spaced is "always", then check whether option is set to false.
	     * If spaced is "never", then check whether option is set to true.
	     * @param {Object} option - The option to exclude.
	     * @returns {boolean} Whether or not the property is excluded.
	     */
	    function isOptionSet(option) {
	        return context.options[1] != null ? context.options[1][option] === !spaced : false;
	    }

	    var options = {
	        spaced: spaced,
	        singleElementException: isOptionSet("singleValue"),
	        objectsInArraysException: isOptionSet("objectsInArrays"),
	        arraysInArraysException: isOptionSet("arraysInArrays")
	    };

	    //--------------------------------------------------------------------------
	    // Helpers
	    //--------------------------------------------------------------------------

	    /**
	    * Reports that there shouldn't be a space after the first token
	    * @param {ASTNode} node - The node to report in the event of an error.
	    * @param {Token} token - The token to use for the report.
	    * @returns {void}
	    */
	    function reportNoBeginningSpace(node, token) {
	        context.report(node, token.loc.start,
	            "There should be no space after '" + token.value + "'");
	    }

	    /**
	    * Reports that there shouldn't be a space before the last token
	    * @param {ASTNode} node - The node to report in the event of an error.
	    * @param {Token} token - The token to use for the report.
	    * @returns {void}
	    */
	    function reportNoEndingSpace(node, token) {
	        context.report(node, token.loc.start,
	            "There should be no space before '" + token.value + "'");
	    }

	    /**
	    * Reports that there should be a space after the first token
	    * @param {ASTNode} node - The node to report in the event of an error.
	    * @param {Token} token - The token to use for the report.
	    * @returns {void}
	    */
	    function reportRequiredBeginningSpace(node, token) {
	        context.report(node, token.loc.start,
	            "A space is required after '" + token.value + "'");
	    }

	    /**
	    * Reports that there should be a space before the last token
	    * @param {ASTNode} node - The node to report in the event of an error.
	    * @param {Token} token - The token to use for the report.
	    * @returns {void}
	    */
	    function reportRequiredEndingSpace(node, token) {
	        context.report(node, token.loc.start,
	                    "A space is required before '" + token.value + "'");
	    }

	    /**
	     * Validates the spacing around array brackets
	     * @param {ASTNode} node - The node we're checking for spacing
	     * @returns {void}
	     */
	    function validateArraySpacing(node) {
	        if (node.elements.length === 0) {
	            return;
	        }

	        var first = context.getFirstToken(node),
	            second = context.getFirstToken(node, 1),
	            penultimate = context.getLastToken(node, 1),
	            last = context.getLastToken(node);

	        var openingBracketMustBeSpaced =
	            options.objectsInArraysException && second.value === "{" ||
	            options.arraysInArraysException && second.value === "[" ||
	            options.singleElementException && node.elements.length === 1
	                ? !options.spaced : options.spaced;

	        var closingBracketMustBeSpaced =
	            options.objectsInArraysException && penultimate.value === "}" ||
	            options.arraysInArraysException && penultimate.value === "]" ||
	            options.singleElementException && node.elements.length === 1
	                ? !options.spaced : options.spaced;

	        if (astUtils.isTokenOnSameLine(first, second)) {
	            if (openingBracketMustBeSpaced && !astUtils.isTokenSpaced(first, second)) {
	                reportRequiredBeginningSpace(node, first);
	            }
	            if (!openingBracketMustBeSpaced && astUtils.isTokenSpaced(first, second)) {
	                reportNoBeginningSpace(node, first);
	            }
	        }

	        if (astUtils.isTokenOnSameLine(penultimate, last)) {
	            if (closingBracketMustBeSpaced && !astUtils.isTokenSpaced(penultimate, last)) {
	                reportRequiredEndingSpace(node, last);
	            }
	            if (!closingBracketMustBeSpaced && astUtils.isTokenSpaced(penultimate, last)) {
	                reportNoEndingSpace(node, last);
	            }
	        }
	    }

	    //--------------------------------------------------------------------------
	    // Public
	    //--------------------------------------------------------------------------

	    return {
	        ArrayPattern: validateArraySpacing,
	        ArrayExpression: validateArraySpacing
	    };

	};

	module.exports.schema = [
	    {
	        "enum": ["always", "never"]
	    },
	    {
	        "type": "object",
	        "properties": {
	            "singleValue": {
	                "type": "boolean"
	            },
	            "objectsInArrays": {
	                "type": "boolean"
	            },
	            "arraysInArrays": {
	                "type": "boolean"
	            }
	        },
	        "additionalProperties": false
	    }
	];


/***/ },
/* 295 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag block statements that do not use the one true brace style
	 * @author Ian Christian Myers
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {
	    var style = context.options[0] || "1tbs";
	    var params = context.options[1] || {};

	    var OPEN_MESSAGE = "Opening curly brace does not appear on the same line as controlling statement.",
	        BODY_MESSAGE = "Statement inside of curly braces should be on next line.",
	        CLOSE_MESSAGE = "Closing curly brace does not appear on the same line as the subsequent block.",
	        CLOSE_MESSAGE_SINGLE = "Closing curly brace should be on the same line as opening curly brace or on the line after the previous block.",
	        CLOSE_MESSAGE_STROUSTRUP = "Closing curly brace appears on the same line as the subsequent block.";

	    //--------------------------------------------------------------------------
	    // Helpers
	    //--------------------------------------------------------------------------

	    /**
	     * Determines if a given node is a block statement.
	     * @param {ASTNode} node The node to check.
	     * @returns {boolean} True if the node is a block statement, false if not.
	     * @private
	     */
	    function isBlock(node) {
	        return node && node.type === "BlockStatement";
	    }

	    /**
	     * Check if the token is an punctuator with a value of curly brace
	     * @param {object} token - Token to check
	     * @returns {boolean} true if its a curly punctuator
	     * @private
	     */
	    function isCurlyPunctuator(token) {
	        return token.value === "{" || token.value === "}";
	    }

	    /**
	     * Binds a list of properties to a function that verifies that the opening
	     * curly brace is on the same line as its controlling statement of a given
	     * node.
	     * @param {...string} The properties to check on the node.
	     * @returns {Function} A function that will perform the check on a node
	     * @private
	     */
	    function checkBlock() {
	        var blockProperties = arguments;

	        return function(node) {
	            [].forEach.call(blockProperties, function(blockProp) {
	                var block = node[blockProp], previousToken, curlyToken, curlyTokenEnd, curlyTokensOnSameLine;
	                block = node[blockProp];

	                if (isBlock(block)) {

	                    previousToken = context.getTokenBefore(block);
	                    curlyToken = context.getFirstToken(block);
	                    curlyTokenEnd = context.getLastToken(block);
	                    curlyTokensOnSameLine = curlyToken.loc.start.line === curlyTokenEnd.loc.start.line;

	                    if (previousToken.loc.start.line !== curlyToken.loc.start.line) {
	                        context.report(node, OPEN_MESSAGE);
	                    } else if (block.body.length && params.allowSingleLine) {

	                        if (curlyToken.loc.start.line === block.body[0].loc.start.line && !curlyTokensOnSameLine) {
	                            context.report(block.body[0], BODY_MESSAGE);
	                        } else if (curlyTokenEnd.loc.start.line === block.body[block.body.length - 1].loc.start.line && !curlyTokensOnSameLine) {
	                            context.report(block.body[block.body.length - 1], CLOSE_MESSAGE_SINGLE);
	                        }

	                    } else if (block.body.length && curlyToken.loc.start.line === block.body[0].loc.start.line) {
	                        context.report(block.body[0], BODY_MESSAGE);
	                    }
	                }
	            });
	        };
	    }

	    /**
	     * Enforces the configured brace style on IfStatements
	     * @param {ASTNode} node An IfStatement node.
	     * @returns {void}
	     * @private
	     */
	    function checkIfStatement(node) {
	        var tokens,
	            alternateIsBlock = false,
	            alternateIsIfBlock = false;

	        checkBlock("consequent", "alternate")(node);

	        if (node.alternate) {

	            alternateIsBlock = isBlock(node.alternate);
	            alternateIsIfBlock = node.alternate.type === "IfStatement" && isBlock(node.alternate.consequent);

	            if (alternateIsBlock || alternateIsIfBlock) {
	                tokens = context.getTokensBefore(node.alternate, 2);

	                if (style === "1tbs") {
	                    if (tokens[0].loc.start.line !== tokens[1].loc.start.line && isCurlyPunctuator(tokens[0]) ) {
	                        context.report(node.alternate, CLOSE_MESSAGE);
	                    }
	                } else if (style === "stroustrup") {
	                    if (tokens[0].loc.start.line === tokens[1].loc.start.line) {
	                        context.report(node.alternate, CLOSE_MESSAGE_STROUSTRUP);
	                    }
	                }
	            }

	        }
	    }

	    /**
	     * Enforces the configured brace style on TryStatements
	     * @param {ASTNode} node A TryStatement node.
	     * @returns {void}
	     * @private
	     */
	    function checkTryStatement(node) {
	        var tokens;

	        checkBlock("block", "finalizer")(node);

	        if (isBlock(node.finalizer)) {
	            tokens = context.getTokensBefore(node.finalizer, 2);
	            if (style === "1tbs") {
	                if (tokens[0].loc.start.line !== tokens[1].loc.start.line) {
	                    context.report(node.finalizer, CLOSE_MESSAGE);
	                }
	            } else if (style === "stroustrup") {
	                if (tokens[0].loc.start.line === tokens[1].loc.start.line) {
	                    context.report(node.finalizer, CLOSE_MESSAGE_STROUSTRUP);
	                }
	            }
	        }
	    }

	    /**
	     * Enforces the configured brace style on CatchClauses
	     * @param {ASTNode} node A CatchClause node.
	     * @returns {void}
	     * @private
	     */
	    function checkCatchClause(node) {
	        var previousToken = context.getTokenBefore(node),
	            firstToken = context.getFirstToken(node);

	        checkBlock("body")(node);

	        if (isBlock(node.body)) {
	            if (style === "1tbs") {
	                if (previousToken.loc.start.line !== firstToken.loc.start.line) {
	                    context.report(node, CLOSE_MESSAGE);
	                }
	            } else if (style === "stroustrup") {
	                if (previousToken.loc.start.line === firstToken.loc.start.line) {
	                    context.report(node, CLOSE_MESSAGE_STROUSTRUP);
	                }
	            }
	        }
	    }

	    /**
	     * Enforces the configured brace style on SwitchStatements
	     * @param {ASTNode} node A SwitchStatement node.
	     * @returns {void}
	     * @private
	     */
	    function checkSwitchStatement(node) {
	        var tokens;
	        if (node.cases && node.cases.length) {
	            tokens = context.getTokensBefore(node.cases[0], 2);
	            if (tokens[0].loc.start.line !== tokens[1].loc.start.line) {
	                context.report(node, OPEN_MESSAGE);
	            }
	        } else {
	            tokens = context.getLastTokens(node, 3);
	            if (tokens[0].loc.start.line !== tokens[1].loc.start.line) {
	                context.report(node, OPEN_MESSAGE);
	            }
	        }
	    }

	    //--------------------------------------------------------------------------
	    // Public API
	    //--------------------------------------------------------------------------

	    return {
	        "FunctionDeclaration": checkBlock("body"),
	        "FunctionExpression": checkBlock("body"),
	        "ArrowFunctionExpression": checkBlock("body"),
	        "IfStatement": checkIfStatement,
	        "TryStatement": checkTryStatement,
	        "CatchClause": checkCatchClause,
	        "DoWhileStatement": checkBlock("body"),
	        "WhileStatement": checkBlock("body"),
	        "WithStatement": checkBlock("body"),
	        "ForStatement": checkBlock("body"),
	        "ForInStatement": checkBlock("body"),
	        "ForOfStatement": checkBlock("body"),
	        "SwitchStatement": checkSwitchStatement
	    };

	};

	module.exports.schema = [
	    {
	        "enum": ["1tbs", "stroustrup"]
	    },
	    {
	        "type": "object",
	        "properties": {
	            "allowSingleLine": {
	                "type": "boolean"
	            }
	        },
	        "additionalProperties": false
	    }
	];


/***/ },
/* 296 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag non-camelcased identifiers
	 * @author Nicholas C. Zakas
	 * @copyright 2015 Dieter Oberkofler. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    //--------------------------------------------------------------------------
	    // Helpers
	    //--------------------------------------------------------------------------

	    /**
	     * Checks if a string contains an underscore and isn't all upper-case
	     * @param {String} name The string to check.
	     * @returns {boolean} if the string is underscored
	     * @private
	     */
	    function isUnderscored(name) {

	        // if there's an underscore, it might be A_CONSTANT, which is okay
	        return name.indexOf("_") > -1 && name !== name.toUpperCase();
	    }

	    /**
	     * Reports an AST node as a rule violation.
	     * @param {ASTNode} node The node to report.
	     * @returns {void}
	     * @private
	     */
	    function report(node) {
	        context.report(node, "Identifier '{{name}}' is not in camel case.", { name: node.name });
	    }

	    var options = context.options[0] || {},
	        properties = options.properties || "";

	    if (properties !== "always" && properties !== "never") {
	        properties = "always";
	    }

	    return {

	        "Identifier": function(node) {

	            // Leading and trailing underscores are commonly used to flag private/protected identifiers, strip them
	            var name = node.name.replace(/^_+|_+$/g, ""),
	                effectiveParent = (node.parent.type === "MemberExpression") ? node.parent.parent : node.parent;

	            // MemberExpressions get special rules
	            if (node.parent.type === "MemberExpression") {

	                // "never" check properties
	                if (properties === "never") {
	                    return;
	                }

	                // Always report underscored object names
	                if (node.parent.object.type === "Identifier" &&
	                        node.parent.object.name === node.name &&
	                        isUnderscored(name)) {
	                    report(node);

	                // Report AssignmentExpressions only if they are the left side of the assignment
	                } else if (effectiveParent.type === "AssignmentExpression" &&
	                        isUnderscored(name) &&
	                        (effectiveParent.right.type !== "MemberExpression" ||
	                        effectiveParent.left.type === "MemberExpression" &&
	                        effectiveParent.left.property.name === node.name)) {
	                    report(node);
	                }

	            // Properties have their own rules
	            } else if (node.parent.type === "Property") {

	                // "never" check properties
	                if (properties === "never") {
	                    return;
	                }

	                if (isUnderscored(name) && effectiveParent.type !== "CallExpression") {
	                    report(node);
	                }

	            // Report anything that is underscored that isn't a CallExpression
	            } else if (isUnderscored(name) && effectiveParent.type !== "CallExpression") {
	                report(node);
	            }
	        }

	    };

	};

	module.exports.schema = [
	    {
	        "type": "object",
	        "properties": {
	            "properties": {
	                "enum": ["always", "never"]
	            }
	        },
	        "additionalProperties": false
	    }
	];


/***/ },
/* 297 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Comma spacing - validates spacing before and after comma
	 * @author Vignesh Anand aka vegetableman.
	 * @copyright 2014 Vignesh Anand. All rights reserved.
	 */
	"use strict";

	var astUtils = __webpack_require__(177);

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var options = {
	        before: context.options[0] ? !!context.options[0].before : false,
	        after: context.options[0] ? !!context.options[0].after : true
	    };

	    //--------------------------------------------------------------------------
	    // Helpers
	    //--------------------------------------------------------------------------

	    // the index of the last comment that was checked
	    var lastCommentIndex = 0;
	    var allComments;

	    /**
	     * Determines the length of comment between 2 tokens
	     * @param {Object} left - The left token object.
	     * @param {Object} right - The right token object.
	     * @returns {number} Length of comment in between tokens
	     */
	    function getCommentLengthBetweenTokens(left, right) {
	        return allComments.reduce(function(val, comment) {
	            if (left.range[1] <= comment.range[0] && comment.range[1] <= right.range[0]) {
	                val = val + comment.range[1] - comment.range[0];
	            }
	            return val;
	        }, 0);
	    }

	    /**
	     * Determines whether two adjacent tokens have whitespace between them.
	     * @param {Object} left - The left token object.
	     * @param {Object} right - The right token object.
	     * @returns {boolean} Whether or not there is space between the tokens.
	     */
	    function isSpaced(left, right) {
	        var punctuationLength = context.getTokensBetween(left, right).length; // the length of any parenthesis
	        var commentLenth = getCommentLengthBetweenTokens(left, right);
	        return (left.range[1] + punctuationLength + commentLenth) < right.range[0];
	    }

	    /**
	     * Determines if a given token is a comma operator.
	     * @param {ASTNode} token The token to check.
	     * @returns {boolean} True if the token is a comma, false if not.
	     * @private
	     */
	    function isComma(token) {
	        return !!token && (token.type === "Punctuator") && (token.value === ",");
	    }

	    /**
	     * Reports a spacing error with an appropriate message.
	     * @param {ASTNode} node The binary expression node to report.
	     * @param {string} dir Is the error "before" or "after" the comma?
	     * @returns {void}
	     * @private
	     */
	    function report(node, dir) {
	        context.report(node, options[dir] ?
	            "A space is required " + dir + " ','." :
	            "There should be no space " + dir + " ','.");
	    }

	    /**
	     * Validates the spacing around a comma token.
	     * @param {Object} tokens - The tokens to be validated.
	     * @param {Token} tokens.comma The token representing the comma.
	     * @param {Token} [tokens.left] The last token before the comma.
	     * @param {Token} [tokens.right] The first token after the comma.
	     * @param {Token|ASTNode} reportItem The item to use when reporting an error.
	     * @returns {void}
	     * @private
	     */
	    function validateCommaItemSpacing(tokens, reportItem) {
	        if (tokens.left && astUtils.isTokenOnSameLine(tokens.left, tokens.comma) &&
	                (options.before !== isSpaced(tokens.left, tokens.comma))
	        ) {
	            report(reportItem, "before");
	        }
	        if (tokens.right && astUtils.isTokenOnSameLine(tokens.comma, tokens.right) &&
	                (options.after !== isSpaced(tokens.comma, tokens.right))
	        ) {
	            report(reportItem, "after");
	        }
	    }

	    /**
	     * Determines if a given source index is in a comment or not by checking
	     * the index against the comment range. Since the check goes straight
	     * through the file, once an index is passed a certain comment, we can
	     * go to the next comment to check that.
	     * @param {int} index The source index to check.
	     * @param {ASTNode[]} comments An array of comment nodes.
	     * @returns {boolean} True if the index is within a comment, false if not.
	     * @private
	     */
	    function isIndexInComment(index, comments) {

	        var comment;

	        while (lastCommentIndex < comments.length) {

	            comment = comments[lastCommentIndex];

	            if (comment.range[0] <= index && index < comment.range[1]) {
	                return true;
	            } else if (index > comment.range[1]) {
	                lastCommentIndex++;
	            } else {
	                break;
	            }

	        }

	        return false;
	    }

	    //--------------------------------------------------------------------------
	    // Public
	    //--------------------------------------------------------------------------

	    return {
	        "Program": function() {

	            var source = context.getSource(),
	                pattern = /,/g,
	                commaToken,
	                previousToken,
	                nextToken;

	            allComments = context.getAllComments();
	            while (pattern.test(source)) {

	                // do not flag anything inside of comments
	                if (!isIndexInComment(pattern.lastIndex, allComments)) {
	                    commaToken = context.getTokenByRangeStart(pattern.lastIndex - 1);

	                    if (commaToken && commaToken.type !== "JSXText") {
	                        previousToken = context.getTokenBefore(commaToken);
	                        nextToken = context.getTokenAfter(commaToken);
	                        validateCommaItemSpacing({
	                            comma: commaToken,
	                            left: isComma(previousToken) ? null : previousToken,
	                            right: isComma(nextToken) ? null : nextToken
	                        }, commaToken);
	                    }
	                }
	            }
	        }
	    };

	};

	module.exports.schema = [
	    {
	        "type": "object",
	        "properties": {
	            "before": {
	                "type": "boolean"
	            },
	            "after": {
	                "type": "boolean"
	            }
	        },
	        "additionalProperties": false
	    }
	];


/***/ },
/* 298 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Comma style - enforces comma styles of two types: last and first
	 * @author Vignesh Anand aka vegetableman
	 * @copyright 2014 Vignesh Anand. All rights reserved.
	 * @copyright 2015 Evan Simmons. All rights reserved.
	 */

	"use strict";

	var astUtils = __webpack_require__(177);

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var style = context.options[0] || "last",
	        exceptions = {};

	    if (context.options.length === 2 && context.options[1].hasOwnProperty("exceptions")) {
	        exceptions = context.options[1].exceptions;
	    }

	    //--------------------------------------------------------------------------
	    // Helpers
	    //--------------------------------------------------------------------------

	    /**
	     * Determines if a given token is a comma operator.
	     * @param {ASTNode} token The token to check.
	     * @returns {boolean} True if the token is a comma, false if not.
	     * @private
	     */
	    function isComma(token) {
	        return !!token && (token.type === "Punctuator") && (token.value === ",");
	    }

	    /**
	     * Validates the spacing around single items in lists.
	     * @param {Token} previousItemToken The last token from the previous item.
	     * @param {Token} commaToken The token representing the comma.
	     * @param {Token} currentItemToken The first token of the current item.
	     * @param {Token} reportItem The item to use when reporting an error.
	     * @returns {void}
	     * @private
	     */
	    function validateCommaItemSpacing(previousItemToken, commaToken, currentItemToken, reportItem) {

	        // if single line
	        if (astUtils.isTokenOnSameLine(commaToken, currentItemToken) &&
	                astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {

	            return;

	        } else if (!astUtils.isTokenOnSameLine(commaToken, currentItemToken) &&
	                !astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {

	            // lone comma
	            context.report(reportItem, {
	                line: commaToken.loc.end.line,
	                column: commaToken.loc.start.column
	            }, "Bad line breaking before and after ','.");

	        } else if (style === "first" && !astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {

	            context.report(reportItem, "',' should be placed first.");

	        } else if (style === "last" && astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {

	            context.report(reportItem, {
	                line: commaToken.loc.end.line,
	                column: commaToken.loc.end.column
	            }, "',' should be placed last.");
	        }
	    }

	    /**
	     * Checks the comma placement with regards to a declaration/property/element
	     * @param {ASTNode} node The binary expression node to check
	     * @param {string} property The property of the node containing child nodes.
	     * @private
	     * @returns {void}
	     */
	    function validateComma(node, property) {
	        var items = node[property],
	            arrayLiteral = (node.type === "ArrayExpression"),
	            previousItemToken;

	        if (items.length > 1 || arrayLiteral) {

	            // seed as opening [
	            previousItemToken = context.getFirstToken(node);

	            items.forEach(function(item) {
	                var commaToken = item ? context.getTokenBefore(item) : previousItemToken,
	                    currentItemToken = item ? context.getFirstToken(item) : context.getTokenAfter(commaToken),
	                    reportItem = item || currentItemToken;

	                /*
	                 * This works by comparing three token locations:
	                 * - previousItemToken is the last token of the previous item
	                 * - commaToken is the location of the comma before the current item
	                 * - currentItemToken is the first token of the current item
	                 *
	                 * These values get switched around if item is undefined.
	                 * previousItemToken will refer to the last token not belonging
	                 * to the current item, which could be a comma or an opening
	                 * square bracket. currentItemToken could be a comma.
	                 *
	                 * All comparisons are done based on these tokens directly, so
	                 * they are always valid regardless of an undefined item.
	                 */
	                if (isComma(commaToken)) {
	                    validateCommaItemSpacing(previousItemToken, commaToken,
	                            currentItemToken, reportItem);
	                }

	                previousItemToken = item ? context.getLastToken(item) : previousItemToken;
	            });

	            /*
	             * Special case for array literals that have empty last items, such
	             * as [ 1, 2, ]. These arrays only have two items show up in the
	             * AST, so we need to look at the token to verify that there's no
	             * dangling comma.
	             */
	            if (arrayLiteral) {

	                var lastToken = context.getLastToken(node),
	                    nextToLastToken = context.getTokenBefore(lastToken);

	                if (isComma(nextToLastToken)) {
	                    validateCommaItemSpacing(
	                        context.getTokenBefore(nextToLastToken),
	                        nextToLastToken,
	                        lastToken,
	                        lastToken
	                    );
	                }
	            }
	        }
	    }

	    //--------------------------------------------------------------------------
	    // Public
	    //--------------------------------------------------------------------------

	    var nodes = {};

	    if (!exceptions.VariableDeclaration) {
	        nodes.VariableDeclaration = function(node) {
	            validateComma(node, "declarations");
	        };
	    }
	    if (!exceptions.ObjectExpression) {
	        nodes.ObjectExpression = function(node) {
	            validateComma(node, "properties");
	        };
	    }
	    if (!exceptions.ArrayExpression) {
	        nodes.ArrayExpression = function(node) {
	            validateComma(node, "elements");
	        };
	    }

	    return nodes;
	};

	module.exports.schema = [
	    {
	        "enum": ["first", "last"]
	    },
	    {
	        "type": "object",
	        "properties": {
	            "exceptions": {
	                "type": "object",
	                "additionalProperties": {
	                    "type": "boolean"
	                }
	            }
	        },
	        "additionalProperties": false
	    }
	];


/***/ },
/* 299 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Disallows or enforces spaces inside computed properties.
	 * @author Jamund Ferguson
	 * @copyright 2015 Jamund Ferguson. All rights reserved.
	 */
	"use strict";

	var astUtils = __webpack_require__(177);

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {
	    var propertyNameMustBeSpaced = context.options[0] === "always"; // default is "never"

	    //--------------------------------------------------------------------------
	    // Helpers
	    //--------------------------------------------------------------------------

	    /**
	    * Reports that there shouldn't be a space after the first token
	    * @param {ASTNode} node - The node to report in the event of an error.
	    * @param {Token} token - The token to use for the report.
	    * @returns {void}
	    */
	    function reportNoBeginningSpace(node, token) {
	        context.report(node, token.loc.start,
	            "There should be no space after '" + token.value + "'");
	    }

	    /**
	    * Reports that there shouldn't be a space before the last token
	    * @param {ASTNode} node - The node to report in the event of an error.
	    * @param {Token} token - The token to use for the report.
	    * @returns {void}
	    */
	    function reportNoEndingSpace(node, token) {
	        context.report(node, token.loc.start,
	            "There should be no space before '" + token.value + "'");
	    }

	    /**
	    * Reports that there should be a space after the first token
	    * @param {ASTNode} node - The node to report in the event of an error.
	    * @param {Token} token - The token to use for the report.
	    * @returns {void}
	    */
	    function reportRequiredBeginningSpace(node, token) {
	        context.report(node, token.loc.start,
	            "A space is required after '" + token.value + "'");
	    }

	    /**
	    * Reports that there should be a space before the last token
	    * @param {ASTNode} node - The node to report in the event of an error.
	    * @param {Token} token - The token to use for the report.
	    * @returns {void}
	    */
	    function reportRequiredEndingSpace(node, token) {
	        context.report(node, token.loc.start,
	                    "A space is required before '" + token.value + "'");
	    }

	    /**
	     * Returns a function that checks the spacing of a node on the property name
	     * that was passed in.
	     * @param {String} propertyName The property on the node to check for spacing
	     * @returns {Function} A function that will check spacing on a node
	     */
	    function checkSpacing(propertyName) {
	        return function(node) {
	            if (!node.computed) {
	                return;
	            }

	            var property = node[propertyName];

	            var before = context.getTokenBefore(property),
	                first = context.getFirstToken(property),
	                last = context.getLastToken(property),
	                after = context.getTokenAfter(property);

	            if (astUtils.isTokenOnSameLine(before, first)) {
	                if (propertyNameMustBeSpaced) {
	                    if (!astUtils.isTokenSpaced(before, first) && astUtils.isTokenOnSameLine(before, first)) {
	                        reportRequiredBeginningSpace(node, before);
	                    }
	                } else {
	                    if (astUtils.isTokenSpaced(before, first)) {
	                        reportNoBeginningSpace(node, before);
	                    }
	                }
	            }

	            if (astUtils.isTokenOnSameLine(last, after)) {
	                if (propertyNameMustBeSpaced) {
	                    if (!astUtils.isTokenSpaced(last, after) && astUtils.isTokenOnSameLine(last, after)) {
	                        reportRequiredEndingSpace(node, after);
	                    }
	                } else {
	                    if (astUtils.isTokenSpaced(last, after)) {
	                        reportNoEndingSpace(node, after);
	                    }
	                }
	            }
	        };
	    }


	    //--------------------------------------------------------------------------
	    // Public
	    //--------------------------------------------------------------------------

	    return {
	        Property: checkSpacing("key"),
	        MemberExpression: checkSpacing("property")
	    };

	};

	module.exports.schema = [
	    {
	        "enum": ["always", "never"]
	    }
	];


/***/ },
/* 300 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to enforce consistent naming of "this" context variables
	 * @author Raphael Pigulla
	 * @copyright 2015 Timothy Jones. All rights reserved.
	 * @copyright 2015 David Aurelio. All rights reserved.
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {
	    var alias = context.options[0];

	    /**
	     * Reports that a variable declarator or assignment expression is assigning
	     * a non-'this' value to the specified alias.
	     * @param {ASTNode} node - The assigning node.
	     * @returns {void}
	     */
	    function reportBadAssignment(node) {
	        context.report(node,
	            "Designated alias '{{alias}}' is not assigned to 'this'.",
	            { alias: alias });
	    }

	    /**
	     * Checks that an assignment to an identifier only assigns 'this' to the
	     * appropriate alias, and the alias is only assigned to 'this'.
	     * @param {ASTNode} node - The assigning node.
	     * @param {Identifier} name - The name of the variable assigned to.
	     * @param {Expression} value - The value of the assignment.
	     * @returns {void}
	     */
	    function checkAssignment(node, name, value) {
	        var isThis = value.type === "ThisExpression";

	        if (name === alias) {
	            if (!isThis || node.operator && node.operator !== "=") {
	                reportBadAssignment(node);
	            }
	        } else if (isThis) {
	            context.report(node,
	                "Unexpected alias '{{name}}' for 'this'.", { name: name });
	        }
	    }

	    /**
	     * Ensures that a variable declaration of the alias in a program or function
	     * is assigned to the correct value.
	     * @returns {void}
	     */
	    function ensureWasAssigned() {
	        var scope = context.getScope();

	        scope.variables.some(function(variable) {
	            var lookup;

	            if (variable.name === alias) {
	                if (variable.defs.some(function(def) {
	                    return def.node.type === "VariableDeclarator" &&
	                        def.node.init !== null;
	                })) {
	                    return true;
	                }

	                lookup = scope.type === "global" ? scope : variable;

	                // The alias has been declared and not assigned: check it was
	                // assigned later in the same scope.
	                if (!lookup.references.some(function(reference) {
	                    var write = reference.writeExpr;

	                    if (reference.from === scope &&
	                            write && write.type === "ThisExpression" &&
	                            write.parent.operator === "=") {
	                        return true;
	                    }
	                })) {
	                    variable.defs.map(function(def) {
	                        return def.node;
	                    }).forEach(reportBadAssignment);
	                }

	                return true;
	            }
	        });
	    }

	    return {
	        "Program:exit": ensureWasAssigned,
	        "FunctionExpression:exit": ensureWasAssigned,
	        "FunctionDeclaration:exit": ensureWasAssigned,

	        "VariableDeclarator": function(node) {
	            var id = node.id;
	            var isDestructuring =
	                id.type === "ArrayPattern" || id.type === "ObjectPattern";

	            if (node.init !== null && !isDestructuring) {
	                checkAssignment(node, id.name, node.init);
	            }
	        },

	        "AssignmentExpression": function(node) {
	            if (node.left.type === "Identifier") {
	                checkAssignment(node, node.left.name, node.right);
	            }
	        }
	    };

	};

	module.exports.schema = [
	    {
	        "type": "string"
	    }
	];


/***/ },
/* 301 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Require file to end with single newline.
	 * @author Nodeca Team <https://github.com/nodeca>
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    //--------------------------------------------------------------------------
	    // Public
	    //--------------------------------------------------------------------------

	    return {

	        "Program": function checkBadEOF(node) {
	            // Get the whole source code, not for node only.
	            var src = context.getSource(), location = {column: 1};

	            if (src.length === 0) {
	                return;
	            }

	            if (src[src.length - 1] !== "\n") {
	                // file is not newline-terminated
	                location.line = src.split(/\n/g).length;
	                context.report(node, location, "Newline required at end of file but not found.");
	            }
	        }

	    };

	};

	module.exports.schema = [];


/***/ },
/* 302 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to warn when a function expression does not have a name.
	 * @author Kyle T. Nunery
	 * @copyright 2015 Brandon Mills. All rights reserved.
	 * @copyright 2014 Kyle T. Nunery. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    /**
	     * Determines whether the current FunctionExpression node is a get, set, or
	     * shorthand method in an object literal or a class.
	     * @returns {boolean} True if the node is a get, set, or shorthand method.
	     */
	    function isObjectOrClassMethod() {
	        var parent = context.getAncestors().pop();

	        return (parent.type === "MethodDefinition" || (
	            parent.type === "Property" && (
	                parent.method ||
	                parent.kind === "get" ||
	                parent.kind === "set"
	            )
	        ));
	    }

	    return {
	        "FunctionExpression": function(node) {

	            var name = node.id && node.id.name;

	            if (!name && !isObjectOrClassMethod()) {
	                context.report(node, "Missing function expression name.");
	            }
	        }
	    };
	};

	module.exports.schema = [];


/***/ },
/* 303 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to enforce a particular function style
	 * @author Nicholas C. Zakas
	 * @copyright 2013 Nicholas C. Zakas. All rights reserved.
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var style = context.options[0],
	        enforceDeclarations = (style === "declaration");

	    return {

	        "FunctionDeclaration": function(node) {
	            if (!enforceDeclarations) {
	                context.report(node, "Expected a function expression.");
	            }
	        },

	        "FunctionExpression": function() {
	            var parent = context.getAncestors().pop();

	            if (enforceDeclarations && parent.type === "VariableDeclarator") {
	                context.report(parent, "Expected a function declaration.");
	            }
	        },

	        "ArrowFunctionExpression": function() {
	            var parent = context.getAncestors().pop();

	            if (enforceDeclarations && parent.type === "VariableDeclarator") {
	                context.report(parent, "Expected a function declaration.");
	            }
	        }

	    };

	};

	module.exports.schema = [
	    {
	        "enum": ["declaration", "expression"]
	    }
	];


/***/ },
/* 304 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule that warns when identifier names are shorter or longer
	 *               than the values provided in configuration.
	 * @author Burak Yigit Kaya aka BYK
	 * @copyright 2015 Burak Yigit Kaya. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {
	    var options = context.options[0] || {};
	    var minLength = typeof options.min !== "undefined" ? options.min : 2;
	    var maxLength = typeof options.max !== "undefined" ? options.max : Infinity;
	    var exceptions = (options.exceptions ? options.exceptions : [])
	        .reduce(function(obj, item) {
	        obj[item] = true;

	        return obj;
	    }, {});

	    var SUPPORTED_EXPRESSIONS = {
	        "AssignmentExpression": function(parent, node) {
	            return parent.left.type === "MemberExpression" &&
	                !parent.left.computed && parent.left.property === node;
	        },
	        "VariableDeclarator": function(parent, node) {
	            return parent.id === node;
	        },
	        "ObjectExpression": function(parent, node) {
	            return node.parent.key === node;
	        },
	        "FunctionExpression": true,
	        "ArrowFunctionExpression": true,
	        "FunctionDeclaration": true,
	        "CatchClause": true
	    };

	    return {
	        Identifier: function(node) {
	            var name = node.name;
	            var effectiveParent = (node.parent.type === "MemberExpression" || node.parent.type === "Property") ?
	                                  node.parent.parent : node.parent;

	            var isShort = name.length < minLength;
	            var isLong = name.length > maxLength;
	            if (!(isShort || isLong) || exceptions[name]) {
	                return;  // Nothing to report
	            }

	            var isValidExpression = SUPPORTED_EXPRESSIONS[effectiveParent.type];

	            if (isValidExpression && (isValidExpression === true || isValidExpression(effectiveParent, node))) {
	                context.report(
	                    node,
	                    isShort ?
	                        "Identifier name '{{name}}' is too short. (< {{min}})" :
	                        "Identifier name '{{name}}' is too long. (> {{max}})",
	                    { name: name, min: minLength, max: maxLength }
	                );
	            }
	        }
	    };
	};

	module.exports.schema = [
	    {
	        "type": "object",
	        "properties": {
	            "min": {
	                "type": "number"
	            },
	            "max": {
	                "type": "number"
	            },
	            "exceptions": {
	                "type": "array",
	                "uniqueItems": true,
	                "items": {
	                    "type": "string"
	                }
	            }
	        },
	        "additionalProperties": false
	    }
	];


/***/ },
/* 305 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview This option sets a specific tab width for your code

	 * This rule has been ported and modified from nodeca.
	 * @author Vitaly Puzrin
	 * @author Gyandeep Singh
	 * @copyright 2015 Vitaly Puzrin. All rights reserved.
	 * @copyright 2015 Gyandeep Singh. All rights reserved.
	 Copyright (C) 2014 by Vitaly Puzrin

	 Permission is hereby granted, free of charge, to any person obtaining a copy
	 of this software and associated documentation files (the "Software"), to deal
	 in the Software without restriction, including without limitation the rights
	 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 copies of the Software, and to permit persons to whom the Software is
	 furnished to do so, subject to the following conditions:

	 The above copyright notice and this permission notice shall be included in
	 all copies or substantial portions of the Software.

	 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 THE SOFTWARE.
	*/
	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	var util = __webpack_require__(213);
	var assign = __webpack_require__(306);

	module.exports = function(context) {

	    var MESSAGE = "Expected indentation of {{needed}} characters but found {{gotten}}.";

	    var extraColumnStart = 0;
	    var indentType = "spaces";
	    var indentSize = 4;
	    var options = {
	        SwitchCase: 0,
	        VariableDeclarator: 1
	    };

	    if (context.options.length) {
	        if (context.options[0] === "tab") {
	            indentSize = 1;
	            indentType = "tab";
	        } else /* istanbul ignore else : this will be caught by options validation */ if (typeof context.options[0] === "number") {
	            indentSize = context.options[0];
	            indentType = "spaces";
	        }

	        if (context.options[1]) {
	            var opts = context.options[1];
	            assign(options, opts);
	        }
	    }

	    var caseIndentStore = {};

	    /**
	     * Get node indent
	     * @param {ASTNode} node Node to examine
	     * @param {boolean} byLastLine get indent of node's last line
	     * @param {boolean} excludeCommas skip comma on start of line
	     * @returns {int} Indent
	     */
	    function getNodeIndent(node, byLastLine, excludeCommas) {
	        byLastLine = byLastLine || false;
	        excludeCommas = excludeCommas || false;

	        var src = context.getSource(node, node.loc.start.column + extraColumnStart);
	        var lines = src.split("\n");
	        if (byLastLine) {
	            src = lines[lines.length - 1];
	        } else {
	            src = lines[0];
	        }

	        var skip = excludeCommas ? "," : "";

	        var regExp;
	        if (indentType === "spaces") {
	            regExp = new RegExp("^[ " + skip + "]+");
	        } else {
	            regExp = new RegExp("^[\t" + skip + "]+");
	        }

	        var indent = regExp.exec(src);
	        return indent ? indent[0].length : 0;
	    }

	    /**
	     * Checks node is the first in its own start line.
	     * @param {ASTNode} node The node to check
	     * @returns {boolean} true if its the first in the its start line
	     */
	    function isNodeFirstInLine(node) {
	        var firstToken = context.getTokenBefore(node),
	            startLine = node.loc.start.line,
	            endLine = firstToken ? firstToken.loc.end.line : -1;

	        return startLine !== endLine;
	    }

	    /**
	     * Check indent for nodes list
	     * @param {ASTNode[]} nodes list of node objects
	     * @param {int} indent needed indent
	     * @param {boolean} excludeCommas skip comma on start of line
	     * @returns {void}
	     */
	    function checkNodesIndent(nodes, indent, excludeCommas) {
	        nodes.forEach(function(node) {
	            var nodeIndent = getNodeIndent(node, false, excludeCommas);
	            if (nodeIndent !== indent && isNodeFirstInLine(node)) {
	                context.report(node, MESSAGE, { gotten: nodeIndent, needed: indent });
	            }
	        });
	    }

	    /**
	     * Check last node line indent this detects, that block closed correctly
	     * @param {ASTNode} node Node to examine
	     * @param {int} lastLineIndent needed indent
	     * @returns {void}
	     */
	    function checkLastNodeLineIndent(node, lastLineIndent) {
	        var endIndent = getNodeIndent(node, true);
	        if (endIndent !== lastLineIndent) {
	            context.report(
	                node,
	                { line: node.loc.end.line, column: node.loc.end.column },
	                MESSAGE,
	                { gotten: endIndent, needed: lastLineIndent }
	            );
	        }
	    }

	    /**
	     * Check first node line indent is correct
	     * @param {ASTNode} node Node to examine
	     * @param {int} firstLineIndent needed indent
	     * @returns {void}
	     */
	    function checkFirstNodeLineIndent(node, firstLineIndent) {
	        var startIndent = getNodeIndent(node, false);
	        if (startIndent !== firstLineIndent && isNodeFirstInLine(node)) {
	            context.report(
	                node,
	                { line: node.loc.start.line, column: node.loc.start.column },
	                MESSAGE,
	                { gotten: startIndent, needed: firstLineIndent }
	            );
	        }
	    }

	    /**
	     * Check indent for function block content
	     * @param {ASTNode} node node to examine
	     * @returns {void}
	     */
	    function checkIndentInFunctionBlock(node) {

	        // Search first caller in chain.
	        // Ex.:
	        //
	        // Models <- Identifier
	        //   .User
	        //   .find()
	        //   .exec(function() {
	        //   // function body
	        // });
	        //
	        // Looks for 'Models'
	        var calleeNode = node.parent; // FunctionExpression
	        while (calleeNode.parent &&
	        calleeNode.parent.type === "CallExpression") {
	            calleeNode = calleeNode.parent;
	        }

	        var indent;

	        if (calleeNode.parent &&
	            (calleeNode.parent.type === "Property" ||
	            calleeNode.parent.type === "ArrayExpression")) {
	            // If function is part of array or object, comma can be put at left
	            indent = getNodeIndent(calleeNode, false, true);
	        } else {
	            // If function is standalone, simple calculate indent
	            indent = getNodeIndent(calleeNode);
	        }

	        indent += indentSize;
	        // If function content is not empty
	        if (node.body.length > 0) {
	            // Calculate left shift position don't require strict indent
	            // allow function body allign to (indentSize * X)
	            while (getNodeIndent(node.body[0]) > indent) {
	                indent += indentSize;
	            }
	        }

	        checkNodesIndent(node.body, indent);

	        checkLastNodeLineIndent(node, indent - indentSize);
	    }


	    /**
	     * Checks if the given node starts and ends on the same line
	     * @param {ASTNode} node The node to check
	     * @returns {boolean} Whether or not the block starts and ends on the same line.
	     */
	    function isSingleLineNode(node) {
	        var lastToken = context.getLastToken(node),
	            startLine = node.loc.start.line,
	            endLine = lastToken.loc.end.line;

	        return startLine === endLine;
	    }

	    /**
	     * Check to see if the node is part of the multi-line variable declaration.
	     * Also if its on the same line as the parent
	     * @param {ASTNode} node node to check
	     * @returns {boolean} True if all the above condition staisfy
	     */
	    function isNodeInVarOnTop(node) {
	        var parent = node.parent.type === "VariableDeclarator" ? node.parent : node.parent.parent;

	        return parent.type === "VariableDeclarator" &&
	            parent.parent.loc.start.line === node.loc.start.line &&
	            parent.parent.declarations.length > 1;
	    }

	    /**
	     * Check to see if the first element inside an array ia an object and on the same line as the node
	     * If the node is not an array then it will return false.
	     * @param {ASTNode} node node to check
	     * @returns {boolean} success/failure
	     */
	    function isFirstArrayElementOnSameLine(node) {
	        if (node.type === "ArrayExpression" && node.elements[0]) {
	            return node.elements[0].loc.start.line === node.loc.start.line && node.elements[0].type === "ObjectExpression";
	        } else {
	            return false;
	        }
	    }

	    /**
	     * Returns the VariableDeclarator based on the current node
	     * if not present then return null
	     * @param {ASTNode} node node to examine
	     * @returns {ASTNode|void} if found then node otherwise null
	     */
	    function getVariableDeclaratorNode(node) {
	        var parent = node.parent;

	        while (parent.type !== "VariableDeclarator" && parent.type !== "Program") {
	            parent = parent.parent;
	        }

	        return parent.type === "VariableDeclarator" ? parent : null;
	    }

	    /**
	     * Check indent for array block content or object block content
	     * @param {ASTNode} node node to examine
	     * @returns {void}
	     */
	    function checkIndentInArrayOrObjectBlock(node) {
	        // Skip inline
	        if (isSingleLineNode(node)) {
	            return;
	        }

	        var elements = (node.type === "ArrayExpression") ? node.elements : node.properties;

	        // filter out empty elements example would be [ , 2] so remove first element as espree considers it as null
	        elements = elements.filter(function(elem) {
	            return elem !== null;
	        });

	        // Skip if first element is in same line with this node
	        if (elements.length > 0 && elements[0].loc.start.line === node.loc.start.line) {
	            return;
	        }

	        var nodeIndent;
	        var elementsIndent;

	        // TODO - come up with a better strategy in future
	        if (isNodeFirstInLine(node)) {
	            var parentVarNode = getVariableDeclaratorNode(node);
	            var parent = node.parent;
	            if (parent.type === "MemberExpression") {
	                parent = node.parent.parent;

	                if (isNodeFirstInLine(parent)) {
	                    nodeIndent = getNodeIndent(parent.parent);
	                } else {
	                    nodeIndent = getNodeIndent(parent);
	                }
	            } else {
	                nodeIndent = getNodeIndent(parent);
	            }

	            if (parentVarNode && parentVarNode.loc.start.line !== node.loc.start.line) {
	                if (parent.type !== "VariableDeclarator" || parentVarNode === parentVarNode.parent.declarations[0]) {
	                    nodeIndent = nodeIndent + (indentSize * options.VariableDeclarator);
	                } else if (parent.loc.start.line !== node.loc.start.line && parentVarNode === parentVarNode.parent.declarations[0]) {
	                    nodeIndent = nodeIndent + indentSize;
	                }
	            } else if (!parentVarNode && !isFirstArrayElementOnSameLine(parent)) {
	                nodeIndent = nodeIndent + indentSize;
	            }

	            elementsIndent = nodeIndent + indentSize;
	            checkFirstNodeLineIndent(node, nodeIndent);
	        } else {
	            nodeIndent = getNodeIndent(node);
	            elementsIndent = nodeIndent + indentSize;
	        }

	        // check if the node is a multiple variable declartion, if yes then make sure indetation takes into account
	        // variable indentation concept
	        if (isNodeInVarOnTop(node)) {
	            elementsIndent += indentSize * options.VariableDeclarator;
	        }

	        // Comma can be placed before property name
	        checkNodesIndent(elements, elementsIndent, true);

	        if (elements.length > 0) {
	            // Skip last block line check if last item in same line
	            if (elements[elements.length - 1].loc.end.line === node.loc.end.line) {
	                return;
	            }
	        }

	        checkLastNodeLineIndent(node, elementsIndent - indentSize);
	    }

	    /**
	     * Check if the node or node body is a BlockStatement or not
	     * @param {ASTNode} node node to test
	     * @returns {boolean} True if it or its body is a block statement
	     */
	    function isNodeBodyBlock(node) {
	        return node.type === "BlockStatement" || (node.body && node.body.type === "BlockStatement") ||
	            (node.consequent && node.consequent.type === "BlockStatement");
	    }

	    /**
	     * Check indentation for blocks
	     * @param {ASTNode} node node to check
	     * @returns {void}
	     */
	    function blockIndentationCheck(node) {
	        // Skip inline blocks
	        if (isSingleLineNode(node)) {
	            return;
	        }

	        if (node.parent && (node.parent.type === "FunctionExpression")) {
	            checkIndentInFunctionBlock(node);
	            return;
	        }

	        var indent;
	        var nodesToCheck = [];

	        // For this statements we should check indent from statement begin
	        // (not from block begin)
	        var statementsWithProperties = [
	            "IfStatement", "WhileStatement", "ForStatement", "ForInStatement", "ForOfStatement", "DoWhileStatement"
	        ];

	        if (node.parent && statementsWithProperties.indexOf(node.parent.type) !== -1 && isNodeBodyBlock(node)) {
	            indent = getNodeIndent(node.parent);
	        } else {
	            indent = getNodeIndent(node);
	        }

	        if (node.type === "IfStatement" && node.consequent.type !== "BlockStatement") {
	            nodesToCheck = [node.consequent];
	        } else if (util.isArray(node.body)) {
	            nodesToCheck = node.body;
	        } else {
	            nodesToCheck = [node.body];
	        }

	        if (nodesToCheck.length > 0) {
	            checkNodesIndent(nodesToCheck, indent + indentSize);
	        }

	        if (node.type === "BlockStatement") {
	            checkLastNodeLineIndent(node, indent);
	        }
	    }

	    /**
	     * Filter out the elements which are on the same line of each other or the node.
	     * basically have only 1 elements from each line except the variable declaration line.
	     * @param {ASTNodes} node Variable declaration node
	     * @returns {ASTNodes[]} Filtered elements
	     */
	    function filterOutSameLineVars(node) {
	        return node.declarations.reduce(function(finalCollection, elem) {
	            var lastElem = finalCollection[finalCollection.length - 1];

	            if ((elem.loc.start.line !== node.loc.start.line && !lastElem) ||
	                (lastElem && lastElem.loc.start.line !== elem.loc.start.line)) {
	                finalCollection.push(elem);
	            }

	            return finalCollection;
	        }, []);
	    }

	    /**
	     * Check indentation for variable declarations
	     * @param {ASTNode} node node to examine
	     * @returns {void}
	     */
	    function checkIndentInVariableDeclarations(node) {
	        var elements = filterOutSameLineVars(node);
	        var nodeIndent = getNodeIndent(node);
	        var elementsIndent = nodeIndent + (indentSize * options.VariableDeclarator);

	        // Comma can be placed before decalartion
	        checkNodesIndent(elements, elementsIndent, true);

	        if (elements.length > 0) {
	            // Skip last block line check if last item in same line
	            if (elements[elements.length - 1].loc.end.line === node.loc.end.line) {
	                return;
	            }
	        }

	        checkLastNodeLineIndent(node, elementsIndent - indentSize);
	    }

	    /**
	     * Check and decide wheteher to check for indentation for blockless nodes
	     * Scenarios are for or while statements without brances around them
	     * @param {ASTNode} node node to examine
	     * @returns {void}
	     */
	    function blockLessNodes(node) {
	        if (node.body.type !== "BlockStatement") {
	            blockIndentationCheck(node);
	        }
	    }

	    /**
	     * Returns the expected indentation for the case statement
	     * @param {ASTNode} node node to examine
	     * @param {int} switchIndent indent for switch statement
	     * @returns {int} indent size
	     */
	    function expectedCaseIndent(node, switchIndent) {
	        var switchNode = (node.type === "SwitchStatement") ? node : node.parent;
	        var caseIndent;

	        if (caseIndentStore[switchNode.loc.start.line]) {
	            return caseIndentStore[switchNode.loc.start.line];
	        } else {
	            if (typeof switchIndent === "undefined") {
	                switchIndent = getNodeIndent(switchNode);
	            }

	            if (switchNode.cases.length > 0 && options.SwitchCase === 0) {
	                caseIndent = switchIndent;
	            } else {
	                caseIndent = switchIndent + (indentSize * options.SwitchCase);
	            }

	            caseIndentStore[switchNode.loc.start.line] = caseIndent;
	            return caseIndent;
	        }
	    }

	    return {
	        "Program": function(node) {
	            var nodeIndent = getNodeIndent(node);

	            // Root nodes should have no indent
	            checkNodesIndent(node.body, nodeIndent);
	        },

	        "BlockStatement": blockIndentationCheck,

	        "WhileStatement": blockLessNodes,

	        "ForStatement": blockLessNodes,

	        "ForInStatement": blockLessNodes,

	        "ForOfStatement": blockLessNodes,

	        "DoWhileStatement": blockLessNodes,

	        "IfStatement": function(node) {
	            if (node.consequent.type !== "BlockStatement" && node.consequent.loc.start.line > node.loc.start.line) {
	                blockIndentationCheck(node);
	            }
	        },

	        "VariableDeclaration": function(node) {
	            if (node.declarations[node.declarations.length - 1].loc.start.line > node.declarations[0].loc.start.line) {
	                checkIndentInVariableDeclarations(node);
	            }
	        },

	        "ObjectExpression": function(node) {
	            checkIndentInArrayOrObjectBlock(node);
	        },

	        "ArrayExpression": function(node) {
	            checkIndentInArrayOrObjectBlock(node);
	        },

	        "SwitchStatement": function(node) {
	            // Switch is not a 'BlockStatement'
	            var switchIndent = getNodeIndent(node);
	            var caseIndent = expectedCaseIndent(node, switchIndent);
	            checkNodesIndent(node.cases, caseIndent);


	            checkLastNodeLineIndent(node, switchIndent);
	        },

	        "SwitchCase": function(node) {
	            // Skip inline cases
	            if (isSingleLineNode(node)) {
	                return;
	            }
	            var caseIndent = expectedCaseIndent(node);
	            checkNodesIndent(node.consequent, caseIndent + indentSize);
	        }
	    };

	};

	module.exports.schema = [
	    {
	        "oneOf": [
	            {
	                "enum": ["tab"]
	            },
	            {
	                "type": "integer"
	            }
	        ]
	    },
	    {
	        "type": "object",
	        "properties": {
	            "SwitchCase": {
	                "type": "integer"
	            },
	            "VariableDeclarator": {
	                "type": "integer"
	            }
	        },
	        "additionalProperties": false
	    }
	];


/***/ },
/* 306 */
/***/ function(module, exports) {

	'use strict';

	function ToObject(val) {
		if (val == null) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	module.exports = Object.assign || function (target, source) {
		var from;
		var keys;
		var to = ToObject(target);

		for (var s = 1; s < arguments.length; s++) {
			from = arguments[s];
			keys = Object.keys(Object(from));

			for (var i = 0; i < keys.length; i++) {
				to[keys[i]] = from[keys[i]];
			}
		}

		return to;
	};


/***/ },
/* 307 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to specify spacing of object literal keys and values
	 * @author Brandon Mills
	 * @copyright 2014 Brandon Mills. All rights reserved.
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------

	/**
	 * Checks whether a string contains a line terminator as defined in
	 * http://www.ecma-international.org/ecma-262/5.1/#sec-7.3
	 * @param {string} str String to test.
	 * @returns {boolean} True if str contains a line terminator.
	 */
	function containsLineTerminator(str) {
	    return /[\n\r\u2028\u2029]/.test(str);
	}

	/**
	 * Gets the last element of an array.
	 * @param {Array} arr An array.
	 * @returns {any} Last element of arr.
	 */
	function last(arr) {
	    return arr[arr.length - 1];
	}

	/**
	 * Checks whether a property is a member of the property group it follows.
	 * @param {ASTNode} lastMember The last Property known to be in the group.
	 * @param {ASTNode} candidate The next Property that might be in the group.
	 * @returns {boolean} True if the candidate property is part of the group.
	 */
	function continuesPropertyGroup(lastMember, candidate) {
	    var groupEndLine = lastMember.loc.start.line,
	        candidateStartLine = candidate.loc.start.line,
	        comments, i;

	    if (candidateStartLine - groupEndLine <= 1) {
	        return true;
	    }

	    // Check that the first comment is adjacent to the end of the group, the
	    // last comment is adjacent to the candidate property, and that successive
	    // comments are adjacent to each other.
	    comments = candidate.leadingComments;
	    if (
	        comments &&
	        comments[0].loc.start.line - groupEndLine <= 1 &&
	        candidateStartLine - last(comments).loc.end.line <= 1
	    ) {
	        for (i = 1; i < comments.length; i++) {
	            if (comments[i].loc.start.line - comments[i - 1].loc.end.line > 1) {
	                return false;
	            }
	        }
	        return true;
	    }

	    return false;
	}

	/**
	 * Checks whether a node is contained on a single line.
	 * @param {ASTNode} node AST Node being evaluated.
	 * @returns {boolean} True if the node is a single line.
	 */
	function isSingleLine(node) {
	    return (node.loc.end.line === node.loc.start.line);
	}

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	var messages = {
	    key: "{{error}} space after {{computed}}key \"{{key}}\".",
	    value: "{{error}} space before value for {{computed}}key \"{{key}}\"."
	};

	module.exports = function(context) {

	    /**
	     * OPTIONS
	     * "key-spacing": [2, {
	     *     beforeColon: false,
	     *     afterColon: true,
	     *     align: "colon" // Optional, or "value"
	     * }
	     */

	    var options = context.options[0] || {},
	        align = options.align,
	        beforeColon = +!!options.beforeColon, // Defaults to false
	        afterColon = +!(options.afterColon === false); // Defaults to true

	    /**
	     * Gets an object literal property's key as the identifier name or string value.
	     * @param {ASTNode} property Property node whose key to retrieve.
	     * @returns {string} The property's key.
	     */
	    function getKey(property) {
	        var key = property.key;

	        if (property.computed) {
	            return context.getSource().slice(key.range[0], key.range[1]);
	        }

	        return property.key.name || property.key.value;
	    }

	    /**
	     * Reports an appropriately-formatted error if spacing is incorrect on one
	     * side of the colon.
	     * @param {ASTNode} property Key-value pair in an object literal.
	     * @param {string} side Side being verified - either "key" or "value".
	     * @param {string} whitespace Actual whitespace string.
	     * @param {int} expected Expected whitespace length.
	     * @returns {void}
	     */
	    function report(property, side, whitespace, expected) {
	        var diff = whitespace.length - expected,
	            key = property.key,
	            firstTokenAfterColon = context.getTokenAfter(key, 1),
	            location = side === "key" ? key.loc.start : firstTokenAfterColon.loc.start;

	        if (diff && !(expected && containsLineTerminator(whitespace))) {
	            context.report(property[side], location, messages[side], {
	                error: diff > 0 ? "Extra" : "Missing",
	                computed: property.computed ? "computed " : "",
	                key: getKey(property)
	            });
	        }
	    }

	    /**
	     * Gets the number of characters in a key, including quotes around string
	     * keys and braces around computed property keys.
	     * @param {ASTNode} property Property of on object literal.
	     * @returns {int} Width of the key.
	     */
	    function getKeyWidth(property) {
	        var key = property.key,
	            startToken, endToken;

	        // [computed]: value
	        if (property.computed) {
	            startToken = context.getTokenBefore(key);
	            endToken = context.getTokenAfter(key);
	            return endToken.range[1] - startToken.range[0];
	        }

	        // name: value
	        if (key.type === "Identifier") {
	            return key.name.length;
	        }

	        // "literal": value
	        // 42: value
	        if (key.type === "Literal") {
	            return key.raw.length;
	        }
	    }

	    /**
	     * Gets the whitespace around the colon in an object literal property.
	     * @param {ASTNode} property Property node from an object literal.
	     * @returns {Object} Whitespace before and after the property's colon.
	     */
	    function getPropertyWhitespace(property) {
	        var whitespace = /(\s*):(\s*)/.exec(context.getSource().slice(
	            property.key.range[1], property.value.range[0]
	        ));

	        if (whitespace) {
	            return {
	                beforeColon: whitespace[1],
	                afterColon: whitespace[2]
	            };
	        }
	    }

	    /**
	     * Creates groups of properties.
	     * @param  {ASTNode} node ObjectExpression node being evaluated.
	     * @returns {Array.<ASTNode[]>} Groups of property AST node lists.
	     */
	    function createGroups(node) {
	        if (node.properties.length === 1) {
	            return [node.properties];
	        }

	        return node.properties.reduce(function(groups, property) {
	            var currentGroup = last(groups),
	                prev = last(currentGroup);

	            if (!prev || continuesPropertyGroup(prev, property)) {
	                currentGroup.push(property);
	            } else {
	                groups.push([property]);
	            }

	            return groups;
	        }, [[]]);
	    }

	    /**
	     * Verifies correct vertical alignment of a group of properties.
	     * @param {ASTNode[]} properties List of Property AST nodes.
	     * @returns {void}
	     */
	    function verifyGroupAlignment(properties) {
	        var length = properties.length,
	            widths = properties.map(getKeyWidth), // Width of keys, including quotes
	            targetWidth = Math.max.apply(null, widths),
	            i, property, whitespace, width;

	        // Conditionally include one space before or after colon
	        targetWidth += (align === "colon" ? beforeColon : afterColon);

	        for (i = 0; i < length; i++) {
	            property = properties[i];
	            whitespace = getPropertyWhitespace(property);

	            if (!whitespace) {
	                continue; // Object literal getters/setters lack a colon
	            }

	            width = widths[i];

	            if (align === "value") {
	                report(property, "key", whitespace.beforeColon, beforeColon);
	                report(property, "value", whitespace.afterColon, targetWidth - width);
	            } else { // align = "colon"
	                report(property, "key", whitespace.beforeColon, targetWidth - width);
	                report(property, "value", whitespace.afterColon, afterColon);
	            }
	        }
	    }

	    /**
	     * Verifies vertical alignment, taking into account groups of properties.
	     * @param  {ASTNode} node ObjectExpression node being evaluated.
	     * @returns {void}
	     */
	    function verifyAlignment(node) {
	        createGroups(node).forEach(function(group) {
	            verifyGroupAlignment(group);
	        });
	    }

	    /**
	     * Verifies spacing of property conforms to specified options.
	     * @param  {ASTNode} node Property node being evaluated.
	     * @returns {void}
	     */
	    function verifySpacing(node) {
	        var whitespace = getPropertyWhitespace(node);
	        if (whitespace) { // Object literal getters/setters lack colons
	            report(node, "key", whitespace.beforeColon, beforeColon);
	            report(node, "value", whitespace.afterColon, afterColon);
	        }
	    }

	    /**
	     * Verifies spacing of each property in a list.
	     * @param  {ASTNode[]} properties List of Property AST nodes.
	     * @returns {void}
	     */
	    function verifyListSpacing(properties) {
	        var length = properties.length;

	        for (var i = 0; i < length; i++) {
	            verifySpacing(properties[i]);
	        }
	    }

	    //--------------------------------------------------------------------------
	    // Public API
	    //--------------------------------------------------------------------------

	    if (align) { // Verify vertical alignment

	        return {
	            "ObjectExpression": function(node) {
	                if (isSingleLine(node)) {
	                    verifyListSpacing(node.properties);
	                } else {
	                    verifyAlignment(node);
	                }
	            }
	        };

	    } else { // Strictly obey beforeColon and afterColon in each property

	        return {
	            "Property": function(node) {
	                verifySpacing(node);
	            }
	        };

	    }

	};

	module.exports.schema = [
	    {
	        "type": "object",
	        "properties": {
	            "align": {
	                "enum": ["colon", "value"]
	            },
	            "beforeColon": {
	                "type": "boolean"
	            },
	            "afterColon": {
	                "type": "boolean"
	            }
	        },
	        "additionalProperties": false
	    }
	];


/***/ },
/* 308 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Enforces empty lines around comments.
	 * @author Jamund Ferguson
	 * @copyright 2015 Mathieu M-Gosselin. All rights reserved.
	 * @copyright 2015 Jamund Ferguson. All rights reserved.
	 * @copyright 2015 Gyandeep Singh. All rights reserved.
	 */
	"use strict";

	/**
	 * Return an array with with any line numbers that are empty.
	 * @param {Array} lines An array of each line of the file.
	 * @returns {Array} An array of line numbers.
	 */
	function getEmptyLineNums(lines) {
	    var emptyLines = lines.map(function(line, i) {
	        return {
	            code: line.trim(),
	            num: i + 1
	        };
	    }).filter(function(line) {
	        return !line.code;
	    }).map(function(line) {
	        return line.num;
	    });
	    return emptyLines;
	}

	/**
	 * Return an array with with any line numbers that contain comments.
	 * @param {Array} comments An array of comment nodes.
	 * @returns {Array} An array of line numbers.
	 */
	function getCommentLineNums(comments) {
	    var lines = [];
	    comments.forEach(function(token) {
	        var start = token.loc.start.line;
	        var end = token.loc.end.line;
	        lines.push(start, end);
	    });
	    return lines;
	}

	/**
	 * Determines if a value is an array.
	 * @param {number} val The value we wish to check for in the array..
	 * @param {Array} array An array.
	 * @returns {boolean} True if the value is in the array..
	 */
	function contains(val, array) {
	    return array.indexOf(val) > -1;
	}

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var options = context.options[0] || {};
	    options.beforeLineComment = options.beforeLineComment || false;
	    options.afterLineComment = options.afterLineComment || false;
	    options.beforeBlockComment = typeof options.beforeBlockComment !== "undefined" ? options.beforeBlockComment : true;
	    options.afterBlockComment = options.afterBlockComment || false;
	    options.allowBlockStart = options.allowBlockStart || false;
	    options.allowBlockEnd = options.allowBlockEnd || false;

	    /**
	     * Returns whether or not comments are not on lines starting with or ending with code
	     * @param {ASTNode} node The comment node to check.
	     * @returns {boolean} True if the comment is not alone.
	     */
	    function codeAroundComment(node) {

	        var lines = context.getSourceLines();

	        // Get the whole line and cut it off at the start of the comment
	        var startLine = lines[node.loc.start.line - 1];
	        var endLine = lines[node.loc.end.line - 1];

	        var preamble = startLine.slice(0, node.loc.start.column).trim();

	        // Also check after the comment
	        var postamble = endLine.slice(node.loc.end.column).trim();

	        // Should be false if there was only whitespace around the comment
	        return !!(preamble || postamble);
	    }

	    /**
	     * Returns whether or not comments are at the block start or not.
	     * @param {ASTNode} node The Comment node.
	     * @returns {boolean} True if the comment is at block start.
	     */
	    function isCommentAtBlockStart(node) {
	        var ancestors = context.getAncestors();
	        var parent;

	        if (ancestors.length) {
	            parent = ancestors.pop();
	        }

	        return parent && (parent.type === "ClassBody" || parent.type === "BlockStatement" || (parent.body && parent.body.type === "BlockStatement")) &&
	                node.loc.start.line - parent.loc.start.line === 1;
	    }

	    /**
	     * Returns whether or not comments are at the block end or not.
	     * @param {ASTNode} node The Comment node.
	     * @returns {boolean} True if the comment is at block end.
	     */
	    function isCommentAtBlockEnd(node) {
	        var ancestors = context.getAncestors();
	        var parent;

	        if (ancestors.length) {
	            parent = ancestors.pop();
	        }

	        return parent && (parent.type === "ClassBody" || parent.type === "BlockStatement" || (parent.body && parent.body.type === "BlockStatement")) &&
	                parent.loc.end.line - node.loc.end.line === 1;
	    }

	    /**
	     * Checks if a comment node has lines around it (ignores inline comments)
	     * @param {ASTNode} node The Comment node.
	     * @param {Object} opts Options to determine the newline.
	     * @param {Boolean} opts.after Should have a newline after this line.
	     * @param {Boolean} opts.before Should have a newline before this line.
	     * @returns {void}
	     */
	    function checkForEmptyLine(node, opts) {

	        var lines = context.getSourceLines(),
	            numLines = lines.length + 1,
	            comments = context.getAllComments(),
	            commentLines = getCommentLineNums(comments),
	            emptyLines = getEmptyLineNums(lines),
	            commentAndEmptyLines = commentLines.concat(emptyLines);

	        var after = opts.after,
	            before = opts.before;

	        var prevLineNum = node.loc.start.line - 1,
	            nextLineNum = node.loc.end.line + 1,
	            commentIsNotAlone = codeAroundComment(node);

	        var blockStartAllowed = options.allowBlockStart && isCommentAtBlockStart(node),
	            blockEndAllowed = options.allowBlockEnd && isCommentAtBlockEnd(node);

	        // ignore top of the file and bottom of the file
	        if (prevLineNum < 1) {
	            before = false;
	        }
	        if (nextLineNum >= numLines) {
	            after = false;
	        }

	        // we ignore all inline comments
	        if (commentIsNotAlone) {
	            return;
	        }

	        // check for newline before
	        if (!blockStartAllowed && before && !contains(prevLineNum, commentAndEmptyLines)) {
	            context.report(node, "Expected line before comment.");
	        }

	        // check for newline after
	        if (!blockEndAllowed && after && !contains(nextLineNum, commentAndEmptyLines)) {
	            context.report(node, "Expected line after comment.");
	        }

	    }

	    //--------------------------------------------------------------------------
	    // Public
	    //--------------------------------------------------------------------------

	    return {

	        "LineComment": function(node) {
	            if (options.beforeLineComment || options.afterLineComment) {
	                checkForEmptyLine(node, {
	                    after: options.afterLineComment,
	                    before: options.beforeLineComment
	                });
	            }
	        },

	        "BlockComment": function(node) {
	            if (options.beforeBlockComment || options.afterBlockComment) {
	                checkForEmptyLine(node, {
	                    after: options.afterBlockComment,
	                    before: options.beforeBlockComment
	                });
	            }
	        }

	    };
	};

	module.exports.schema = [
	    {
	        "type": "object",
	        "properties": {
	            "beforeBlockComment": {
	                "type": "boolean"
	            },
	            "afterBlockComment": {
	                "type": "boolean"
	            },
	            "beforeLineComment": {
	                "type": "boolean"
	            },
	            "afterLineComment": {
	                "type": "boolean"
	            },
	            "allowBlockStart": {
	                "type": "boolean"
	            },
	            "allowBlockEnd": {
	                "type": "boolean"
	            }
	        },
	        "additionalProperties": false
	    }
	];


/***/ },
/* 309 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to forbid mixing LF and LFCR line breaks.
	 * @author Erik Mueller
	 * @copyright 2015 Varun Verma. All rights reserverd.
	 * @copyright 2015 James Whitney. All rights reserved.
	 * @copyright 2015 Erik Mueller. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {
	    var EXPECTED_LF_MSG = "Expected linebreaks to be 'LF' but found 'CRLF'.",
	        EXPECTED_CRLF_MSG = "Expected linebreaks to be 'CRLF' but found 'LF'.";

	    return {
	        "Program": function checkForlinebreakStyle(node) {
	            var linebreakStyle = context.options[0] || "unix",
	                expectedLF = linebreakStyle === "unix",
	                linebreaks = context.getSource().match(/\r\n|\r|\n|\u2028|\u2029/g),
	                lineOfError = -1;

	            if (linebreaks !== null) {
	                lineOfError = linebreaks.indexOf(expectedLF ? "\r\n" : "\n");
	            }

	            if (lineOfError !== -1) {
	                context.report(node, {
	                    line: lineOfError + 1,
	                    column: context.getSourceLines()[lineOfError].length
	                }, expectedLF ? EXPECTED_LF_MSG : EXPECTED_CRLF_MSG);
	            }
	        }
	    };
	};

	module.exports.schema = [
	    {
	        "enum": ["unix", "windows"]
	    }
	];


/***/ },
/* 310 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to enforce a maximum number of nested callbacks.
	 * @author Ian Christian Myers
	 * @copyright 2013 Ian Christian Myers. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    //--------------------------------------------------------------------------
	    // Constants
	    //--------------------------------------------------------------------------

	    var THRESHOLD = context.options[0];

	    //--------------------------------------------------------------------------
	    // Helpers
	    //--------------------------------------------------------------------------

	    var callbackStack = [];

	    /**
	     * Checks a given function node for too many callbacks.
	     * @param {ASTNode} node The node to check.
	     * @returns {void}
	     * @private
	     */
	    function checkFunction(node) {
	        var parent = node.parent;

	        if (parent.type === "CallExpression") {
	            callbackStack.push(node);
	        }

	        if (callbackStack.length > THRESHOLD) {
	            var opts = {num: callbackStack.length, max: THRESHOLD};
	            context.report(node, "Too many nested callbacks ({{num}}). Maximum allowed is {{max}}.", opts);
	        }
	    }

	    /**
	     * Pops the call stack.
	     * @returns {void}
	     * @private
	     */
	    function popStack() {
	        callbackStack.pop();
	    }

	    //--------------------------------------------------------------------------
	    // Public API
	    //--------------------------------------------------------------------------

	    return {
	        "ArrowFunctionExpression": checkFunction,
	        "ArrowFunctionExpression:exit": popStack,

	        "FunctionExpression": checkFunction,
	        "FunctionExpression:exit": popStack
	    };

	};

	module.exports.schema = [
	    {
	        "type": "integer"
	    }
	];


/***/ },
/* 311 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag use of constructors without capital letters
	 * @author Nicholas C. Zakas
	 * @copyright 2014 Jordan Harband. All rights reserved.
	 * @copyright 2013-2014 Nicholas C. Zakas. All rights reserved.
	 */

	"use strict";

	var CAPS_ALLOWED = [
	    "Array",
	    "Boolean",
	    "Date",
	    "Error",
	    "Function",
	    "Number",
	    "Object",
	    "RegExp",
	    "String",
	    "Symbol"
	];

	/**
	 * Ensure that if the key is provided, it must be an array.
	 * @param {Object} obj Object to check with `key`.
	 * @param {string} key Object key to check on `obj`.
	 * @param {*} fallback If obj[key] is not present, this will be returned.
	 * @returns {string[]} Returns obj[key] if it's an Array, otherwise `fallback`
	 */
	function checkArray(obj, key, fallback) {
	    /* istanbul ignore if */
	    if (Object.prototype.hasOwnProperty.call(obj, key) && !Array.isArray(obj[key])) {
	        throw new TypeError(key + ", if provided, must be an Array");
	    }
	    return obj[key] || fallback;
	}

	/**
	 * A reducer function to invert an array to an Object mapping the string form of the key, to `true`.
	 * @param {Object} map Accumulator object for the reduce.
	 * @param {string} key Object key to set to `true`.
	 * @returns {Object} Returns the updated Object for further reduction.
	 */
	function invert(map, key) {
	    map[key] = true;
	    return map;
	}

	/**
	 * Creates an object with the cap is new exceptions as its keys and true as their values.
	 * @param {Object} config Rule configuration
	 * @returns {Object} Object with cap is new exceptions.
	 */
	function calculateCapIsNewExceptions(config) {
	    var capIsNewExceptions = checkArray(config, "capIsNewExceptions", CAPS_ALLOWED);

	    if (capIsNewExceptions !== CAPS_ALLOWED) {
	        capIsNewExceptions = capIsNewExceptions.concat(CAPS_ALLOWED);
	    }

	    return capIsNewExceptions.reduce(invert, {});
	}

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var config = context.options[0] || {};
	    config.newIsCap = config.newIsCap !== false;
	    config.capIsNew = config.capIsNew !== false;

	    var newIsCapExceptions = checkArray(config, "newIsCapExceptions", []).reduce(invert, {});

	    var capIsNewExceptions = calculateCapIsNewExceptions(config);

	    var listeners = {};

	    //--------------------------------------------------------------------------
	    // Helpers
	    //--------------------------------------------------------------------------

	    /**
	     * Get exact callee name from expression
	     * @param {ASTNode} node CallExpression or NewExpression node
	     * @returns {string} name
	     */
	    function extractNameFromExpression(node) {

	        var name = "",
	            property;

	        if (node.callee.type === "MemberExpression") {
	            property = node.callee.property;

	            if (property.type === "Literal" && (typeof property.value === "string")) {
	                name = property.value;
	            } else if (property.type === "Identifier" && !node.callee.computed) {
	                name = property.name;
	            }
	        } else {
	            name = node.callee.name;
	        }
	        return name;
	    }

	    /**
	     * Returns the capitalization state of the string -
	     * Whether the first character is uppercase, lowercase, or non-alphabetic
	     * @param {string} str String
	     * @returns {string} capitalization state: "non-alpha", "lower", or "upper"
	     */
	    function getCap(str) {
	        var firstChar = str.charAt(0);

	        var firstCharLower = firstChar.toLowerCase();
	        var firstCharUpper = firstChar.toUpperCase();

	        if (firstCharLower === firstCharUpper) {
	            // char has no uppercase variant, so it's non-alphabetic
	            return "non-alpha";
	        } else if (firstChar === firstCharLower) {
	            return "lower";
	        } else {
	            return "upper";
	        }
	    }

	    /**
	     * Check if capitalization is allowed for a CallExpression
	     * @param {Object} allowedMap Object mapping calleeName to a Boolean
	     * @param {ASTNode} node CallExpression node
	     * @param {string} calleeName Capitalized callee name from a CallExpression
	     * @returns {Boolean} Returns true if the callee may be capitalized
	     */
	    function isCapAllowed(allowedMap, node, calleeName) {
	        if (allowedMap[calleeName] || allowedMap[context.getSource(node.callee)]) {
	            return true;
	        }

	        if (calleeName === "UTC" && node.callee.type === "MemberExpression") {
	            // allow if callee is Date.UTC
	            return node.callee.object.type === "Identifier" &&
	                node.callee.object.name === "Date";
	        }
	        return false;
	    }

	    /**
	     * Reports the given message for the given node. The location will be the start of the property or the callee.
	     * @param {ASTNode} node CallExpression or NewExpression node.
	     * @param {string} message The message to report.
	     * @returns {void}
	     */
	    function report(node, message) {
	        var callee = node.callee;

	        if (callee.type === "MemberExpression") {
	            callee = callee.property;
	        }

	        context.report(node, callee.loc.start, message);
	    }

	    //--------------------------------------------------------------------------
	    // Public
	    //--------------------------------------------------------------------------

	    if (config.newIsCap) {
	        listeners.NewExpression = function(node) {

	            var constructorName = extractNameFromExpression(node);
	            if (constructorName) {
	                var capitalization = getCap(constructorName);
	                var isAllowed = capitalization !== "lower" || isCapAllowed(newIsCapExceptions, node, constructorName);
	                if (!isAllowed) {
	                    report(node, "A constructor name should not start with a lowercase letter.");
	                }
	            }
	        };
	    }

	    if (config.capIsNew) {
	        listeners.CallExpression = function(node) {

	            var calleeName = extractNameFromExpression(node);
	            if (calleeName) {
	                var capitalization = getCap(calleeName);
	                var isAllowed = capitalization !== "upper" || isCapAllowed(capIsNewExceptions, node, calleeName);
	                if (!isAllowed) {
	                    report(node, "A function with a name starting with an uppercase letter should only be used as a constructor.");
	                }
	            }
	        };
	    }

	    return listeners;
	};

	module.exports.schema = [
	    {
	        "type": "object",
	        "properties": {
	            "newIsCap": {
	                "type": "boolean"
	            },
	            "capIsNew": {
	                "type": "boolean"
	            },
	            "newIsCapExceptions": {
	                "type": "array",
	                "items": {
	                    "type": "string"
	                }
	            },
	            "capIsNewExceptions": {
	                "type": "array",
	                "items": {
	                    "type": "string"
	                }
	            }
	        },
	        "additionalProperties": false
	    }
	];


/***/ },
/* 312 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag when using constructor without parentheses
	 * @author Ilya Volodin
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {

	        "NewExpression": function(node) {
	            var tokens = context.getTokens(node);
	            var prenticesTokens = tokens.filter(function(token) {
	                return token.value === "(" || token.value === ")";
	            });
	            if (prenticesTokens.length < 2) {
	                context.report(node, "Missing '()' invoking a constructor");
	            }
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 313 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to check empty newline after "var" statement
	 * @author Gopal Venkatesan
	 * @copyright 2015 Gopal Venkatesan. All rights reserved.
	 * @copyright 2015 Casey Visco. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var ALWAYS_MESSAGE = "Expected blank line after variable declarations.",
	        NEVER_MESSAGE = "Unexpected blank line after variable declarations.";

	    // Default `mode` to "always". This means that invalid options will also
	    // be treated as "always" and the only special case is "never"
	    var mode = context.options[0] === "never" ? "never" : "always";

	    // Cache line numbers of comments for faster lookup
	    var comments = context.getAllComments().map(function(token) {
	        return token.loc.start.line;
	    });


	    //--------------------------------------------------------------------------
	    // Helpers
	    //--------------------------------------------------------------------------

	    /**
	     * Determine if provided keyword is a variable declaration
	     * @private
	     * @param {string} keyword - keyword to test
	     * @returns {boolean} True if `keyword` is a type of var
	     */
	    function isVar(keyword) {
	        return keyword === "var" || keyword === "let" || keyword === "const";
	    }

	    /**
	     * Determine if provided keyword is a variant of for specifiers
	     * @private
	     * @param {string} keyword - keyword to test
	     * @returns {boolean} True if `keyword` is a variant of for specifier
	     */
	    function isForTypeSpecifier(keyword) {
	        return keyword === "ForStatement" || keyword === "ForInStatement" || keyword === "ForOfStatement";
	    }

	    /**
	     * Determine if provided keyword is an export specifiers
	     * @private
	     * @param {string} nodeType - nodeType to test
	     * @returns {boolean} True if `nodeType` is an export specifier
	     */
	    function isExportSpecifier(nodeType) {
	        return nodeType === "ExportNamedDeclaration" || nodeType === "ExportSpecifier" ||
	            nodeType === "ExportDefaultDeclaration" || nodeType === "ExportAllDeclaration";
	    }

	    /**
	     * Checks that a blank line exists after a variable declaration when mode is
	     * set to "always", or checks that there is no blank line when mode is set
	     * to "never"
	     * @private
	     * @param {ASTNode} node - `VariableDeclaration` node to test
	     * @returns {void}
	     */
	    function checkForBlankLine(node) {
	        var lastToken = context.getLastToken(node),
	            nextToken = context.getTokenAfter(node),
	            nextLineNum = lastToken.loc.end.line + 1,
	            noNextLineToken,
	            hasNextLineComment;

	        // Ignore if there is no following statement
	        if (!nextToken) {
	            return;
	        }

	        // Ignore if parent of node is a for variant
	        if (isForTypeSpecifier(node.parent.type)) {
	            return;
	        }

	        // Ignore if parent of node is an export specifier
	        if (isExportSpecifier(node.parent.type)) {
	            return;
	        }

	        // Some coding styles use multiple `var` statements, so do nothing if
	        // the next token is a `var` statement.
	        if (nextToken.type === "Keyword" && isVar(nextToken.value)) {
	            return;
	        }

	        // Next statement is not a `var`...
	        noNextLineToken = nextToken.loc.start.line > nextLineNum;
	        hasNextLineComment = comments.indexOf(nextLineNum) >= 0;

	        if (mode === "never" && noNextLineToken && !hasNextLineComment) {
	            context.report(node, NEVER_MESSAGE, { identifier: node.name });
	        }

	        if (mode === "always" && (!noNextLineToken || hasNextLineComment)) {
	            context.report(node, ALWAYS_MESSAGE, { identifier: node.name });
	        }
	    }

	    //--------------------------------------------------------------------------
	    // Public
	    //--------------------------------------------------------------------------

	    return {
	        "VariableDeclaration": checkForBlankLine
	    };

	};

	module.exports.schema = [
	    {
	        "enum": ["never", "always"]
	    }
	];


/***/ },
/* 314 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Disallow construction of dense arrays using the Array constructor
	 * @author Matt DuVall <http://www.mattduvall.com/>
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    function check(node) {
	        if (
	            node.arguments.length !== 1 &&
	            node.callee.type === "Identifier" &&
	            node.callee.name === "Array"
	        ) {
	            context.report(node, "The array literal notation [] is preferrable.");
	        }
	    }

	    return {
	        "CallExpression": check,
	        "NewExpression": check
	    };

	};

	module.exports.schema = [];


/***/ },
/* 315 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag use of continue statement
	 * @author Borislav Zhivkov
	 * @copyright 2015 Borislav Zhivkov. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {
	        "ContinueStatement": function(node) {
	            context.report(node, "Unexpected use of continue statement");
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 316 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Enforces or disallows inline comments.
	 * @author Greg Cochard
	 * @copyright 2014 Greg Cochard. All rights reserved.
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    /**
	     * Will check that comments are not on lines starting with or ending with code
	     * @param {ASTNode} node The comment node to check
	     * @private
	     * @returns {void}
	     */
	    function testCodeAroundComment(node) {

	        // Get the whole line and cut it off at the start of the comment
	        var startLine = String(context.getSourceLines()[node.loc.start.line - 1]);
	        var endLine = String(context.getSourceLines()[node.loc.end.line - 1]);

	        var preamble = startLine.slice(0, node.loc.start.column).trim();

	        // Also check after the comment
	        var postamble = endLine.slice(node.loc.end.column).trim();

	        // Should be empty if there was only whitespace around the comment
	        if (preamble || postamble) {
	            context.report(node, "Unexpected comment inline with code.");
	        }
	    }

	    //--------------------------------------------------------------------------
	    // Public
	    //--------------------------------------------------------------------------

	    return {

	        "LineComment": testCodeAroundComment,
	        "BlockComment": testCodeAroundComment

	    };
	};

	module.exports.schema = [];


/***/ },
/* 317 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to disallow if as the only statmenet in an else block
	 * @author Brandon Mills
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {
	        "IfStatement": function(node) {
	            var ancestors = context.getAncestors(),
	                parent = ancestors.pop(),
	                grandparent = ancestors.pop();

	            if (parent && parent.type === "BlockStatement" &&
	                    parent.body.length === 1 && grandparent &&
	                    grandparent.type === "IfStatement" &&
	                    parent === grandparent.alternate) {
	                context.report(node, "Unexpected if as the only statement in an else block.");
	            }
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 318 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Disallow mixed spaces and tabs for indentation
	 * @author Jary Niebur
	 * @copyright 2014 Nicholas C. Zakas. All rights reserved.
	 * @copyright 2014 Jary Niebur. All rights reserved.
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var smartTabs;

	    switch (context.options[0]) {
	        case true: // Support old syntax, maybe add deprecation warning here
	        case "smart-tabs":
	            smartTabs = true;
	            break;
	        default:
	            smartTabs = false;
	    }

	    var COMMENT_START = /^\s*\/\*/,
	        MAYBE_COMMENT = /^\s*\*/;

	    //--------------------------------------------------------------------------
	    // Public
	    //--------------------------------------------------------------------------

	    return {

	        "Program": function(node) {
	            /*
	             * At least one space followed by a tab
	             * or the reverse before non-tab/-space
	             * characters begin.
	             */
	            var regex = /^(?=[\t ]*(\t | \t))/,
	                match,
	                lines = context.getSourceLines();

	            if (smartTabs) {
	                /*
	                 * At least one space followed by a tab
	                 * before non-tab/-space characters begin.
	                 */
	                regex = /^(?=[\t ]* \t)/;
	            }

	            lines.forEach(function(line, i) {
	                match = regex.exec(line);

	                if (match) {

	                    if (!MAYBE_COMMENT.test(line) && !COMMENT_START.test(lines[i - 1])) {
	                        context.report(node, { line: i + 1, column: match.index + 1 }, "Mixed spaces and tabs.");
	                    }

	                }
	            });
	        }

	    };

	};

	module.exports.schema = [
	    {
	        "enum": ["smart-tabs", true, false]
	    }
	];


/***/ },
/* 319 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Disallows multiple blank lines.
	 * implementation adapted from the no-trailing-spaces rule.
	 * @author Greg Cochard
	 * @copyright 2014 Greg Cochard. All rights reserved.
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    // Use options.max or 2 as default
	    var numLines = 2;

	    // store lines that appear empty but really aren't
	    var notEmpty = [];

	    if (context.options.length) {
	        numLines = context.options[0].max;
	    }

	    //--------------------------------------------------------------------------
	    // Public
	    //--------------------------------------------------------------------------

	    return {

	        "TemplateLiteral": function(node) {
	            var start = node.loc.start.line;
	            var end = node.loc.end.line;
	            while (start <= end) {
	                notEmpty.push(start);
	                start++;
	            }
	        },

	        "Program:exit": function checkBlankLines(node) {
	            var lines = context.getSourceLines(),
	                currentLocation = -1,
	                lastLocation,
	                blankCounter = 0,
	                location,
	                trimmedLines = lines.map(function(str) {
	                    return str.trim();
	                });

	            // add the notEmpty lines in there with a placeholder
	            notEmpty.forEach(function(x, i) {
	                trimmedLines[i] = x;
	            });

	            // swallow the final newline, as some editors add it automatically
	            // and we don't want it to cause an issue
	            if (trimmedLines[trimmedLines.length - 1] === "") {
	                trimmedLines = trimmedLines.slice(0, -1);
	            }

	            // Aggregate and count blank lines
	            lastLocation = currentLocation;
	            currentLocation = trimmedLines.indexOf("", currentLocation + 1);
	            while (currentLocation !== -1) {
	                lastLocation = currentLocation;
	                currentLocation = trimmedLines.indexOf("", currentLocation + 1);
	                if (lastLocation === currentLocation - 1) {
	                    blankCounter++;
	                } else {
	                    if (blankCounter >= numLines) {
	                        location = {
	                            line: lastLocation + 1,
	                            column: lines[lastLocation].length
	                        };
	                        context.report(node, location, "Multiple blank lines not allowed.");
	                    }

	                    // Finally, reset the blank counter
	                    blankCounter = 0;
	                }
	            }
	        }
	    };

	};

	module.exports.schema = [
	    {
	        "type": "object",
	        "properties": {
	            "max": {
	                "type": "integer"
	            }
	        },
	        "required": ["max"],
	        "additionalProperties": false
	    }
	];


/***/ },
/* 320 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag nested ternary expressions
	 * @author Ian Christian Myers
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {
	        "ConditionalExpression": function(node) {
	            if (node.alternate.type === "ConditionalExpression" ||
	                    node.consequent.type === "ConditionalExpression") {
	                context.report(node, "Do not nest ternary expressions");
	            }
	        }
	    };
	};

	module.exports.schema = [];


/***/ },
/* 321 */
/***/ function(module, exports) {

	/**
	 * @fileoverview A rule to disallow calls to the Object constructor
	 * @author Matt DuVall <http://www.mattduvall.com/>
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {

	        "NewExpression": function(node) {
	            if (node.callee.name === "Object") {
	                context.report(node, "The object literal notation {} is preferrable.");
	            }
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 322 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to check that spaced function application
	 * @author Matt DuVall <http://www.mattduvall.com>
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    function detectOpenSpaces(node) {
	        var lastCalleeToken = context.getLastToken(node.callee);
	        var tokens = context.getTokens(node);
	        var i = tokens.indexOf(lastCalleeToken), l = tokens.length;
	        while (i < l && tokens[i].value !== "(") {
	            ++i;
	        }
	        if (i >= l) {
	            return;
	        }
	        // look for a space between the callee and the open paren
	        if (tokens[i - 1].range[1] !== tokens[i].range[0]) {
	            context.report(node, lastCalleeToken.loc.start, "Unexpected space between function name and paren.");
	        }
	    }

	    return {
	        "CallExpression": detectOpenSpaces,
	        "NewExpression": detectOpenSpaces
	    };

	};

	module.exports.schema = [];


/***/ },
/* 323 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag use of ternary operators.
	 * @author Ian Christian Myers
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {

	        "ConditionalExpression": function(node) {
	            context.report(node, "Ternary operator used.");
	        }

	    };

	};

	module.exports.schema = [];


/***/ },
/* 324 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Disallow trailing spaces at the end of lines.
	 * @author Nodeca Team <https://github.com/nodeca>
	 * @copyright 2015 Greg Cochard
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var BLANK_CLASS = "[ \t\u00a0\u2000-\u200b\u2028\u2029\u3000]",
	        SKIP_BLANK = "^" + BLANK_CLASS + "*$",
	        NONBLANK = BLANK_CLASS + "$";

	    var options = context.options[0] || {},
	        skipBlankLines = options.skipBlankLines || false;


	    //--------------------------------------------------------------------------
	    // Public
	    //--------------------------------------------------------------------------

	    return {

	        "Program": function checkTrailingSpaces(node) {

	            // Let's hack. Since Espree does not return whitespace nodes,
	            // fetch the source code and do matching via regexps.

	            var src = context.getSource(),
	                re = new RegExp(NONBLANK),
	                skipMatch = new RegExp(SKIP_BLANK),
	                matches, lines = src.split(/\r?\n/), location;

	            for (var i = 0, ii = lines.length; i < ii; i++) {

	                matches = re.exec(lines[i]);
	                if (matches) {

	                    // If the line has only whitespace, and skipBlankLines
	                    // is true, don't report it
	                    if (skipBlankLines && skipMatch.test(lines[i])) {
	                        continue;
	                    }
	                    location = {
	                        line: i + 1,
	                        column: lines[i].length - matches[0].length + 1
	                    };

	                    // Passing node is a bit dirty, because message data will contain
	                    // big text in `source`. But... who cares :) ?
	                    // One more kludge will not make worse the bloody wizardry of this plugin.
	                    context.report(node, location, "Trailing spaces not allowed.");
	                }
	            }
	        }

	    };
	};

	module.exports.schema = [
	    {
	        "type": "object",
	        "properties": {
	            "skipBlankLines": {
	                "type": "boolean"
	            }
	        },
	        "additionalProperties": false
	    }
	];


/***/ },
/* 325 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag trailing underscores in variable declarations.
	 * @author Matt DuVall <http://www.mattduvall.com>
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    //-------------------------------------------------------------------------
	    // Helpers
	    //-------------------------------------------------------------------------

	    function hasTrailingUnderscore(identifier) {
	        var len = identifier.length;

	        return identifier !== "_" && (identifier[0] === "_" || identifier[len - 1] === "_");
	    }

	    function isSpecialCaseIdentifierForMemberExpression(identifier) {
	        return identifier === "__proto__";
	    }

	    function isSpecialCaseIdentifierInVariableExpression(identifier) {
	        // Checks for the underscore library usage here
	        return identifier === "_";
	    }

	    function checkForTrailingUnderscoreInFunctionDeclaration(node) {
	        if (node.id) {
	            var identifier = node.id.name;

	            if (typeof identifier !== "undefined" && hasTrailingUnderscore(identifier)) {
	                context.report(node, "Unexpected dangling \"_\" in \"" + identifier + "\".");
	            }
	        }
	    }

	    function checkForTrailingUnderscoreInVariableExpression(node) {
	        var identifier = node.id.name;

	        if (typeof identifier !== "undefined" && hasTrailingUnderscore(identifier) &&
	            !isSpecialCaseIdentifierInVariableExpression(identifier)) {
	            context.report(node, "Unexpected dangling \"_\" in \"" + identifier + "\".");
	        }
	    }

	    function checkForTrailingUnderscoreInMemberExpression(node) {
	        var identifier = node.property.name;

	        if (typeof identifier !== "undefined" && hasTrailingUnderscore(identifier) &&
	            !isSpecialCaseIdentifierForMemberExpression(identifier)) {
	            context.report(node, "Unexpected dangling \"_\" in \"" + identifier + "\".");
	        }
	    }

	    //--------------------------------------------------------------------------
	    // Public API
	    //--------------------------------------------------------------------------

	    return {
	        "FunctionDeclaration": checkForTrailingUnderscoreInFunctionDeclaration,
	        "VariableDeclarator": checkForTrailingUnderscoreInVariableExpression,
	        "MemberExpression": checkForTrailingUnderscoreInMemberExpression
	    };

	};

	module.exports.schema = [];


/***/ },
/* 326 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag no-unneeded-ternary
	 * @author Gyandeep Singh
	 * @copyright 2015 Gyandeep Singh. All rights reserved.
	 * @copyright 2015 Michael Ficarra. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    /**
	     * Reports an AST node as a rule violation.
	     * @param {ASTNode} mainNode The node to report.
	     * @param {object} culpritNode - The token which has a problem
	     * @returns {void}
	     * @private
	     */
	    function report(mainNode, culpritNode) {
	        context.report(mainNode, culpritNode.loc.start, "Unnecessary use of boolean literals in conditional expression");
	    }

	    /**
	     * Test if the node is a boolean literal
	     * @param {ASTNode} node - The node to report.
	     * @returns {boolean} True if the its a boolean literal
	     * @private
	     */
	    function isBooleanLiteral(node) {
	        return node.type === "Literal" && typeof node.value === "boolean";
	    }

	    return {

	        "ConditionalExpression": function(node) {

	            if (isBooleanLiteral(node.alternate) && isBooleanLiteral(node.consequent)) {
	                report(node, node.consequent);
	            }
	        }
	    };
	};

	module.exports.schema = [];


/***/ },
/* 327 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Disallows or enforces spaces inside of object literals.
	 * @author Jamund Ferguson
	 * @copyright 2014 Brandyn Bennett. All rights reserved.
	 * @copyright 2014 Michael Ficarra. No rights reserved.
	 * @copyright 2014 Vignesh Anand. All rights reserved.
	 * @copyright 2015 Jamund Ferguson. All rights reserved.
	 */
	"use strict";

	var astUtils = __webpack_require__(177);

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {
	    var spaced = context.options[0] === "always";

	    /**
	     * Determines whether an option is set, relative to the spacing option.
	     * If spaced is "always", then check whether option is set to false.
	     * If spaced is "never", then check whether option is set to true.
	     * @param {Object} option - The option to exclude.
	     * @returns {boolean} Whether or not the property is excluded.
	     */
	    function isOptionSet(option) {
	        return context.options[1] != null ? context.options[1][option] === !spaced : false;
	    }

	    var options = {
	        spaced: spaced,
	        arraysInObjectsException: isOptionSet("arraysInObjects"),
	        objectsInObjectsException: isOptionSet("objectsInObjects")
	    };

	    //--------------------------------------------------------------------------
	    // Helpers
	    //--------------------------------------------------------------------------

	    /**
	    * Reports that there shouldn't be a space after the first token
	    * @param {ASTNode} node - The node to report in the event of an error.
	    * @param {Token} token - The token to use for the report.
	    * @returns {void}
	    */
	    function reportNoBeginningSpace(node, token) {
	        context.report(node, token.loc.start,
	            "There should be no space after '" + token.value + "'");
	    }

	    /**
	    * Reports that there shouldn't be a space before the last token
	    * @param {ASTNode} node - The node to report in the event of an error.
	    * @param {Token} token - The token to use for the report.
	    * @returns {void}
	    */
	    function reportNoEndingSpace(node, token) {
	        context.report(node, token.loc.start,
	            "There should be no space before '" + token.value + "'");
	    }

	    /**
	    * Reports that there should be a space after the first token
	    * @param {ASTNode} node - The node to report in the event of an error.
	    * @param {Token} token - The token to use for the report.
	    * @returns {void}
	    */
	    function reportRequiredBeginningSpace(node, token) {
	        context.report(node, token.loc.start,
	            "A space is required after '" + token.value + "'");
	    }

	    /**
	    * Reports that there should be a space before the last token
	    * @param {ASTNode} node - The node to report in the event of an error.
	    * @param {Token} token - The token to use for the report.
	    * @returns {void}
	    */
	    function reportRequiredEndingSpace(node, token) {
	        context.report(node, token.loc.start,
	                    "A space is required before '" + token.value + "'");
	    }

	    /**
	     * Determines if spacing in curly braces is valid.
	     * @param {ASTNode} node The AST node to check.
	     * @param {Token} first The first token to check (should be the opening brace)
	     * @param {Token} second The second token to check (should be first after the opening brace)
	     * @param {Token} penultimate The penultimate token to check (should be last before closing brace)
	     * @param {Token} last The last token to check (should be closing brace)
	     * @returns {void}
	     */
	    function validateBraceSpacing(node, first, second, penultimate, last) {
	        var closingCurlyBraceMustBeSpaced =
	            options.arraysInObjectsException && penultimate.value === "]" ||
	            options.objectsInObjectsException && penultimate.value === "}"
	                ? !options.spaced : options.spaced,
	            firstSpaced, lastSpaced;

	        if (astUtils.isTokenOnSameLine(first, second)) {
	            firstSpaced = astUtils.isTokenSpaced(first, second);
	            if (options.spaced && !firstSpaced) {
	                reportRequiredBeginningSpace(node, first);
	            }
	            if (!options.spaced && firstSpaced) {
	                reportNoBeginningSpace(node, first);
	            }
	        }

	        if (astUtils.isTokenOnSameLine(penultimate, last)) {
	            lastSpaced = astUtils.isTokenSpaced(penultimate, last);
	            if (closingCurlyBraceMustBeSpaced && !lastSpaced) {
	                reportRequiredEndingSpace(node, last);
	            }
	            if (!closingCurlyBraceMustBeSpaced && lastSpaced) {
	                reportNoEndingSpace(node, last);
	            }
	        }
	    }

	    //--------------------------------------------------------------------------
	    // Public
	    //--------------------------------------------------------------------------

	    return {

	        // var {x} = y;
	        ObjectPattern: function(node) {
	            var firstSpecifier = node.properties[0],
	                lastSpecifier = node.properties[node.properties.length - 1];

	            var first = context.getTokenBefore(firstSpecifier),
	                second = context.getFirstToken(firstSpecifier),
	                penultimate = context.getLastToken(lastSpecifier),
	                last = context.getTokenAfter(lastSpecifier);

	            // support trailing commas
	            if (last.value === ",") {
	                penultimate = last;
	                last = context.getTokenAfter(last);
	            }

	            validateBraceSpacing(node, first, second, penultimate, last);
	        },

	        // import {y} from 'x';
	        ImportDeclaration: function(node) {

	            var firstSpecifier = node.specifiers[0],
	                lastSpecifier = node.specifiers[node.specifiers.length - 1],
	                first, second, penultimate, last;

	            // import { x, y } from 'foo'
	            if (firstSpecifier && lastSpecifier && firstSpecifier.type === "ImportSpecifier" && lastSpecifier.type === "ImportSpecifier") {
	                first = context.getTokenBefore(firstSpecifier);
	                second = context.getFirstToken(firstSpecifier);
	                penultimate = context.getLastToken(lastSpecifier);
	                last = context.getTokenAfter(lastSpecifier);
	                validateBraceSpacing(node, first, second, penultimate, last);
	                return;
	            }

	            // import a, { b, c } from 'foo'
	            if (lastSpecifier && lastSpecifier.type === "ImportSpecifier") {
	                first = context.getTokenBefore(lastSpecifier);
	                second = context.getFirstToken(lastSpecifier);
	                penultimate = context.getLastToken(lastSpecifier);
	                last = context.getTokenAfter(lastSpecifier);
	                validateBraceSpacing(node, first, second, penultimate, last);
	            }

	        },

	        // export {name} from 'yo';
	        ExportNamedDeclaration: function(node) {
	            if (!node.specifiers.length) {
	                return;
	            }

	            var firstSpecifier = node.specifiers[0],
	                lastSpecifier = node.specifiers[node.specifiers.length - 1],
	                first = context.getTokenBefore(firstSpecifier),
	                second = context.getFirstToken(firstSpecifier),
	                penultimate = context.getLastToken(lastSpecifier),
	                last = context.getTokenAfter(lastSpecifier);

	            validateBraceSpacing(node, first, second, penultimate, last);

	        },

	        // var y = {x: 'y'}
	        ObjectExpression: function(node) {
	            if (node.properties.length === 0) {
	                return;
	            }

	            var first = context.getFirstToken(node),
	                second = context.getFirstToken(node, 1),
	                penultimate = context.getLastToken(node, 1),
	                last = context.getLastToken(node);

	            validateBraceSpacing(node, first, second, penultimate, last);
	        }

	    };

	};

	module.exports.schema = [
	    {
	        "enum": ["always", "never"]
	    },
	    {
	        "type": "object",
	        "properties": {
	            "arraysInObjects": {
	                "type": "boolean"
	            },
	            "objectsInObjects": {
	                "type": "boolean"
	            }
	        },
	        "additionalProperties": false
	    }
	];


/***/ },
/* 328 */
/***/ function(module, exports) {

	/**
	 * @fileoverview A rule to control the use of single variable declarations.
	 * @author Ian Christian Myers
	 * @copyright 2015 Ian VanSchooten. All rights reserved.
	 * @copyright 2015 Joey Baker. All rights reserved.
	 * @copyright 2015 Danny Fritz. All rights reserved.
	 * @copyright 2013 Ian Christian Myers. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var MODE_ALWAYS = "always",
	        MODE_NEVER = "never";

	    var mode = context.options[0];

	    var options = {
	    };

	    if (typeof mode === "string") { // simple options configuration with just a string
	        options.var = { uninitialized: mode, initialized: mode};
	        options.let = { uninitialized: mode, initialized: mode};
	        options.const = { uninitialized: mode, initialized: mode};
	    } else if (typeof mode === "object") { // options configuration is an object
	        if (mode.hasOwnProperty("var") && typeof mode.var === "string") {
	            options.var = { uninitialized: mode.var, initialized: mode.var};
	        }
	        if (mode.hasOwnProperty("let") && typeof mode.let === "string") {
	            options.let = { uninitialized: mode.let, initialized: mode.let};
	        }
	        if (mode.hasOwnProperty("const") && typeof mode.const === "string") {
	            options.const = { uninitialized: mode.const, initialized: mode.const};
	        }
	        if (mode.hasOwnProperty("uninitialized")) {
	            if (!options.var) {
	                options.var = {};
	            }
	            if (!options.let) {
	                options.let = {};
	            }
	            if (!options.const) {
	                options.const = {};
	            }
	            options.var.uninitialized = mode.uninitialized;
	            options.let.uninitialized = mode.uninitialized;
	            options.const.uninitialized = mode.uninitialized;
	        }
	        if (mode.hasOwnProperty("initialized")) {
	            if (!options.var) {
	                options.var = {};
	            }
	            if (!options.let) {
	                options.let = {};
	            }
	            if (!options.const) {
	                options.const = {};
	            }
	            options.var.initialized = mode.initialized;
	            options.let.initialized = mode.initialized;
	            options.const.initialized = mode.initialized;
	        }
	    }

	    //--------------------------------------------------------------------------
	    // Helpers
	    //--------------------------------------------------------------------------

	    var functionStack = [];
	    var blockStack = [];

	    /**
	     * Increments the blockStack counter.
	     * @returns {void}
	     * @private
	     */
	    function startBlock() {
	        blockStack.push({
	            let: {initialized: false, uninitialized: false},
	            const: {initialized: false, uninitialized: false}
	        });
	    }

	    /**
	     * Increments the functionStack counter.
	     * @returns {void}
	     * @private
	     */
	    function startFunction() {
	        functionStack.push({initialized: false, uninitialized: false});
	        startBlock();
	    }

	    /**
	     * Decrements the blockStack counter.
	     * @returns {void}
	     * @private
	     */
	    function endBlock() {
	        blockStack.pop();
	    }

	    /**
	     * Decrements the functionStack counter.
	     * @returns {void}
	     * @private
	     */
	    function endFunction() {
	        functionStack.pop();
	        endBlock();
	    }

	    /**
	     * Records whether initialized or uninitialized variables are defined in current scope.
	     * @param {string} statementType node.kind, one of: "var", "let", or "const"
	     * @param {ASTNode[]} declarations List of declarations
	     * @param {Object} currentScope The scope being investigated
	     * @returns {void}
	     * @private
	     */
	    function recordTypes(statementType, declarations, currentScope) {
	        for (var i = 0; i < declarations.length; i++) {
	            if (declarations[i].init === null) {
	                if (options[statementType] && options[statementType].uninitialized === MODE_ALWAYS) {
	                    currentScope.uninitialized = true;
	                }
	            } else {
	                if (options[statementType] && options[statementType].initialized === MODE_ALWAYS) {
	                    currentScope.initialized = true;
	                }
	            }
	        }
	    }

	    /**
	     * Determines the current scope (function or block)
	     * @param  {string} statementType node.kind, one of: "var", "let", or "const"
	     * @returns {Object} The scope associated with statementType
	     */
	    function getCurrentScope(statementType) {
	        var currentScope;
	        if (statementType === "var") {
	            currentScope = functionStack[functionStack.length - 1];
	        } else if (statementType === "let") {
	            currentScope = blockStack[blockStack.length - 1].let;
	        } else if (statementType === "const") {
	            currentScope = blockStack[blockStack.length - 1].const;
	        }
	        return currentScope;
	    }

	    /**
	     * Counts the number of initialized and uninitialized declarations in a list of declarations
	     * @param {ASTNode[]} declarations List of declarations
	     * @returns {Object} Counts of 'uninitialized' and 'initialized' declarations
	     * @private
	     */
	    function countDeclarations(declarations) {
	        var counts = { uninitialized: 0, initialized: 0 };
	        for (var i = 0; i < declarations.length; i++) {
	            if (declarations[i].init === null) {
	                counts.uninitialized++;
	            } else {
	                counts.initialized++;
	            }
	        }
	        return counts;
	    }

	    /**
	     * Determines if there is more than one var statement in the current scope.
	     * @param {string} statementType node.kind, one of: "var", "let", or "const"
	     * @param {ASTNode[]} declarations List of declarations
	     * @returns {boolean} Returns true if it is the first var declaration, false if not.
	     * @private
	     */
	    function hasOnlyOneStatement(statementType, declarations) {

	        var declarationCounts = countDeclarations(declarations);
	        var currentOptions = options[statementType] || {};
	        var currentScope = getCurrentScope(statementType);

	        if (currentOptions.uninitialized === MODE_ALWAYS && currentOptions.initialized === MODE_ALWAYS) {
	            if (currentScope.uninitialized || currentScope.initialized) {
	                return false;
	            }
	        }

	        if (declarationCounts.uninitialized > 0) {
	            if (currentOptions.uninitialized === MODE_ALWAYS && currentScope.uninitialized) {
	                return false;
	            }
	        }
	        if (declarationCounts.initialized > 0) {
	            if (currentOptions.initialized === MODE_ALWAYS && currentScope.initialized) {
	                return false;
	            }
	        }
	        recordTypes(statementType, declarations, currentScope);
	        return true;
	    }


	    //--------------------------------------------------------------------------
	    // Public API
	    //--------------------------------------------------------------------------

	    return {
	        "Program": startFunction,
	        "FunctionDeclaration": startFunction,
	        "FunctionExpression": startFunction,
	        "ArrowFunctionExpression": startFunction,
	        "BlockStatement": startBlock,
	        "ForStatement": startBlock,
	        "ForInStatement": startBlock,
	        "ForOfStatement": startBlock,
	        "SwitchStatement": startBlock,

	        "VariableDeclaration": function(node) {
	            var parent = node.parent,
	                type, declarations, declarationCounts;

	            type = node.kind;
	            if (!options[type]) {
	                return;
	            }

	            declarations = node.declarations;
	            declarationCounts = countDeclarations(declarations);

	            // always
	            if (!hasOnlyOneStatement(type, declarations)) {
	                if (options[type].initialized === MODE_ALWAYS && options[type].uninitialized === MODE_ALWAYS) {
	                    context.report(node, "Combine this with the previous '" + type + "' statement.");
	                } else {
	                    if (options[type].initialized === MODE_ALWAYS) {
	                        context.report(node, "Combine this with the previous '" + type + "' statement with initialized variables.");
	                    }
	                    if (options[type].uninitialized === MODE_ALWAYS) {
	                        context.report(node, "Combine this with the previous '" + type + "' statement with uninitialized variables.");
	                    }
	                }
	            }
	            // never
	            if (parent.type !== "ForStatement" || parent.init !== node) {
	                var totalDeclarations = declarationCounts.uninitialized + declarationCounts.initialized;
	                if (totalDeclarations > 1) {
	                    // both initialized and uninitialized
	                    if (options[type].initialized === MODE_NEVER && options[type].uninitialized === MODE_NEVER) {
	                        context.report(node, "Split '" + type + "' declarations into multiple statements.");
	                    // initialized
	                    } else if (options[type].initialized === MODE_NEVER && declarationCounts.initialized > 0) {
	                        context.report(node, "Split initialized '" + type + "' declarations into multiple statements.");
	                    // uninitialized
	                    } else if (options[type].uninitialized === MODE_NEVER && declarationCounts.uninitialized > 0) {
	                        context.report(node, "Split uninitialized '" + type + "' declarations into multiple statements.");
	                    }
	                }
	            }
	        },

	        "ForStatement:exit": endBlock,
	        "ForOfStatement:exit": endBlock,
	        "ForInStatement:exit": endBlock,
	        "SwitchStatement:exit": endBlock,
	        "BlockStatement:exit": endBlock,
	        "Program:exit": endFunction,
	        "FunctionDeclaration:exit": endFunction,
	        "FunctionExpression:exit": endFunction,
	        "ArrowFunctionExpression:exit": endFunction
	    };

	};

	module.exports.schema = [
	    {
	        "oneOf": [
	            {
	                "enum": ["always", "never"]
	            },
	            {
	                "type": "object",
	                "properties": {
	                    "var": {
	                        "enum": ["always", "never"]
	                    },
	                    "let": {
	                        "enum": ["always", "never"]
	                    },
	                    "const": {
	                        "enum": ["always", "never"]
	                    }
	                },
	                "additionalProperties": false
	            },
	            {
	                "type": "object",
	                "properties": {
	                    "initialized": {
	                        "enum": ["always", "never"]
	                    },
	                    "uninitialized": {
	                        "enum": ["always", "never"]
	                    }
	                },
	                "additionalProperties": false
	            }
	        ]
	    }
	];


/***/ },
/* 329 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to replace assignment expressions with operator assignment
	 * @author Brandon Mills
	 * @copyright 2014 Brandon Mills. All rights reserved.
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------

	/**
	 * Checks whether an operator is commutative and has an operator assignment
	 * shorthand form.
	 * @param   {string}  operator Operator to check.
	 * @returns {boolean}          True if the operator is commutative and has a
	 *     shorthand form.
	 */
	function isCommutativeOperatorWithShorthand(operator) {
	    return ["*", "&", "^", "|"].indexOf(operator) >= 0;
	}

	/**
	 * Checks whether an operator is not commuatative and has an operator assignment
	 * shorthand form.
	 * @param   {string}  operator Operator to check.
	 * @returns {boolean}          True if the operator is not commuatative and has
	 *     a shorthand form.
	 */
	function isNonCommutativeOperatorWithShorthand(operator) {
	    return ["+", "-", "/", "%", "<<", ">>", ">>>"].indexOf(operator) >= 0;
	}

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	/**
	 * Checks whether two expressions reference the same value. For example:
	 *     a = a
	 *     a.b = a.b
	 *     a[0] = a[0]
	 *     a['b'] = a['b']
	 * @param   {ASTNode} a Left side of the comparison.
	 * @param   {ASTNode} b Right side of the comparison.
	 * @returns {boolean}   True if both sides match and reference the same value.
	 */
	function same(a, b) {
	    if (a.type !== b.type) {
	        return false;
	    }

	    switch (a.type) {
	        case "Identifier":
	            return a.name === b.name;
	        case "Literal":
	            return a.value === b.value;
	        case "MemberExpression":
	            // x[0] = x[0]
	            // x[y] = x[y]
	            // x.y = x.y
	            return same(a.object, b.object) && same(a.property, b.property);
	        default:
	            return false;
	    }
	}

	module.exports = function(context) {

	    /**
	     * Ensures that an assignment uses the shorthand form where possible.
	     * @param   {ASTNode} node An AssignmentExpression node.
	     * @returns {void}
	     */
	    function verify(node) {
	        var expr, left, operator;

	        if (node.operator !== "=" || node.right.type !== "BinaryExpression") {
	            return;
	        }

	        left = node.left;
	        expr = node.right;
	        operator = expr.operator;

	        if (isCommutativeOperatorWithShorthand(operator)) {
	            if (same(left, expr.left) || same(left, expr.right)) {
	                context.report(node, "Assignment can be replaced with operator assignment.");
	            }
	        } else if (isNonCommutativeOperatorWithShorthand(operator)) {
	            if (same(left, expr.left)) {
	                context.report(node, "Assignment can be replaced with operator assignment.");
	            }
	        }
	    }

	    /**
	     * Warns if an assignment expression uses operator assignment shorthand.
	     * @param   {ASTNode} node An AssignmentExpression node.
	     * @returns {void}
	     */
	    function prohibit(node) {
	        if (node.operator !== "=") {
	            context.report(node, "Unexpected operator assignment shorthand.");
	        }
	    }

	    return {
	        "AssignmentExpression": context.options[0] !== "never" ? verify : prohibit
	    };

	};

	module.exports.schema = [
	    {
	        "enum": ["always", "never"]
	    }
	];


/***/ },
/* 330 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Operator linebreak - enforces operator linebreak style of two types: after and before
	 * @author Benot Zugmeyer
	 * @copyright 2015 Benot Zugmeyer. All rights reserved.
	 */

	"use strict";

	var astUtils = __webpack_require__(177);

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var style = context.options[0] || "after";

	    //--------------------------------------------------------------------------
	    // Helpers
	    //--------------------------------------------------------------------------

	    /**
	     * Checks the operator placement
	     * @param {ASTNode} node The binary operator node to check
	     * @private
	     * @returns {void}
	     */
	    function validateBinaryExpression(node) {
	        var leftToken = context.getLastToken(node.left || node.id);
	        var operatorToken = context.getTokenAfter(leftToken);

	        // When the left part of a binary expression is a single expression wrapped in
	        // parentheses (ex: `(a) + b`), leftToken will be the last token of the expression
	        // and operatorToken will be the closing parenthesis.
	        // The leftToken should be the last closing parenthesis, and the operatorToken
	        // should be the token right after that.
	        while (operatorToken.value === ")") {
	            leftToken = operatorToken;
	            operatorToken = context.getTokenAfter(operatorToken);
	        }

	        var rightToken = context.getTokenAfter(operatorToken);
	        var operator = operatorToken.value;

	        // if single line
	        if (astUtils.isTokenOnSameLine(leftToken, operatorToken) &&
	                astUtils.isTokenOnSameLine(operatorToken, rightToken)) {

	            return;

	        } else if (!astUtils.isTokenOnSameLine(leftToken, operatorToken) &&
	                !astUtils.isTokenOnSameLine(operatorToken, rightToken)) {

	            // lone operator
	            context.report(node, {
	                line: operatorToken.loc.end.line,
	                column: operatorToken.loc.end.column
	            }, "Bad line breaking before and after '" + operator + "'.");

	        } else if (style === "before" && astUtils.isTokenOnSameLine(leftToken, operatorToken)) {

	            context.report(node, {
	                line: operatorToken.loc.end.line,
	                column: operatorToken.loc.end.column
	            }, "'" + operator + "' should be placed at the beginning of the line.");

	        } else if (style === "after" && astUtils.isTokenOnSameLine(operatorToken, rightToken)) {

	            context.report(node, {
	                line: operatorToken.loc.end.line,
	                column: operatorToken.loc.end.column
	            }, "'" + operator + "' should be placed at the end of the line.");

	        } else if (style === "none") {

	            context.report(node, {
	                line: operatorToken.loc.end.line,
	                column: operatorToken.loc.end.column
	            }, "There should be no line break before or after '" + operator + "'");

	        }
	    }

	    //--------------------------------------------------------------------------
	    // Public
	    //--------------------------------------------------------------------------

	    return {
	        "BinaryExpression": validateBinaryExpression,
	        "LogicalExpression": validateBinaryExpression,
	        "AssignmentExpression": validateBinaryExpression,
	        "VariableDeclarator": function(node) {
	            if (node.init) {
	                validateBinaryExpression(node);
	            }
	        }
	    };
	};

	module.exports.schema = [
	    {
	        "enum": ["after", "before", "none"]
	    }
	];


/***/ },
/* 331 */
/***/ function(module, exports) {

	/**
	 * @fileoverview A rule to ensure blank lines within blocks.
	 * @author Mathias Schreck <https://github.com/lo1tuma>
	 * @copyright 2014 Mathias Schreck. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {
	    var requirePadding = context.options[0] !== "never";

	    var ALWAYS_MESSAGE = "Block must be padded by blank lines.",
	        NEVER_MESSAGE = "Block must not be padded by blank lines.";

	    /**
	     * Retrieves an array of all comments defined inside the given node.
	     * @param {ASTNode} node The AST node.
	     * @returns {ASTNode[]} An array of comment nodes.
	     */
	    function getCommentsInNode(node) {
	        var allComments = context.getAllComments();

	        return allComments.filter(function(comment) {
	            return node.range[0] < comment.range[0] &&
	                node.range[1] > comment.range[1];
	        });
	    }

	    /**
	     * Checks if the location of a node or token is before the location of another node or token
	     * @param {ASTNode|Token} a The node or token to check if its location is before b.
	     * @param {ASTNode|Token} b The node or token which will be compared with a.
	     * @returns {boolean} True if a is located before b.
	     */
	    function isLocatedBefore(a, b) {
	        return a.range[1] < b.range[0];
	    }

	    /**
	     * Checks if the given non empty block node has a blank line before its first child node.
	     * @param {ASTNode} node The AST node of a BlockStatement.
	     * @returns {boolean} Whether or not the block starts with a blank line.
	     */
	    function isBlockTopPadded(node) {
	        var blockStart = node.loc.start.line,
	            first = node.body[0],
	            firstLine = first.loc.start.line,
	            expectedFirstLine = blockStart + 2,
	            comments = getCommentsInNode(node),
	            firstComment = comments[0];

	        if (firstComment && isLocatedBefore(firstComment, first)) {
	            firstLine = firstComment.loc.start.line;
	        }

	        return expectedFirstLine <= firstLine;
	    }

	    /**
	     * Checks if the given non empty block node has a blank line after its last child node.
	     * @param {ASTNode} node The AST node of a BlockStatement.
	     * @returns {boolean} Whether or not the block ends with a blank line.
	     */
	    function isBlockBottomPadded(node) {
	        var blockEnd = node.loc.end.line,
	            last = node.body[node.body.length - 1],
	            lastToken = context.getLastToken(last),
	            lastLine = lastToken.loc.end.line,
	            expectedLastLine = blockEnd - 2,
	            comments = getCommentsInNode(node),
	            lastComment = comments[comments.length - 1];

	        if (lastComment && isLocatedBefore(lastToken, lastComment)) {
	            lastLine = lastComment.loc.end.line;
	        }

	        return lastLine <= expectedLastLine;
	    }

	    /**
	     * Checks the given BlockStatement node to be padded if the block is not empty.
	     * @param {ASTNode} node The AST node of a BlockStatement.
	     * @returns {void} undefined.
	     */
	    function checkPadding(node) {
	        if (node.body.length > 0) {

	            var blockHasTopPadding = isBlockTopPadded(node),
	                blockHasBottomPadding = isBlockBottomPadded(node);

	            if (requirePadding) {
	                if (!blockHasTopPadding) {
	                    context.report(node, ALWAYS_MESSAGE);
	                }

	                if (!blockHasBottomPadding) {
	                    context.report(node, node.loc.end, ALWAYS_MESSAGE);
	                }
	            } else {
	                if (blockHasTopPadding) {
	                    context.report(node, NEVER_MESSAGE);
	                }

	                if (blockHasBottomPadding) {
	                    context.report(node, node.loc.end, NEVER_MESSAGE);
	                }
	            }
	        }
	    }

	    return {
	        "BlockStatement": checkPadding
	    };

	};

	module.exports.schema = [
	    {
	        "enum": ["always", "never"]
	    }
	];


/***/ },
/* 332 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to flag non-quoted property names in object literals.
	 * @author Mathias Bynens <http://mathiasbynens.be/>
	 * @copyright 2014 Brandon Mills. All rights reserved.
	 * @copyright 2015 Tomasz Oldzki. All rights reserved.
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------

	var espree = __webpack_require__(184),
	    keywords = __webpack_require__(225);

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var MODE = context.options[0],
	        KEYWORDS = context.options[1] && context.options[1].keywords,

	        MESSAGE_UNNECESSARY = "Unnecessarily quoted property `{{property}}` found.",
	        MESSAGE_UNQUOTED = "Unquoted property `{{property}}` found.",
	        MESSAGE_RESERVED = "Unquoted reserved word `{{property}}` used as key.";


	    /**
	     * Checks whether a certain string constitutes an ES3 token
	     * @param   {string} tokenStr - The string to be checked.
	     * @returns {boolean} `true` if it is an ES3 token.
	     */
	    function isKeyword(tokenStr) {
	        return keywords.indexOf(tokenStr) >= 0;
	    }

	    /**
	     * Checks if an espree-tokenized key has redundant quotes (i.e. whether quotes are unnecessary)
	     * @param   {espreeTokens} tokens The espree-tokenized node key
	     * @returns {boolean} Whether or not a key has redundant quotes.
	     * @private
	     */
	    function areQuotesRedundant(tokens) {
	        return tokens.length === 1 &&
	            (["Identifier", "Keyword", "Null", "Boolean"].indexOf(tokens[0].type) >= 0 ||
	            (tokens[0].type === "Numeric" && "" + +tokens[0].value === tokens[0].value));
	    }

	    /**
	     * Ensures that a property's key is quoted only when necessary
	     * @param   {ASTNode} node Property AST node
	     * @returns {void}
	     */
	    function checkUnnecessaryQuotes(node) {
	        var key = node.key,
	            isKeywordToken,
	            tokens;

	        if (key.type === "Literal" && typeof key.value === "string") {
	            try {
	                tokens = espree.tokenize(key.value);
	            } catch (e) {
	                return;
	            }

	            if (tokens.length !== 1) {
	                return;
	            }

	            isKeywordToken = isKeyword(tokens[0].value);

	            if (isKeywordToken && KEYWORDS) {
	                return;
	            }

	            if (areQuotesRedundant(tokens)) {
	                context.report(node, MESSAGE_UNNECESSARY, {property: key.value});
	            }
	        } else if (KEYWORDS && key.type === "Identifier" && isKeyword(key.name)) {
	            context.report(node, MESSAGE_RESERVED, {property: key.name});
	        }
	    }

	    /**
	     * Ensures that a property's key is quoted
	     * @param   {ASTNode} node Property AST node
	     * @returns {void}
	     */
	    function checkOmittedQuotes(node) {
	        var key = node.key;

	        if (!node.method && !(key.type === "Literal" && typeof key.value === "string")) {
	            context.report(node, MESSAGE_UNQUOTED, {
	                property: key.name || key.value
	            });
	        }
	    }

	    /**
	     * Ensures that an object's keys are consistenly quoted, optionally checks for redundancy of quotes
	     * @param   {ASTNode} node Property AST node
	     * @param   {boolean} checkQuotesRedundancy Whether to check quotes' redundancy
	     * @returns {void}
	     */
	    function checkConsistency(node, checkQuotesRedundancy) {
	        var quotes = false,
	            lackOfQuotes = false,
	            necessaryQuotes = false;

	        node.properties.forEach(function(property) {
	            var key = property.key,
	                tokens;

	            if (key.type === "Literal" && typeof key.value === "string") {

	                quotes = true;

	                if (checkQuotesRedundancy) {
	                    try {
	                        tokens = espree.tokenize(key.value);
	                    } catch (e) {
	                        necessaryQuotes = true;
	                        return;
	                    }
	                    necessaryQuotes = necessaryQuotes || !areQuotesRedundant(tokens);
	                }
	            } else {
	                lackOfQuotes = true;
	            }

	            if (quotes && lackOfQuotes) {
	                context.report(node, "Inconsistently quoted property `{{key}}` found.", {
	                    key: key.name || key.value
	                });
	            }
	        });

	        if (checkQuotesRedundancy && quotes && !necessaryQuotes) {
	            context.report(node, "Properties shouldn't be quoted as all quotes are redundant.");
	        }
	    }

	    return {
	        "Property": function(node) {
	            if (MODE === "always" || !MODE) {
	                checkOmittedQuotes(node);
	            }
	            if (MODE === "as-needed") {
	                checkUnnecessaryQuotes(node);
	            }
	        },
	        "ObjectExpression": function(node) {
	            if (MODE === "consistent") {
	                checkConsistency(node, false);
	            }
	            if (MODE === "consistent-as-needed") {
	                checkConsistency(node, true);
	            }
	        }
	    };

	};

	module.exports.schema = {
	    "anyOf": [
	        {
	            "type": "array",
	            "items": [
	                {
	                    "enum": [0, 1, 2]
	                },
	                {
	                    "enum": ["always", "as-needed", "consistent", "consistent-as-needed"]
	                }
	            ],
	            "minItems": 1,
	            "maxItems": 2
	        },
	        {
	            "type": "array",
	            "items": [
	                {
	                    "enum": [0, 1, 2]
	                },
	                {
	                    "enum": ["always", "as-needed", "consistent", "consistent-as-needed"]
	                },
	                {
	                    "type": "object",
	                    "properties": {
	                        "keywords": {
	                            "type": "boolean"
	                        }
	                    },
	                    "additionalProperties": false
	                }
	            ],
	            "minItems": 1,
	            "maxItems": 3
	        }
	    ]
	};


/***/ },
/* 333 */
/***/ function(module, exports) {

	/**
	 * @fileoverview A rule to choose between single and double quote marks
	 * @author Matt DuVall <http://www.mattduvall.com/>, Brandon Payton
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Constants
	//------------------------------------------------------------------------------

	var QUOTE_SETTINGS = {
	    "double": {
	        quote: "\"",
	        alternateQuote: "'",
	        description: "doublequote"
	    },
	    "single": {
	        quote: "'",
	        alternateQuote: "\"",
	        description: "singlequote"
	    },
	    "backtick": {
	        quote: "`",
	        alternateQuote: "\"",
	        description: "backtick"
	    }
	};

	var AVOID_ESCAPE = "avoid-escape";

	var FUNCTION_TYPE = /^(?:Arrow)?Function(?:Declaration|Expression)$/;

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    /**
	     * Validate that a string passed in is surrounded by the specified character
	     * @param  {string} val The text to check.
	     * @param  {string} character The character to see if it's surrounded by.
	     * @returns {boolean} True if the text is surrounded by the character, false if not.
	     * @private
	     */
	    function isSurroundedBy(val, character) {
	        return val[0] === character && val[val.length - 1] === character;
	    }

	    /**
	     * Determines if a given node is part of JSX syntax.
	     * @param {ASTNode} node The node to check.
	     * @returns {boolean} True if the node is a JSX node, false if not.
	     * @private
	     */
	    function isJSXElement(node) {
	        return node.type.indexOf("JSX") === 0;
	    }

	    /**
	     * Checks whether or not a given node is a directive.
	     * The directive is a `ExpressionStatement` which has only a string literal.
	     * @param {ASTNode} node - A node to check.
	     * @returns {boolean} Whether or not the node is a directive.
	     * @private
	     */
	    function isDirective(node) {
	        return (
	            node.type === "ExpressionStatement" &&
	            node.expression.type === "Literal" &&
	            typeof node.expression.value === "string"
	        );
	    }

	    /**
	     * Checks whether or not a given node is a part of directive prologues.
	     * See also: http://www.ecma-international.org/ecma-262/6.0/#sec-directive-prologues-and-the-use-strict-directive
	     * @param {ASTNode} node - A node to check.
	     * @returns {boolean} Whether or not the node is a part of directive prologues.
	     * @private
	     */
	    function isPartOfDirectivePrologue(node) {
	        var block = node.parent.parent;
	        if (block.type !== "Program" && (block.type !== "BlockStatement" || !FUNCTION_TYPE.test(block.parent.type))) {
	            return false;
	        }

	        // Check the node is at a prologue.
	        for (var i = 0; i < block.body.length; ++i) {
	            var statement = block.body[i];

	            if (statement === node.parent) {
	                return true;
	            }
	            if (!isDirective(statement)) {
	                break;
	            }
	        }

	        return false;
	    }

	    /**
	     * Checks whether or not a given node is allowed as non backtick.
	     * @param {ASTNode} node - A node to check.
	     * @returns {boolean} Whether or not the node is allowed as non backtick.
	     * @private
	     */
	    function isAllowedAsNonBacktick(node) {
	        var parent = node.parent;

	        switch (parent.type) {
	            // Directive Prologues.
	            case "ExpressionStatement":
	                return isPartOfDirectivePrologue(node);

	            // LiteralPropertyName.
	            case "Property":
	                return parent.key === node && !parent.computed;

	            // ModuleSpecifier.
	            case "ImportDeclaration":
	            case "ExportNamedDeclaration":
	            case "ExportAllDeclaration":
	                return parent.source === node;

	            // Others don't allow.
	            default:
	                return false;
	        }
	    }

	    return {

	        "Literal": function(node) {
	            var val = node.value,
	                rawVal = node.raw,
	                quoteOption = context.options[0],
	                settings = QUOTE_SETTINGS[quoteOption || "double"],
	                avoidEscape = context.options[1] === AVOID_ESCAPE,
	                isValid;

	            if (settings && typeof val === "string") {
	                isValid = (quoteOption === "backtick" && isAllowedAsNonBacktick(node)) || isJSXElement(node.parent) || isSurroundedBy(rawVal, settings.quote);

	                if (!isValid && avoidEscape) {
	                    isValid = isSurroundedBy(rawVal, settings.alternateQuote) && rawVal.indexOf(settings.quote) >= 0;
	                }

	                if (!isValid) {
	                    context.report(node, "Strings must use " + settings.description + ".");
	                }
	            }
	        }
	    };

	};

	module.exports.schema = [
	    {
	        "enum": ["single", "double", "backtick"]
	    },
	    {
	        "enum": ["avoid-escape"]
	    }
	];


/***/ },
/* 334 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag non-matching identifiers
	 * @author Matthieu Larcher
	 * @copyright 2015 Matthieu Larcher. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    //--------------------------------------------------------------------------
	    // Helpers
	    //--------------------------------------------------------------------------

	    var pattern = context.options[0] || "^.+$",
	        regexp = new RegExp(pattern);

	    var options = context.options[1] || {},
	        properties = options.properties;

	    // cast to boolean and default to false
	    properties = !!properties;


	    /**
	     * Checks if a string matches the provided pattern
	     * @param {String} name The string to check.
	     * @returns {boolean} if the string is a match
	     * @private
	     */
	    function isInvalid(name) {
	        return !regexp.test(name);
	    }

	    /**
	     * Reports an AST node as a rule violation.
	     * @param {ASTNode} node The node to report.
	     * @returns {void}
	     * @private
	     */
	    function report(node) {
	        context.report(node, "Identifier '{{name}}' does not match the pattern '{{pattern}}'.", {
	            name: node.name,
	            pattern: pattern
	        });
	    }

	    return {

	        "Identifier": function(node) {
	            var name = node.name,
	                effectiveParent = (node.parent.type === "MemberExpression") ? node.parent.parent : node.parent;

	            // MemberExpressions get special rules
	            if (node.parent.type === "MemberExpression") {
	                // return early if properties is false
	                if (!properties) {
	                    return;
	                }

	                // Always check object names
	                if (node.parent.object.type === "Identifier" &&
	                    node.parent.object.name === node.name) {
	                    if (isInvalid(name)) {
	                        report(node);
	                    }

	                    // Report AssignmentExpressions only if they are the left side of the assignment
	                } else if (effectiveParent.type === "AssignmentExpression" &&
	                    (effectiveParent.right.type !== "MemberExpression" ||
	                    effectiveParent.left.type === "MemberExpression" &&
	                    effectiveParent.left.property.name === node.name)) {
	                    if (isInvalid(name)) {
	                        report(node);
	                    }
	                }

	            // Properties have their own rules
	            } else if (node.parent.type === "Property") {
	                // return early if properties is false
	                if (!properties) {
	                    return;
	                }

	                if (effectiveParent.type !== "CallExpression" && isInvalid(name)) {
	                    report(node);
	                }

	            // Report anything that is a match and not a CallExpression
	            } else if (effectiveParent.type !== "CallExpression" && isInvalid(name)) {
	                report(node);
	            }
	        }

	    };

	};

	module.exports.schema = [
	    {
	        "type": "string"
	    },
	    {
	        "type": "object",
	        "properties": {
	            "properties": {
	                "enum": [true, false]
	            }
	        }
	    }
	];


/***/ },
/* 335 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Validates spacing before and after semicolon
	 * @author Mathias Schreck
	 * @copyright 2015 Mathias Schreck
	 */

	"use strict";

	var astUtils = __webpack_require__(177);

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var config = context.options[0],
	        requireSpaceBefore = false,
	        requireSpaceAfter = true;

	    if (typeof config === "object") {
	        if (config.hasOwnProperty("before")) {
	            requireSpaceBefore = config.before;
	        }
	        if (config.hasOwnProperty("after")) {
	            requireSpaceAfter = config.after;
	        }
	    }

	    /**
	     * Checks if a given token has leading whitespace.
	     * @param {Object} token The token to check.
	     * @returns {boolean} True if the given token has leading space, false if not.
	     */
	    function hasLeadingSpace(token) {
	        var tokenBefore = context.getTokenBefore(token);
	        return tokenBefore && astUtils.isTokenOnSameLine(tokenBefore, token) && astUtils.isTokenSpaced(tokenBefore, token);
	    }

	    /**
	     * Checks if a given token has trailing whitespace.
	     * @param {Object} token The token to check.
	     * @returns {boolean} True if the given token has trailing space, false if not.
	     */
	    function hasTrailingSpace(token) {
	        var tokenAfter = context.getTokenAfter(token);
	        return tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter) && astUtils.isTokenSpaced(token, tokenAfter);
	    }

	    /**
	     * Checks if the given token is the last token in its line.
	     * @param {Token} token The token to check.
	     * @returns {boolean} Whether or not the token is the last in its line.
	     */
	    function isLastTokenInCurrentLine(token) {
	        var tokenAfter = context.getTokenAfter(token);
	        return !(tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter));
	    }

	    /**
	     * Checks if the given token is a semicolon.
	     * @param {Token} token The token to check.
	     * @returns {boolean} Whether or not the given token is a semicolon.
	     */
	    function isSemicolon(token) {
	        return token.type === "Punctuator" && token.value === ";";
	    }

	    /**
	     * Reports if the given token has invalid spacing.
	     * @param {Token} token The semicolon token to check.
	     * @param {ASTNode} node The corresponding node of the token.
	     * @returns {void}
	     */
	    function checkSemicolonSpacing(token, node) {
	        var location;

	        if (isSemicolon(token)) {
	            location = token.loc.start;

	            if (hasLeadingSpace(token)) {
	                if (!requireSpaceBefore) {
	                    context.report(node, location, "Unexpected whitespace before semicolon.");
	                }
	            } else {
	                if (requireSpaceBefore) {
	                    context.report(node, location, "Missing whitespace before semicolon.");
	                }
	            }

	            if (!isLastTokenInCurrentLine(token)) {
	                if (hasTrailingSpace(token)) {
	                    if (!requireSpaceAfter) {
	                        context.report(node, location, "Unexpected whitespace after semicolon.");
	                    }
	                } else {
	                    if (requireSpaceAfter) {
	                        context.report(node, location, "Missing whitespace after semicolon.");
	                    }
	                }
	            }
	        }
	    }

	    /**
	     * Checks the spacing of the semicolon with the assumption that the last token is the semicolon.
	     * @param {ASTNode} node The node to check.
	     * @returns {void}
	     */
	    function checkNode(node) {
	        var token = context.getLastToken(node);
	        checkSemicolonSpacing(token, node);
	    }

	    return {
	        "VariableDeclaration": checkNode,
	        "ExpressionStatement": checkNode,
	        "BreakStatement": checkNode,
	        "ContinueStatement": checkNode,
	        "DebuggerStatement": checkNode,
	        "ReturnStatement": checkNode,
	        "ThrowStatement": checkNode,
	        "ForStatement": function(node) {
	            if (node.init) {
	                checkSemicolonSpacing(context.getTokenAfter(node.init), node);
	            }

	            if (node.test) {
	                checkSemicolonSpacing(context.getTokenAfter(node.test), node);
	            }
	        }
	    };
	};

	module.exports.schema = [
	    {
	        "type": "object",
	        "properties": {
	            "before": {
	                "type": "boolean"
	            },
	            "after": {
	                "type": "boolean"
	            }
	        },
	        "additionalProperties": false
	    }
	];


/***/ },
/* 336 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag missing semicolons.
	 * @author Nicholas C. Zakas
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	module.exports = function(context) {

	    var OPT_OUT_PATTERN = /[\[\(\/\+\-]/; // One of [(/+-

	    var always = context.options[0] !== "never";

	    //--------------------------------------------------------------------------
	    // Helpers
	    //--------------------------------------------------------------------------

	    /**
	     * Reports a semicolon error with appropriate location and message.
	     * @param {ASTNode} node The node with an extra or missing semicolon.
	     * @returns {void}
	     */
	    function report(node) {
	        var message = always ? "Missing semicolon." : "Extra semicolon.";
	        context.report(node, context.getLastToken(node).loc.end, message);
	    }

	    /**
	     * Checks whether a token is a semicolon punctuator.
	     * @param {Token} token The token.
	     * @returns {boolean} True if token is a semicolon punctuator.
	     */
	    function isSemicolon(token) {
	        return (token.type === "Punctuator" && token.value === ";");
	    }

	    /**
	     * Check if a semicolon is unnecessary, only true if:
	     *   - next token is on a new line and is not one of the opt-out tokens
	     *   - next token is a valid statement divider
	     * @param {Token} lastToken last token of current node.
	     * @returns {boolean} whether the semicolon is unnecessary.
	     */
	    function isUnnecessarySemicolon(lastToken) {
	        var isDivider, isOptOutToken, lastTokenLine, nextToken, nextTokenLine;

	        if (!isSemicolon(lastToken)) {
	            return false;
	        }

	        nextToken = context.getTokenAfter(lastToken);

	        if (!nextToken) {
	            return true;
	        }

	        lastTokenLine = lastToken.loc.end.line;
	        nextTokenLine = nextToken.loc.start.line;
	        isOptOutToken = OPT_OUT_PATTERN.test(nextToken.value);
	        isDivider = (nextToken.value === "}" || nextToken.value === ";");

	        return (lastTokenLine !== nextTokenLine && !isOptOutToken) || isDivider;
	    }

	    /**
	     * Checks a node to see if it's followed by a semicolon.
	     * @param {ASTNode} node The node to check.
	     * @returns {void}
	     */
	    function checkForSemicolon(node) {
	        var lastToken = context.getLastToken(node);

	        if (always) {
	            if (!isSemicolon(lastToken)) {
	                report(node);
	            }
	        } else {
	            if (isUnnecessarySemicolon(lastToken)) {
	                report(node);
	            }
	        }
	    }

	    /**
	     * Checks to see if there's a semicolon after a variable declaration.
	     * @param {ASTNode} node The node to check.
	     * @returns {void}
	     */
	    function checkForSemicolonForVariableDeclaration(node) {
	        var ancestors = context.getAncestors(),
	            parentIndex = ancestors.length - 1,
	            parent = ancestors[parentIndex];

	        if ((parent.type !== "ForStatement" || parent.init !== node) &&
	            (!/^For(?:In|Of)Statement/.test(parent.type) || parent.left !== node)
	        ) {
	            checkForSemicolon(node);
	        }
	    }

	    //--------------------------------------------------------------------------
	    // Public API
	    //--------------------------------------------------------------------------

	    return {

	        "VariableDeclaration": checkForSemicolonForVariableDeclaration,
	        "ExpressionStatement": checkForSemicolon,
	        "ReturnStatement": checkForSemicolon,
	        "ThrowStatement": checkForSemicolon,
	        "DebuggerStatement": checkForSemicolon,
	        "BreakStatement": checkForSemicolon,
	        "ContinueStatement": checkForSemicolon,
	        "ImportDeclaration": checkForSemicolon,
	        "ExportAllDeclaration": checkForSemicolon,
	        "ExportNamedDeclaration": function(node) {
	            if (!node.declaration) {
	                checkForSemicolon(node);
	            }
	        },
	        "ExportDefaultDeclaration": function(node) {
	            if (!/(?:Class|Function)Declaration/.test(node.declaration.type)) {
	                checkForSemicolon(node);
	            }
	        }
	    };

	};

	module.exports.schema = [
	    {
	        "enum": ["always", "never"]
	    }
	];


/***/ },
/* 337 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to require sorting of variables within a single Variable Declaration block
	 * @author Ilya Volodin
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var configuration = context.options[0] || {},
	        ignoreCase = configuration.ignoreCase || false;

	    return {
	        "VariableDeclaration": function(node) {
	            node.declarations.reduce(function(memo, decl) {
	                if (decl.id.type !== "ObjectPattern" && decl.id.type !== "ArrayPattern") {
	                    var lastVariableName = memo.id.name,
	                        currenVariableName = decl.id.name;

	                    if (ignoreCase) {
	                        lastVariableName = lastVariableName.toLowerCase();
	                        currenVariableName = currenVariableName.toLowerCase();
	                    }

	                    if (currenVariableName < lastVariableName) {
	                        context.report(decl, "Variables within the same declaration block should be sorted alphabetically");
	                        return memo;
	                    } else {
	                        return decl;
	                    }
	                }
	            }, node.declarations[0]);
	        }
	    };
	};

	module.exports.schema = [
	    {
	        "type": "object",
	        "properties": {
	            "ignoreCase": {
	                "type": "boolean"
	            }
	        },
	        "additionalProperties": false
	    }
	];


/***/ },
/* 338 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to enforce the number of spaces after certain keywords
	 * @author Nick Fisher
	 * @copyright 2014 Nick Fisher. All rights reserved.
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    // unless the first option is `"never"`, then a space is required
	    var requiresSpace = context.options[0] !== "never";

	    /**
	     * Check if the separation of two adjacent tokens meets the spacing rules, and report a problem if not.
	     *
	     * @param {ASTNode} node  The node to which the potential problem belongs.
	     * @param {Token} left    The first token.
	     * @param {Token} right   The second token
	     * @returns {void}
	     */
	    function checkTokens(node, left, right) {
	        var hasSpace = left.range[1] < right.range[0],
	            value = left.value;

	        if (hasSpace !== requiresSpace) {
	            context.report(node, "Keyword \"{{value}}\" must {{not}}be followed by whitespace.", {
	                value: value,
	                not: requiresSpace ? "" : "not "
	            });
	        } else if (left.loc.end.line !== right.loc.start.line) {
	            context.report(node, "Keyword \"{{value}}\" must not be followed by a newline.", {
	                value: value
	            });
	        }
	    }

	    /**
	     * Check if the given node (`if`, `for`, `while`, etc), has the correct spacing after it.
	     * @param {ASTNode} node The node to check.
	     * @returns {void}
	     */
	    function check(node) {
	        var tokens = context.getFirstTokens(node, 2);
	        checkTokens(node, tokens[0], tokens[1]);
	    }

	    return {
	        "IfStatement": function(node) {
	            check(node);
	            // check the `else`
	            if (node.alternate && node.alternate.type !== "IfStatement") {
	                checkTokens(node.alternate, context.getTokenBefore(node.alternate), context.getFirstToken(node.alternate));
	            }
	        },
	        "ForStatement": check,
	        "ForOfStatement": check,
	        "ForInStatement": check,
	        "WhileStatement": check,
	        "DoWhileStatement": function(node) {
	            check(node);
	            // check the `while`
	            var whileTokens = context.getTokensAfter(node.body, 2);
	            checkTokens(node, whileTokens[0], whileTokens[1]);
	        },
	        "SwitchStatement": check,
	        "TryStatement": function(node) {
	            check(node);
	            // check the `finally`
	            if (node.finalizer) {
	                checkTokens(node.finalizer, context.getTokenBefore(node.finalizer), context.getFirstToken(node.finalizer));
	            }
	        },
	        "CatchStatement": check,
	        "WithStatement": check
	    };
	};

	module.exports.schema = [
	    {
	        "enum": ["always", "never"]
	    }
	];


/***/ },
/* 339 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview A rule to ensure whitespace before blocks.
	 * @author Mathias Schreck <https://github.com/lo1tuma>
	 * @copyright 2014 Mathias Schreck. All rights reserved.
	 */

	"use strict";

	var astUtils = __webpack_require__(177);

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {
	    var requireSpace = context.options[0] !== "never";

	    /**
	     * Checks the given BlockStatement node has a preceding space if it doesnt start on a new line.
	     * @param {ASTNode|Token} node The AST node of a BlockStatement.
	     * @returns {void} undefined.
	     */
	    function checkPrecedingSpace(node) {
	        var precedingToken = context.getTokenBefore(node),
	            hasSpace;

	        if (precedingToken && astUtils.isTokenOnSameLine(precedingToken, node)) {
	            hasSpace = astUtils.isTokenSpaced(precedingToken, node);

	            if (requireSpace) {
	                if (!hasSpace) {
	                    context.report(node, "Missing space before opening brace.");
	                }
	            } else {
	                if (hasSpace) {
	                    context.report(node, "Unexpected space before opening brace.");
	                }
	            }
	        }
	    }

	    /**
	     * Checks if the CaseBlock of an given SwitchStatement node has a preceding space.
	     * @param {ASTNode} node The node of a SwitchStatement.
	     * @returns {void} undefined.
	     */
	    function checkSpaceBeforeCaseBlock(node) {
	        var cases = node.cases,
	            firstCase,
	            openingBrace;

	        if (cases.length > 0) {
	            firstCase = cases[0];
	            openingBrace = context.getTokenBefore(firstCase);
	        } else {
	            openingBrace = context.getLastToken(node, 1);
	        }

	        checkPrecedingSpace(openingBrace);
	    }

	    return {
	        "BlockStatement": checkPrecedingSpace,
	        "ClassBody": checkPrecedingSpace,
	        "SwitchStatement": checkSpaceBeforeCaseBlock
	    };

	};

	module.exports.schema = [
	    {
	        "enum": ["always", "never"]
	    }
	];


/***/ },
/* 340 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to validate spacing before function paren.
	 * @author Mathias Schreck <https://github.com/lo1tuma>
	 * @copyright 2015 Mathias Schreck
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var configuration = context.options[0],
	        requireAnonymousFunctionSpacing = true,
	        requireNamedFunctionSpacing = true;

	    if (typeof configuration === "object") {
	        requireAnonymousFunctionSpacing = configuration.anonymous !== "never";
	        requireNamedFunctionSpacing = configuration.named !== "never";
	    } else if (configuration === "never") {
	        requireAnonymousFunctionSpacing = false;
	        requireNamedFunctionSpacing = false;
	    }

	    /**
	     * Determines whether two adjacent tokens are have whitespace between them.
	     * @param {Object} left - The left token object.
	     * @param {Object} right - The right token object.
	     * @returns {boolean} Whether or not there is space between the tokens.
	     */
	    function isSpaced(left, right) {
	        return left.range[1] < right.range[0];
	    }

	    /**
	     * Determines whether a function has a name.
	     * @param {ASTNode} node The function node.
	     * @returns {boolean} Whether the function has a name.
	     */
	    function isNamedFunction(node) {
	        var parent;

	        if (node.id) {
	            return true;
	        }

	        parent = context.getAncestors().pop();
	        return parent.type === "MethodDefinition" ||
	            (parent.type === "Property" &&
	                (
	                    parent.kind === "get" ||
	                    parent.kind === "set" ||
	                    parent.method
	                )
	            );
	    }

	    /**
	     * Validates the spacing before function parentheses.
	     * @param {ASTNode} node The node to be validated.
	     * @returns {void}
	     */
	    function validateSpacingBeforeParentheses(node) {
	        var isNamed = isNamedFunction(node),
	            tokens,
	            leftToken,
	            rightToken,
	            location;

	        if (node.generator && !isNamed) {
	            return;
	        }

	        tokens = context.getTokens(node);

	        if (node.generator) {
	            if (node.id) {
	                leftToken = tokens[2];
	                rightToken = tokens[3];
	            } else {
	                // Object methods are named but don't have an id
	                leftToken = context.getTokenBefore(node);
	                rightToken = tokens[0];
	            }
	        } else if (isNamed) {
	            if (node.id) {
	                leftToken = tokens[1];
	                rightToken = tokens[2];
	            } else {
	                // Object methods are named but don't have an id
	                leftToken = context.getTokenBefore(node);
	                rightToken = tokens[0];
	            }
	        } else {
	            leftToken = tokens[0];
	            rightToken = tokens[1];
	        }

	        location = leftToken.loc.end;

	        if (isSpaced(leftToken, rightToken)) {
	            if ((isNamed && !requireNamedFunctionSpacing) || (!isNamed && !requireAnonymousFunctionSpacing)) {
	                context.report(node, location, "Unexpected space before function parentheses.");
	            }
	        } else {
	            if ((isNamed && requireNamedFunctionSpacing) || (!isNamed && requireAnonymousFunctionSpacing)) {
	                context.report(node, location, "Missing space before function parentheses.");
	            }
	        }
	    }

	    return {
	        "FunctionDeclaration": validateSpacingBeforeParentheses,
	        "FunctionExpression": validateSpacingBeforeParentheses
	    };
	};

	module.exports.schema = [
	    {
	        "oneOf": [
	            {
	                "enum": ["always", "never"]
	            },
	            {
	                "type": "object",
	                "properties": {
	                    "anonymous": {
	                        "enum": ["always", "never"]
	                    },
	                    "named": {
	                        "enum": ["always", "never"]
	                    }
	                },
	                "additionalProperties": false
	            }
	        ]
	    }
	];


/***/ },
/* 341 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Disallows or enforces spaces inside of parentheses.
	 * @author Jonathan Rajavuori
	 * @copyright 2014 David Clark. All rights reserved.
	 * @copyright 2014 Jonathan Rajavuori. All rights reserved.
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var MISSING_SPACE_MESSAGE = "There must be a space inside this paren.",
	        REJECTED_SPACE_MESSAGE = "There should be no spaces inside this paren.",
	        exceptionsArray = (context.options.length === 2) ? context.options[1].exceptions : [],
	        options = {},
	        rejectedSpaceRegExp,
	        missingSpaceRegExp,
	        spaceChecks;

	    if (exceptionsArray && exceptionsArray.length) {
	        options.braceException = exceptionsArray.indexOf("{}") !== -1 || false;
	        options.bracketException = exceptionsArray.indexOf("[]") !== -1 || false;
	        options.parenException = exceptionsArray.indexOf("()") !== -1 || false;
	        options.empty = exceptionsArray.indexOf("empty") !== -1 || false;
	    }

	    /**
	     * Used with the `never` option to produce, given the exception options,
	     * two regular expressions to check for missing and rejected spaces.
	     * @param {Object} opts The exception options
	     * @returns {Object} `missingSpace` and `rejectedSpace` regular expressions
	     * @private
	     */
	    function getNeverChecks(opts) {
	        var missingSpaceOpeners = [],
	            missingSpaceClosers = [],
	            rejectedSpaceOpeners = ["\\s"],
	            rejectedSpaceClosers = ["\\s"],
	            missingSpaceCheck,
	            rejectedSpaceCheck;

	        // Populate openers and closers
	        if (opts.braceException) {
	            missingSpaceOpeners.push("\\{");
	            missingSpaceClosers.push("\\}");
	            rejectedSpaceOpeners.push("\\{");
	            rejectedSpaceClosers.push("\\}");
	        }
	        if (opts.bracketException) {
	            missingSpaceOpeners.push("\\[");
	            missingSpaceClosers.push("\\]");
	            rejectedSpaceOpeners.push("\\[");
	            rejectedSpaceClosers.push("\\]");
	        }
	        if (opts.parenException) {
	            missingSpaceOpeners.push("\\(");
	            missingSpaceClosers.push("\\)");
	            rejectedSpaceOpeners.push("\\(");
	            rejectedSpaceClosers.push("\\)");
	        }
	        if (opts.empty) {
	            missingSpaceOpeners.push("\\)");
	            missingSpaceClosers.push("\\(");
	            rejectedSpaceOpeners.push("\\)");
	            rejectedSpaceClosers.push("\\(");
	        }

	        if (missingSpaceOpeners.length) {
	            missingSpaceCheck = "\\((" + missingSpaceOpeners.join("|") + ")";
	            if (missingSpaceClosers.length) {
	                missingSpaceCheck += "|";
	            }
	        }
	        if (missingSpaceClosers.length) {
	            missingSpaceCheck += "(" + missingSpaceClosers.join("|") + ")\\)";
	        }

	        // compose the rejected regexp
	        rejectedSpaceCheck = "\\( +[^" + rejectedSpaceOpeners.join("") + "]";
	        rejectedSpaceCheck += "|[^" + rejectedSpaceClosers.join("") + "] +\\)";

	        return {
	            // e.g. \((\{)|(\})\) --- where {} is an exception
	            missingSpace: missingSpaceCheck || ".^",
	            // e.g. \( +[^ \n\r\{]|[^ \n\r\}] +\) --- where {} is an exception
	            rejectedSpace: rejectedSpaceCheck
	        };
	    }

	    /**
	     * Used with the `always` option to produce, given the exception options,
	     * two regular expressions to check for missing and rejected spaces.
	     * @param {Object} opts The exception options
	     * @returns {Object} `missingSpace` and `rejectedSpace` regular expressions
	     * @private
	     */
	    function getAlwaysChecks(opts) {
	        var missingSpaceOpeners = ["\\s", "\\)"],
	            missingSpaceClosers = ["\\s", "\\("],
	            rejectedSpaceOpeners = [],
	            rejectedSpaceClosers = [],
	            missingSpaceCheck,
	            rejectedSpaceCheck;

	        // Populate openers and closers
	        if (opts.braceException) {
	            missingSpaceOpeners.push("\\{");
	            missingSpaceClosers.push("\\}");
	            rejectedSpaceOpeners.push(" \\{");
	            rejectedSpaceClosers.push("\\} ");
	        }
	        if (opts.bracketException) {
	            missingSpaceOpeners.push("\\[");
	            missingSpaceClosers.push("\\]");
	            rejectedSpaceOpeners.push(" \\[");
	            rejectedSpaceClosers.push("\\] ");
	        }
	        if (opts.parenException) {
	            missingSpaceOpeners.push("\\(");
	            missingSpaceClosers.push("\\)");
	            rejectedSpaceOpeners.push(" \\(");
	            rejectedSpaceClosers.push("\\) ");
	        }
	        if (opts.empty) {
	            rejectedSpaceOpeners.push(" \\)");
	            rejectedSpaceClosers.push("\\( ");
	        }

	        // compose the allowed regexp
	        missingSpaceCheck = "\\([^" + missingSpaceOpeners.join("") + "]";
	        missingSpaceCheck += "|[^" + missingSpaceClosers.join("") + "]\\)";

	        // compose the rejected regexp
	        if (rejectedSpaceOpeners.length) {
	            rejectedSpaceCheck = "\\((" + rejectedSpaceOpeners.join("|") + ")";
	            if (rejectedSpaceClosers.length) {
	                rejectedSpaceCheck += "|";
	            }
	        }
	        if (rejectedSpaceClosers.length) {
	            rejectedSpaceCheck += "(" + rejectedSpaceClosers.join("|") + ")\\)";
	        }

	        return {
	            // e.g. \([^ \)\r\n\{]|[^ \(\r\n\}]\) --- where {} is an exception
	            missingSpace: missingSpaceCheck,
	            // e.g. \(( \{})|(\} )\) --- where {} is an excpetion
	            rejectedSpace: rejectedSpaceCheck || ".^"
	        };
	    }

	    spaceChecks = (context.options[0] === "always") ? getAlwaysChecks(options) : getNeverChecks(options);
	    missingSpaceRegExp = new RegExp(spaceChecks.missingSpace, "mg");
	    rejectedSpaceRegExp = new RegExp(spaceChecks.rejectedSpace, "mg");


	    //--------------------------------------------------------------------------
	    // Helpers
	    //--------------------------------------------------------------------------

	    var skipRanges = [];

	    /**
	     * Adds the range of a node to the set to be skipped when checking parens
	     * @param {ASTNode} node The node to skip
	     * @returns {void}
	     * @private
	     */
	    function addSkipRange(node) {
	        skipRanges.push(node.range);
	    }

	    /**
	     * Sorts the skipRanges array. Must be called before shouldSkip
	     * @returns {void}
	     * @private
	     */
	    function sortSkipRanges() {
	        skipRanges.sort(function(a, b) {
	            return a[0] - b[0];
	        });
	    }

	    /**
	     * Checks if a certain position in the source should be skipped
	     * @param {Number} pos The 0-based index in the source
	     * @returns {boolean} whether the position should be skipped
	     * @private
	     */
	    function shouldSkip(pos) {
	        var i, len, range;
	        for (i = 0, len = skipRanges.length; i < len; i += 1) {
	            range = skipRanges[i];
	            if (pos < range[0]) {
	                break;
	            } else if (pos < range[1]) {
	                return true;
	            }
	        }
	        return false;
	    }


	    //--------------------------------------------------------------------------
	    // Public
	    //--------------------------------------------------------------------------

	    return {

	        "Program:exit": function checkParenSpaces(node) {

	            var nextMatch,
	                nextLine,
	                column,
	                line = 1,
	                source = context.getSource(),
	                pos = 0;

	            function checkMatch(match, message) {
	                if (source.charAt(match.index) !== "(") {
	                    // Matched a closing paren pattern
	                    match.index += 1;
	                }

	                if (!shouldSkip(match.index)) {
	                    while ((nextLine = source.indexOf("\n", pos)) !== -1 && nextLine < match.index) {
	                        pos = nextLine + 1;
	                        line += 1;
	                    }
	                    column = match.index - pos;

	                    context.report(node, { line: line, column: column }, message);
	                }
	            }

	            sortSkipRanges();

	            while ((nextMatch = rejectedSpaceRegExp.exec(source)) !== null) {
	                checkMatch(nextMatch, REJECTED_SPACE_MESSAGE);
	            }

	            while ((nextMatch = missingSpaceRegExp.exec(source)) !== null) {
	                checkMatch(nextMatch, MISSING_SPACE_MESSAGE);
	            }

	        },


	        // These nodes can contain parentheses that this rule doesn't care about

	        LineComment: addSkipRange,

	        BlockComment: addSkipRange,

	        Literal: addSkipRange,

	        TemplateElement: addSkipRange

	    };

	};

	module.exports.schema = [
	    {
	        "enum": ["always", "never"]
	    },
	    {
	        "type": "object",
	        "properties": {
	            "exceptions": {
	                "type": "array",
	                "items": {
	                    "enum": ["{}", "[]", "()", "empty"]
	                },
	                "uniqueItems": true
	            }
	        },
	        "additionalProperties": false
	    }
	];


/***/ },
/* 342 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Require spaces around infix operators
	 * @author Michael Ficarra
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {
	    var int32Hint = context.options[0] ? context.options[0].int32Hint === true : false;

	    var OPERATORS = [
	        "*", "/", "%", "+", "-", "<<", ">>", ">>>", "<", "<=", ">", ">=", "in",
	        "instanceof", "==", "!=", "===", "!==", "&", "^", "|", "&&", "||", "=",
	        "+=", "-=", "*=", "/=", "%=", "<<=", ">>=", ">>>=", "&=", "^=", "|=",
	        "?", ":", ","
	    ];

	    /**
	     * Returns the first token which violates the rule
	     * @param {ASTNode} left - The left node of the main node
	     * @param {ASTNode} right - The right node of the main node
	     * @returns {object} The violator token or null
	     * @private
	     */
	    function getFirstNonSpacedToken(left, right) {
	        var op, tokens = context.getTokensBetween(left, right, 1);
	        for (var i = 1, l = tokens.length - 1; i < l; ++i) {
	            op = tokens[i];
	            if (
	                op.type === "Punctuator" &&
	                OPERATORS.indexOf(op.value) >= 0 &&
	                (tokens[i - 1].range[1] >= op.range[0] || op.range[1] >= tokens[i + 1].range[0])
	            ) {
	                return op;
	            }
	        }
	        return null;
	    }

	    /**
	     * Reports an AST node as a rule violation
	     * @param {ASTNode} mainNode - The node to report
	     * @param {object} culpritToken - The token which has a problem
	     * @returns {void}
	     * @private
	     */
	    function report(mainNode, culpritToken) {
	        context.report(mainNode, culpritToken.loc.start, "Infix operators must be spaced.");
	    }

	    function checkBinary(node) {
	        var nonSpacedNode = getFirstNonSpacedToken(node.left, node.right);

	        if (nonSpacedNode) {
	            if (!(int32Hint && context.getSource(node).substr(-2) === "|0")) {
	                report(node, nonSpacedNode);
	            }
	        }
	    }

	    function checkConditional(node) {
	        var nonSpacedConsequesntNode = getFirstNonSpacedToken(node.test, node.consequent);
	        var nonSpacedAlternateNode = getFirstNonSpacedToken(node.consequent, node.alternate);

	        if (nonSpacedConsequesntNode) {
	            report(node, nonSpacedConsequesntNode);
	        } else if (nonSpacedAlternateNode) {
	            report(node, nonSpacedAlternateNode);
	        }
	    }

	    function checkVar(node) {
	        var nonSpacedNode;

	        if (node.init) {
	            nonSpacedNode = getFirstNonSpacedToken(node.id, node.init);
	            if (nonSpacedNode) {
	                report(node, nonSpacedNode);
	            }
	        }
	    }

	    return {
	        "AssignmentExpression": checkBinary,
	        "BinaryExpression": checkBinary,
	        "LogicalExpression": checkBinary,
	        "ConditionalExpression": checkConditional,
	        "VariableDeclarator": checkVar
	    };

	};

	module.exports.schema = [
	    {
	        "type": "object",
	        "properties": {
	            "int32Hint": {
	                "type": "boolean"
	            }
	        },
	        "additionalProperties": false
	    }
	];


/***/ },
/* 343 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Require spaces following return, throw, and case
	 * @author Michael Ficarra
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    function check(node) {
	        var tokens = context.getFirstTokens(node, 2),
	            value = tokens[0].value;

	        if (tokens[0].range[1] >= tokens[1].range[0]) {
	            context.report(node, "Keyword \"" + value + "\" must be followed by whitespace.");
	        }
	    }

	    return {
	        "ReturnStatement": function(node) {
	            if (node.argument) {
	                check(node);
	            }
	        },
	        "SwitchCase": function(node) {
	            if (node.test) {
	                check(node);
	            }
	        },
	        "ThrowStatement": check
	    };

	};

	module.exports.schema = [];


/***/ },
/* 344 */
/***/ function(module, exports) {

	/**
	 * @fileoverview This rule shoud require or disallow spaces before or after unary operations.
	 * @author Marcin Kumorek
	 * @copyright 2014 Marcin Kumorek. All rights reserved.
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {
	    var options = context.options && Array.isArray(context.options) && context.options[0] || { words: true, nonwords: false };

	    //--------------------------------------------------------------------------
	    // Helpers
	    //--------------------------------------------------------------------------

	    /**
	    * Check if the parent unary operator is "!" in order to know if it's "!!" convert to Boolean or just "!" negation
	    * @param {ASTnode} node AST node
	    * @returns {boolean} Whether or not the parent is unary "!" operator
	    */
	    function isParentUnaryBangExpression(node) {
	        return node && node.parent && node.parent.type === "UnaryExpression" && node.parent.operator === "!";
	    }

	    /**
	    * Check if the node's child argument is an "ObjectExpression"
	    * @param {ASTnode} node AST node
	    * @returns {boolean} Whether or not the argument's type is "ObjectExpression"
	    */
	    function isArgumentObjectExpression(node) {
	        return node.argument && node.argument.type && node.argument.type === "ObjectExpression";
	    }

	    /**
	    * Check Unary Word Operators for spaces after the word operator
	    * @param {ASTnode} node AST node
	    * @param {object} firstToken first token from the AST node
	    * @param {object} secondToken second token from the AST node
	    * @returns {void}
	    */
	    function checkUnaryWordOperatorForSpaces(node, firstToken, secondToken) {
	        if (options.words) {
	            if (secondToken.range[0] === firstToken.range[1]) {
	                context.report(node, "Unary word operator \"" + firstToken.value + "\" must be followed by whitespace.");
	            }
	        }

	        if (!options.words && isArgumentObjectExpression(node)) {
	            if (secondToken.range[0] > firstToken.range[1]) {
	                context.report(node, "Unexpected space after unary word operator \"" + firstToken.value + "\".");
	            }
	        }
	    }

	    /**
	    * Checks UnaryExpression, UpdateExpression and NewExpression for spaces before and after the operator
	    * @param {ASTnode} node AST node
	    * @returns {void}
	    */
	    function checkForSpaces(node) {
	        var tokens = context.getFirstTokens(node, 2),
	            firstToken = tokens[0],
	            secondToken = tokens[1];

	        if ((node.type === "NewExpression" || node.prefix) && firstToken.type === "Keyword") {
	            checkUnaryWordOperatorForSpaces(node, firstToken, secondToken);
	            return void 0;
	        }

	        if (options.nonwords) {
	            if (node.prefix) {
	                if (isParentUnaryBangExpression(node)) {
	                    return void 0;
	                }
	                if (firstToken.range[1] === secondToken.range[0]) {
	                    context.report(node, "Unary operator \"" + firstToken.value + "\" must be followed by whitespace.");
	                }
	            } else {
	                if (firstToken.range[1] === secondToken.range[0]) {
	                    context.report(node, "Space is required before unary expressions \"" + secondToken.value + "\".");
	                }
	            }
	        } else {
	            if (node.prefix) {
	                if (secondToken.range[0] > firstToken.range[1]) {
	                    context.report(node, "Unexpected space after unary operator \"" + firstToken.value + "\".");
	                }
	            } else {
	                if (secondToken.range[0] > firstToken.range[1]) {
	                    context.report(node, "Unexpected space before unary operator \"" + secondToken.value + "\".");
	                }
	            }
	        }
	    }

	    //--------------------------------------------------------------------------
	    // Public
	    //--------------------------------------------------------------------------

	    return {
	        "UnaryExpression": checkForSpaces,
	        "UpdateExpression": checkForSpaces,
	        "NewExpression": checkForSpaces
	    };

	};

	module.exports.schema = [
	    {
	        "type": "object",
	        "properties": {
	            "words": {
	                "type": "boolean"
	            },
	            "nonwords": {
	                "type": "boolean"
	            }
	        },
	        "additionalProperties": false
	    }
	];


/***/ },
/* 345 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Source code for spaced-comments rule
	 * @author Gyandeep Singh
	 * @copyright 2015 Toru Nagashima. All rights reserved.
	 * @copyright 2015 Gyandeep Singh. All rights reserved.
	 * @copyright 2014 Greg Cochard. All rights reserved.
	 */
	"use strict";

	var escapeStringRegexp = __webpack_require__(346);

	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------

	/**
	 * Escapes the control characters of a given string.
	 * @param {string} s - A string to escape.
	 * @returns {string} An escaped string.
	 */
	function escape(s) {
	    var isOneChar = s.length === 1;
	    s = escapeStringRegexp(s);
	    return isOneChar ? s : "(?:" + s + ")";
	}

	/**
	 * Escapes the control characters of a given string.
	 * And adds a repeat flag.
	 * @param {string} s - A string to escape.
	 * @returns {string} An escaped string.
	 */
	function escapeAndRepeat(s) {
	    return escape(s) + "+";
	}

	/**
	 * Parses `markers` option.
	 * If markers don't include `"*"`, this adds `"*"` to allow JSDoc comments.
	 * @param {string[]|null} markers - A marker list.
	 * @returns {string[]} A marker list.
	 */
	function parseMarkersOption(markers) {
	    if (markers == null) {
	        markers = [];
	    }

	    // `*` is a marker for JSDoc comments.
	    if (markers.indexOf("*") === -1) {
	        markers.push("*");
	    }

	    return markers;
	}

	/**
	 * Parses `exceptions` option.
	 * @param {string[]|null} exceptions - An exception list.
	 * @returns {string[]} An exception list.
	 */
	function parseExceptionsOption(exceptions) {
	    return exceptions || [];
	}

	/**
	 * Creates RegExp object for `always` mode.
	 * Generated pattern is below:
	 *
	 * 1. First, a marker or nothing.
	 * 2. Next, a space or an exception pattern sequence.
	 *
	 * @param {string[]} markers - A marker list.
	 * @param {string[]} exceptions - A exception pattern list.
	 * @returns {RegExp} A RegExp object for `always` mode.
	 */
	function createAlwaysStylePattern(markers, exceptions) {
	    var pattern = "^";

	    // A marker or nothing.
	    //   ["*"]            ==> "\*?"
	    //   ["*", "!"]       ==> "(?:\*|!)?"
	    //   ["*", "/", "!<"] ==> "(?:\*|\/|(?:!<))?" ==> https://jex.im/regulex/#!embed=false&flags=&re=(%3F%3A%5C*%7C%5C%2F%7C(%3F%3A!%3C))%3F
	    if (markers.length === 1) {
	        // the marker.
	        pattern += escape(markers[0]);
	    } else {
	        // one of markers.
	        pattern += "(?:";
	        pattern += markers.map(escape).join("|");
	        pattern += ")";
	    }
	    pattern += "?"; // or nothing.

	    // A space or an exception pattern sequence.
	    //   []                 ==> "\s"
	    //   ["-"]              ==> "(?:\s|\-+$)"
	    //   ["-", "="]         ==> "(?:\s|(?:\-+|=+)$)"
	    //   ["-", "=", "--=="] ==> "(?:\s|(?:\-+|=+|(?:\-\-==)+)$)" ==> https://jex.im/regulex/#!embed=false&flags=&re=(%3F%3A%5Cs%7C(%3F%3A%5C-%2B%7C%3D%2B%7C(%3F%3A%5C-%5C-%3D%3D)%2B)%24)
	    if (exceptions.length === 0) {
	        // a space.
	        pattern += "\\s";
	    } else {
	        // a space or...
	        pattern += "(?:\\s|";
	        if (exceptions.length === 1) {
	            // a sequence of the exception pattern.
	            pattern += escapeAndRepeat(exceptions[0]);
	        } else {
	            // a sequence of one of exception patterns.
	            pattern += "(?:";
	            pattern += exceptions.map(escapeAndRepeat).join("|");
	            pattern += ")";
	        }
	        pattern += "$)"; // the sequence continues until the end.
	    }

	    return new RegExp(pattern);
	}

	/**
	 * Creates RegExp object for `never` mode.
	 * Generated pattern is below:
	 *
	 * 1. First, a marker or nothing (captured).
	 * 2. Next, a space or a tab.
	 *
	 * @param {string[]} markers - A marker list.
	 * @returns {RegExp} A RegExp object for `never` mode.
	 */
	function createNeverStylePattern(markers) {
	    var pattern = "^(" + markers.map(escape).join("|") + ")?[ \t]";
	    return new RegExp(pattern);
	}

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {
	    // Unless the first option is never, require a space
	    var requireSpace = context.options[0] !== "never";

	    // Parse the second options.
	    // If markers don't include `"*"`, it's added automatically for JSDoc comments.
	    var markers = parseMarkersOption(context.options[1] && context.options[1].markers);
	    var exceptions = parseExceptionsOption(context.options[1] && context.options[1].exceptions);

	    // Create RegExp object for valid patterns.
	    var stylePattern = null;
	    if (requireSpace) {
	        stylePattern = createAlwaysStylePattern(markers, exceptions);
	    } else {
	        stylePattern = createNeverStylePattern(markers);
	    }

	    /**
	     * Reports a given comment if it's invalid.
	     * @param {ASTNode} node - a comment node to check.
	     * @returns {void}
	     */
	    function checkCommentForSpace(node) {
	        var commentIdentifier = node.type === "Block" ? "/*" : "//";

	        // Ignores empty comments.
	        if (node.value.length === 0) {
	            return;
	        }

	        // Checks.
	        if (requireSpace) {
	            if (!stylePattern.test(node.value)) {
	                if (exceptions.length > 0) {
	                    context.report(node, "Expected exception block, space or tab after " + commentIdentifier + " in comment.");
	                } else {
	                    context.report(node, "Expected space or tab after " + commentIdentifier + " in comment.");
	                }
	            }
	        } else {
	            var matched = stylePattern.exec(node.value);
	            if (matched) {
	                if (matched[1] == null) {
	                    context.report(node, "Unexpected space or tab after " + commentIdentifier + " in comment.");
	                } else {
	                    context.report(node, "Unexpected space or tab after marker (" + matched[1] + ") in comment.");
	                }
	            }
	        }
	    }

	    return {

	        "LineComment": checkCommentForSpace,
	        "BlockComment": checkCommentForSpace

	    };
	};

	module.exports.schema = [
	    {
	        "enum": ["always", "never"]
	    },
	    {
	        "type": "object",
	        "properties": {
	            "exceptions": {
	                "type": "array",
	                "items": {
	                    "type": "string"
	                }
	            },
	            "markers": {
	                "type": "array",
	                "items": {
	                    "type": "string"
	                }
	            }
	        },
	        "additionalProperties": false
	    }
	];


/***/ },
/* 346 */
/***/ function(module, exports) {

	'use strict';

	var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

	module.exports = function (str) {
		if (typeof str !== 'string') {
			throw new TypeError('Expected a string');
		}

		return str.replace(matchOperatorsRe,  '\\$&');
	};


/***/ },
/* 347 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag when regex literals are not wrapped in parens
	 * @author Matt DuVall <http://www.mattduvall.com>
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {

	        "Literal": function(node) {
	            var token = context.getFirstToken(node),
	                nodeType = token.type,
	                source,
	                grandparent,
	                ancestors;

	            if (nodeType === "RegularExpression") {
	                source = context.getTokenBefore(node);
	                ancestors = context.getAncestors();
	                grandparent = ancestors[ancestors.length - 1];

	                if (grandparent.type === "MemberExpression" && grandparent.object === node &&
	                    (!source || source.value !== "(")) {
	                    context.report(node, "Wrap the regexp literal in parens to disambiguate the slash.");
	                }
	            }
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 348 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to require parens in arrow function arguments.
	 * @author Jxck
	 * @copyright 2015 Jxck. All rights reserved.
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {
	    var message = "Expected parentheses around arrow function argument.";
	    var asNeededMessage = "Unexpected parentheses around single function argument";
	    var asNeeded = context.options[0] === "as-needed";

	    /**
	     * Determines whether a arrow function argument end with `)`
	     * @param {ASTNode} node The arrow function node.
	     * @returns {void}
	     */
	    function parens(node) {
	        var token = context.getFirstToken(node);

	        // as-needed: x => x
	        if (asNeeded && node.params.length === 1) {
	            if (token.type === "Punctuator" && token.value === "(") {
	                context.report(node, asNeededMessage);
	            }
	            return;
	        }

	        if (token.type === "Identifier") {
	            var after = context.getTokenAfter(token);

	            // (x) => x
	            if (after.value !== ")") {
	                context.report(node, message);
	            }
	        }
	    }

	    return {
	        "ArrowFunctionExpression": parens
	    };
	};

	module.exports.schema = [
	    {
	        "enum": ["always", "as-needed"]
	    }
	];


/***/ },
/* 349 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to require parens in arrow function arguments.
	 * @author Jxck
	 * @copyright 2015 Jxck. All rights reserved.
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {
	    // merge rules with default
	    var rule = { before: true, after: true };
	    var option = context.options[0] || {};
	    rule.before = option.before !== false;
	    rule.after = option.after !== false;

	    /**
	     * Get tokens of arrow(`=>`) and before/after arrow.
	     * @param {ASTNode} node The arrow function node.
	     * @returns {Object} Tokens of arrow and before/after arrow.
	     */
	    function getTokens(node) {
	        var t = context.getFirstToken(node);
	        var before;
	        while (t.type !== "Punctuator" || t.value !== "=>") {
	            before = t;
	            t = context.getTokenAfter(t);
	        }
	        var after = context.getTokenAfter(t);
	        return { before: before, arrow: t, after: after };
	    }

	    /**
	     * Count spaces before/after arrow(`=>`) token.
	     * @param {Object} tokens Tokens before/after arrow.
	     * @returns {Object} count of space before/after arrow.
	     */
	    function countSpaces(tokens) {
	        var before = tokens.arrow.range[0] - tokens.before.range[1];
	        var after = tokens.after.range[0] - tokens.arrow.range[1];
	        return { before: before, after: after };
	    }

	    /**
	     * Determines whether space(s) before after arrow(`=>`) is satisfy rule.
	     * if before/after value is `true`, there should be space(s).
	     * if before/after value is `false`, there should be no space.
	     * @param {ASTNode} node The arrow function node.
	     * @returns {void}
	     */
	    function spaces(node) {
	        var tokens = getTokens(node);
	        var countSpace = countSpaces(tokens);

	        if (rule.before) {
	            // should be space(s) before arrow
	            if (countSpace.before === 0) {
	                context.report(tokens.before, "Missing space before =>");
	            }
	        } else {
	            // should be no space before arrow
	            if (countSpace.before > 0) {
	                context.report(tokens.before, "Unexpected space before =>");
	            }
	        }

	        if (rule.after) {
	            // should be space(s) after arrow
	            if (countSpace.after === 0) {
	                context.report(tokens.after, "Missing space after =>");
	            }
	        } else {
	            // should be no space after arrow
	            if (countSpace.after > 0) {
	                context.report(tokens.after, "Unexpected space after =>");
	            }
	        }
	    }

	    return {
	        "ArrowFunctionExpression": spaces
	    };
	};

	module.exports.schema = [
	    {
	        "type": "object",
	        "properties": {
	            "before": {
	                "type": "boolean"
	            },
	            "after": {
	                "type": "boolean"
	            }
	        },
	        "additionalProperties": false
	    }
	];


/***/ },
/* 350 */
/***/ function(module, exports) {

	/**
	 * @fileoverview A rule to verify `super()` callings in constructor.
	 * @author Toru Nagashima
	 * @copyright 2015 Toru Nagashima. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    /**
	     * Searches a class node from ancestors of a node.
	     * @param {Node} node - A node to get.
	     * @returns {ClassDeclaration|ClassExpression|null} the found class node or `null`.
	     */
	    function getClassInAncestor(node) {
	        while (node != null) {
	            if (node.type === "ClassDeclaration" || node.type === "ClassExpression") {
	                return node;
	            }
	            node = node.parent;
	        }
	        /* istanbul ignore next */
	        return null;
	    }

	    /**
	     * Checks whether or not a node is the null literal.
	     * @param {Node} node - A node to check.
	     * @returns {boolean} whether or not a node is the null literal.
	     */
	    function isNullLiteral(node) {
	        return node != null && node.type === "Literal" && node.value === null;
	    }

	    /**
	     * Checks whether or not the current traversal context is on constructors.
	     * @param {{scope: Scope}} item - A checking context to check.
	     * @returns {boolean} whether or not the current traversal context is on constructors.
	     */
	    function isOnConstructor(item) {
	        return item != null && item.scope === context.getScope().variableScope.upper.variableScope;
	    }

	    // A stack for checking context.
	    var stack = [];

	    return {
	        /**
	         * Start checking.
	         * @param {MethodDefinition} node - A target node.
	         * @returns {void}
	         */
	        "MethodDefinition": function(node) {
	            if (node.kind !== "constructor") {
	                return;
	            }
	            stack.push({
	                superCallings: [],
	                scope: context.getScope().variableScope
	            });
	        },

	        /**
	         * Checks the result, then reports invalid/missing `super()`.
	         * @param {MethodDefinition} node - A target node.
	         * @returns {void}
	         */
	        "MethodDefinition:exit": function(node) {
	            if (node.kind !== "constructor") {
	                return;
	            }
	            var result = stack.pop();

	            var classNode = getClassInAncestor(node);
	            /* istanbul ignore if */
	            if (classNode == null) {
	                return;
	            }

	            if (classNode.superClass === null || isNullLiteral(classNode.superClass)) {
	                result.superCallings.forEach(function(superCalling) {
	                    context.report(superCalling, "unexpected `super()`.");
	                });
	            } else if (result.superCallings.length === 0) {
	                context.report(node.key, "this constructor requires `super()`.");
	            }
	        },

	        /**
	         * Checks the result of checking, then reports invalid/missing `super()`.
	         * @param {MethodDefinition} node - A target node.
	         * @returns {void}
	         */
	        "CallExpression": function(node) {
	            var item = stack[stack.length - 1];
	            if (isOnConstructor(item) && node.callee.type === "Super") {
	                item.superCallings.push(node);
	            }
	        }
	    };
	};

	module.exports.schema = [];


/***/ },
/* 351 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to check the spacing around the * in generator functions.
	 * @author Jamund Ferguson
	 * @copyright 2015 Brandon Mills. All rights reserved.
	 * @copyright 2014 Jamund Ferguson. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var mode = (function(option) {
	        if (option == null || typeof option === "string") {
	            return {
	                before: { before: true, after: false },
	                after: { before: false, after: true },
	                both: { before: true, after: true },
	                neither: { before: false, after: false }
	            }[option || "before"];
	        }
	        return option;
	    }(context.options[0]));

	    /**
	     * Checks the spacing between two tokens before or after the star token.
	     * @param {string} side Either "before" or "after".
	     * @param {Token} leftToken `function` keyword token if side is "before", or
	     *     star token if side is "after".
	     * @param {Token} rightToken Star token if side is "before", or identifier
	     *     token if side is "after".
	     * @returns {void}
	     */
	    function checkSpacing(side, leftToken, rightToken) {
	        if (!!(rightToken.range[0] - leftToken.range[1]) !== mode[side]) {
	            context.report(
	                leftToken.value === "*" ? leftToken : rightToken,
	                "{{type}} space {{side}} *.",
	                {
	                    type: mode[side] ? "Missing" : "Unexpected",
	                    side: side
	                }
	            );
	        }
	    }

	    /**
	     * Enforces the spacing around the star if node is a generator function.
	     * @param {ASTNode} node A function expression or declaration node.
	     * @returns {void}
	     */
	    function checkFunction(node) {
	        var prevToken, starToken, nextToken;

	        if (!node.generator) {
	            return;
	        }

	        if (node.parent.method || node.parent.type === "MethodDefinition") {
	            starToken = context.getTokenBefore(node, 1);
	        } else {
	            starToken = context.getFirstToken(node, 1);
	        }

	        // Only check before when preceded by `function` keyword
	        prevToken = context.getTokenBefore(starToken);
	        if (prevToken.value === "function" || prevToken.value === "static") {
	            checkSpacing("before", prevToken, starToken);
	        }

	        // Only check after when followed by an identifier
	        nextToken = context.getTokenAfter(starToken);
	        if (nextToken.type === "Identifier") {
	            checkSpacing("after", starToken, nextToken);
	        }
	    }

	    return {
	        "FunctionDeclaration": checkFunction,
	        "FunctionExpression": checkFunction
	    };

	};

	module.exports.schema = [
	    {
	        "oneOf": [
	            {
	                "enum": ["before", "after", "both", "neither"]
	            },
	            {
	                "type": "object",
	                "properties": {
	                    "before": {"type": "boolean"},
	                    "after": {"type": "boolean"}
	                },
	                "additionalProperties": false
	            }
	        ]
	    }
	];


/***/ },
/* 352 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview A rule to disallow modifying variables of class declarations
	 * @author Toru Nagashima
	 * @copyright 2015 Toru Nagashima. All rights reserved.
	 */

	"use strict";

	var astUtils = __webpack_require__(177);

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    /**
	     * Finds and reports references that are non initializer and writable.
	     * @param {Variable} variable - A variable to check.
	     * @returns {void}
	     */
	    function checkVariable(variable) {
	        astUtils.getModifyingReferences(variable.references).forEach(function(reference) {
	            context.report(
	                reference.identifier,
	                "`{{name}}` is a class.",
	                {name: reference.identifier.name});

	        });
	    }

	    /**
	     * Finds and reports references that are non initializer and writable.
	     * @param {ASTNode} node - A ClassDeclaration/ClassExpression node to check.
	     * @returns {void}
	     */
	    function checkForClass(node) {
	        context.getDeclaredVariables(node).forEach(checkVariable);
	    }

	    return {
	        "ClassDeclaration": checkForClass,
	        "ClassExpression": checkForClass
	    };

	};

	module.exports.schema = [];


/***/ },
/* 353 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview A rule to disallow modifying variables that are declared using `const`
	 * @author Toru Nagashima
	 * @copyright 2015 Toru Nagashima. All rights reserved.
	 */

	"use strict";

	var astUtils = __webpack_require__(177);

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    /**
	     * Finds and reports references that are non initializer and writable.
	     * @param {Variable} variable - A variable to check.
	     * @returns {void}
	     */
	    function checkVariable(variable) {
	        astUtils.getModifyingReferences(variable.references).forEach(function(reference) {
	            context.report(
	                reference.identifier,
	                "`{{name}}` is constant.",
	                {name: reference.identifier.name});
	        });
	    }

	    return {
	        "VariableDeclaration": function(node) {
	            if (node.kind === "const") {
	                context.getDeclaredVariables(node).forEach(checkVariable);
	            }
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 354 */
/***/ function(module, exports) {

	/**
	 * @fileoverview A rule to disallow using `this`/`super` before `super()`.
	 * @author Toru Nagashima
	 * @copyright 2015 Toru Nagashima. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    /**
	     * Searches a class node that a node is belonging to.
	     * @param {Node} node - A node to start searching.
	     * @returns {ClassDeclaration|ClassExpression|null} the found class node, or `null`.
	     */
	    function getClassInAncestor(node) {
	        while (node != null) {
	            if (node.type === "ClassDeclaration" || node.type === "ClassExpression") {
	                return node;
	            }
	            node = node.parent;
	        }
	        /* istanbul ignore next */
	        return null;
	    }

	    /**
	     * Checks whether or not a node is the null literal.
	     * @param {Node} node - A node to check.
	     * @returns {boolean} whether or not a node is the null literal.
	     */
	    function isNullLiteral(node) {
	        return node != null && node.type === "Literal" && node.value === null;
	    }

	    /**
	     * Checks whether or not a node is the callee of a call expression.
	     * @param {Node} node - A node to check.
	     * @returns {boolean} whether or not a node is the callee of a call expression.
	     */
	    function isCallee(node) {
	        return node != null && node.parent.type === "CallExpression" && node.parent.callee === node;
	    }

	    /**
	     * Checks whether or not the current traversal context is before `super()`.
	     * @param {object} item - A checking context.
	     * @returns {boolean} whether or not the current traversal context is before `super()`.
	     */
	    function isBeforeSuperCalling(item) {
	        return (
	            item != null &&
	            item.scope === context.getScope().variableScope.upper.variableScope &&
	            item.superCalled === false
	        );
	    }

	    var stack = [];

	    return {
	        /**
	         * Start checking.
	         * @param {MethodDefinition} node - A target node.
	         * @returns {void}
	         */
	        "MethodDefinition": function(node) {
	            if (node.kind !== "constructor") {
	                return;
	            }
	            stack.push({
	                thisOrSuperBeforeSuperCalled: [],
	                superCalled: false,
	                scope: context.getScope().variableScope
	            });
	        },

	        /**
	         * Treats the result of checking and reports invalid `this`/`super`.
	         * @param {MethodDefinition} node - A target node.
	         * @returns {void}
	         */
	        "MethodDefinition:exit": function(node) {
	            if (node.kind !== "constructor") {
	                return;
	            }
	            var result = stack.pop();

	            // Skip if it has no extends or `extends null`.
	            var classNode = getClassInAncestor(node);
	            if (classNode == null || classNode.superClass == null || isNullLiteral(classNode.superClass)) {
	                return;
	            }

	            // Reports.
	            result.thisOrSuperBeforeSuperCalled.forEach(function(thisOrSuper) {
	                var type = (thisOrSuper.type === "Super" ? "super" : "this");
	                context.report(thisOrSuper, "\"{{type}}\" is not allowed before super()", {type: type});
	            });
	        },

	        /**
	         * Marks the node if is before `super()`.
	         * @param {ThisExpression} node - A target node.
	         * @returns {void}
	         */
	        "ThisExpression": function(node) {
	            var item = stack[stack.length - 1];
	            if (isBeforeSuperCalling(item)) {
	                item.thisOrSuperBeforeSuperCalled.push(node);
	            }
	        },

	        /**
	         * Marks the node if is before `super()`. (exclude `super()` itself)
	         * @param {Super} node - A target node.
	         * @returns {void}
	         */
	        "Super": function(node) {
	            var item = stack[stack.length - 1];
	            if (isBeforeSuperCalling(item) && isCallee(node) === false) {
	                item.thisOrSuperBeforeSuperCalled.push(node);
	            }
	        },

	        /**
	         * Marks `super()` called.
	         * To catch `super(this.a);`, marks on `CallExpression:exit`.
	         * @param {CallExpression} node - A target node.
	         * @returns {void}
	         */
	        "CallExpression:exit": function(node) {
	            var item = stack[stack.length - 1];
	            if (isBeforeSuperCalling(item) && node.callee.type === "Super") {
	                item.superCalled = true;
	            }
	        }
	    };
	};

	module.exports.schema = [];


/***/ },
/* 355 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to check for the usage of var.
	 * @author Jamund Ferguson
	 * @copyright 2014 Jamund Ferguson. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {
	        "VariableDeclaration": function(node) {
	            if (node.kind === "var") {
	                context.report(node, "Unexpected var, use let or const instead.");
	            }
	        }

	    };

	};

	module.exports.schema = [];


/***/ },
/* 356 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to enforce concise object methods and properties.
	 * @author Jamund Ferguson
	 * @copyright 2015 Jamund Ferguson. All rights reserved.
	 */

	"use strict";

	var OPTIONS = {
	    always: "always",
	    never: "never",
	    methods: "methods",
	    properties: "properties"
	};

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var APPLY = context.options[0] || OPTIONS.always;
	    var APPLY_TO_METHODS = APPLY === OPTIONS.methods || APPLY === OPTIONS.always;
	    var APPLY_TO_PROPS = APPLY === OPTIONS.properties || APPLY === OPTIONS.always;
	    var APPLY_NEVER = APPLY === OPTIONS.never;

	    //--------------------------------------------------------------------------
	    // Public
	    //--------------------------------------------------------------------------

	    return {
	        "Property": function(node) {
	            var isConciseProperty = node.method || node.shorthand,
	                type;

	            // if we're "never" and concise we should warn now
	            if (APPLY_NEVER && isConciseProperty) {
	                type = node.method ? "method" : "property";
	                context.report(node, "Expected longform " + type + " syntax.");
	            }

	            // at this point if we're concise or if we're "never" we can leave
	            if (APPLY_NEVER || isConciseProperty) {
	                return;
	            }

	            // getters, setters and computed properties are ignored
	            if (node.kind === "get" || node.kind === "set" || node.computed) {
	                return;
	            }

	            if (node.value.type === "FunctionExpression" && node.value.id == null && APPLY_TO_METHODS) {

	                // {x: function(){}} should be written as {x() {}}
	                context.report(node, "Expected method shorthand.");
	            } else if (node.value.type === "Identifier" && node.key.name === node.value.name && APPLY_TO_PROPS) {

	                // {x: x} should be written as {x}
	                context.report(node, "Expected property shorthand.");
	            } else if (node.value.type === "Identifier" && node.key.type === "Literal" && node.key.value === node.value.name && APPLY_TO_PROPS) {

	                // {"x": x} should be written as {x}
	                context.report(node, "Expected property shorthand.");
	            }
	        }
	    };

	};

	module.exports.schema = [
	    {
	        "enum": ["always", "methods", "properties", "never"]
	    }
	];


/***/ },
/* 357 */
/***/ function(module, exports) {

	/**
	 * @fileoverview A rule to suggest using of const declaration for variables that are never modified after declared.
	 * @author Toru Nagashima
	 * @copyright 2015 Toru Nagashima. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    /**
	     * Checks whether a reference is the initializer.
	     * @param {Reference} reference - A reference to check.
	     * @returns {boolean} Whether or not the reference is the initializer.
	     */
	    function isInitializer(reference) {
	        return reference.init === true;
	    }

	    /**
	     * Checks whether a reference is read-only or the initializer.
	     * @param {Reference} reference - A reference to check.
	     * @returns {boolean} Whether or not the reference is read-only or the initializer.
	     */
	    function isReadOnlyOrInitializer(reference) {
	        return reference.isReadOnly() || reference.init === true;
	    }

	    /**
	     * Searches and reports variables that are never modified after declared.
	     * @param {Scope} scope - A scope of the search domain.
	     * @returns {void}
	     */
	    function checkForVariables(scope) {
	        // Skip the TDZ type.
	        if (scope.type === "TDZ") {
	            return;
	        }

	        var variables = scope.variables;
	        for (var i = 0, end = variables.length; i < end; ++i) {
	            var variable = variables[i];
	            var def = variable.defs[0];
	            var declaration = def && def.parent;
	            var statement = declaration && declaration.parent;
	            var references = variable.references;
	            var identifier = variable.identifiers[0];

	            if (statement != null &&
	                identifier != null &&
	                declaration.type === "VariableDeclaration" &&
	                declaration.kind === "let" &&
	                (statement.type !== "ForStatement" || statement.init !== declaration) &&
	                references.some(isInitializer) &&
	                references.every(isReadOnlyOrInitializer)
	            ) {
	                context.report(
	                    identifier,
	                    "`{{name}}` is never modified, use `const` instead.",
	                    {name: identifier.name});
	            }
	        }
	    }

	    /**
	     * Adds multiple items to the tail of an array.
	     * @param {any[]} array - A destination to add.
	     * @param {any[]} values - Items to be added.
	     * @returns {void}
	     */
	    var pushAll = Function.apply.bind(Array.prototype.push);

	    return {
	        "Program:exit": function() {
	            var stack = [context.getScope()];
	            while (stack.length) {
	                var scope = stack.pop();
	                pushAll(stack, scope.childScopes);

	                checkForVariables(scope);
	            }
	        }
	    };

	};

	module.exports.schema = [];


/***/ },
/* 358 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview A rule to suggest using of the spread operator instead of `.apply()`.
	 * @author Toru Nagashima
	 * @copyright 2015 Toru Nagashima. All rights reserved.
	 */

	"use strict";

	var astUtils = __webpack_require__(177);

	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------

	/**
	 * Checks whether or not a node is a `.apply()` for variadic.
	 * @param {ASTNode} node - A CallExpression node to check.
	 * @returns {boolean} Whether or not the node is a `.apply()` for variadic.
	 */
	function isVariadicApplyCalling(node) {
	    return (
	        node.callee.type === "MemberExpression" &&
	        node.callee.property.type === "Identifier" &&
	        node.callee.property.name === "apply" &&
	        node.callee.computed === false &&
	        node.arguments.length === 2 &&
	        node.arguments[1].type !== "ArrayExpression"
	    );
	}

	/**
	 * Checks whether or not the tokens of two given nodes are same.
	 * @param {ASTNode} left - A node 1 to compare.
	 * @param {ASTNode} right - A node 2 to compare.
	 * @param {RuleContext} context - The ESLint rule context object.
	 * @returns {boolean} the source code for the given node.
	 */
	function equalTokens(left, right, context) {
	    var tokensL = context.getTokens(left);
	    var tokensR = context.getTokens(right);

	    if (tokensL.length !== tokensR.length) {
	        return false;
	    }
	    for (var i = 0; i < tokensL.length; ++i) {
	        if (tokensL[i].type !== tokensR[i].type ||
	            tokensL[i].value !== tokensR[i].value
	        ) {
	            return false;
	        }
	    }

	    return true;
	}

	/**
	 * Checks whether or not `thisArg` is not changed by `.apply()`.
	 * @param {ASTNode|null} expectedThis - The node that is the owner of the applied function.
	 * @param {ASTNode} thisArg - The node that is given to the first argument of the `.apply()`.
	 * @param {RuleContext} context - The ESLint rule context object.
	 * @returns {boolean} Whether or not `thisArg` is not changed by `.apply()`.
	 */
	function isValidThisArg(expectedThis, thisArg, context) {
	    if (expectedThis == null) {
	        return astUtils.isNullOrUndefined(thisArg);
	    }
	    return equalTokens(expectedThis, thisArg, context);
	}

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {
	    return {
	        "CallExpression": function(node) {
	            if (!isVariadicApplyCalling(node)) {
	                return;
	            }

	            var applied = node.callee.object;
	            var expectedThis = (applied.type === "MemberExpression") ? applied.object : null;
	            var thisArg = node.arguments[0];

	            if (isValidThisArg(expectedThis, thisArg, context)) {
	                context.report(node, "use the spread operator instead of the \".apply()\".");
	            }
	        }
	    };
	};

	module.exports.schema = [];


/***/ },
/* 359 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to suggest using "Reflect" api over Function/Object methods
	 * @author Keith Cirkel <http://keithcirkel.co.uk>
	 * @copyright 2015 Keith Cirkel. All rights reserved.
	 */
	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {
	    var existingNames = {
	        "apply": "Function.prototype.apply",
	        "call": "Function.prototype.call",
	        "defineProperty": "Object.defineProperty",
	        "getOwnPropertyDescriptor": "Object.getOwnPropertyDescriptor",
	        "getPrototypeOf": "Object.getPrototypeOf",
	        "setPrototypeOf": "Object.setPrototypeOf",
	        "isExtensible": "Object.isExtensible",
	        "getOwnPropertyNames": "Object.getOwnPropertyNames",
	        "preventExtensions": "Object.preventExtensions"
	    };

	    var reflectSubsitutes = {
	        "apply": "Reflect.apply",
	        "call": "Reflect.apply",
	        "defineProperty": "Reflect.defineProperty",
	        "getOwnPropertyDescriptor": "Reflect.getOwnPropertyDescriptor",
	        "getPrototypeOf": "Reflect.getPrototypeOf",
	        "setPrototypeOf": "Reflect.setPrototypeOf",
	        "isExtensible": "Reflect.isExtensible",
	        "getOwnPropertyNames": "Reflect.getOwnPropertyNames",
	        "preventExtensions": "Reflect.preventExtensions"
	    };

	    var exceptions = (context.options[0] || {}).exceptions || [];

	    /**
	     * Reports the Reflect violation based on the `existing` and `substitute`
	     * @param {Object} node The node that violates the rule.
	     * @param {string} existing The existing method name that has been used.
	     * @param {string} substitute The Reflect substitute that should be used.
	     * @returns {void}
	     */
	    function report(node, existing, substitute) {
	        context.report(node, "Avoid using {{existing}}, instead use {{substitute}}", {
	            existing: existing,
	            substitute: substitute
	        });
	    }

	    return {
	        "CallExpression": function(node) {
	            var methodName = (node.callee.property || {}).name;
	            var isReflectCall = (node.callee.object || {}).name === "Reflect";
	            var hasReflectSubsitute = reflectSubsitutes.hasOwnProperty(methodName);
	            var userConfiguredException = exceptions.indexOf(methodName) !== -1;
	            if (hasReflectSubsitute && !isReflectCall && !userConfiguredException) {
	                report(node, existingNames[methodName], reflectSubsitutes[methodName]);
	            }
	        },
	        "UnaryExpression": function(node) {
	            var isDeleteOperator = node.operator === "delete";
	            var targetsIdentifier = node.argument.type === "Identifier";
	            var userConfiguredException = exceptions.indexOf("delete") !== -1;
	            if (isDeleteOperator && !targetsIdentifier && !userConfiguredException) {
	                report(node, "the delete keyword", "Reflect.deleteProperty");
	            }
	        }
	    };

	};

	module.exports.schema = [
	    {
	        "type": "object",
	        "properties": {
	            "exceptions": {
	                "type": "array",
	                "items": {
	                    "enum": [
	                        "apply",
	                        "call",
	                        "delete",
	                        "defineProperty",
	                        "getOwnPropertyDescriptor",
	                        "getPrototypeOf",
	                        "setPrototypeOf",
	                        "isExtensible",
	                        "getOwnPropertyNames",
	                        "preventExtensions"
	                    ]
	                },
	                "uniqueItems": true
	            }
	        },
	        "additionalProperties": false
	    }
	];


/***/ },
/* 360 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag the generator functions that does not have yield.
	 * @author Toru Nagashima
	 * @copyright 2015 Toru Nagashima. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {
	    var stack = [];

	    /**
	     * If the node is a generator function, start counting `yield` keywords.
	     * @param {Node} node - A function node to check.
	     * @returns {void}
	     */
	    function beginChecking(node) {
	        if (node.generator) {
	            stack.push(0);
	        }
	    }

	    /**
	     * If the node is a generator function, end counting `yield` keywords, then
	     * reports result.
	     * @param {Node} node - A function node to check.
	     * @returns {void}
	     */
	    function endChecking(node) {
	        if (!node.generator) {
	            return;
	        }

	        var countYield = stack.pop();
	        if (countYield === 0 && node.body.body.length > 0) {
	            context.report(
	                node,
	                "This generator function does not have `yield`.");
	        }
	    }

	    return {
	        "FunctionDeclaration": beginChecking,
	        "FunctionDeclaration:exit": endChecking,
	        "FunctionExpression": beginChecking,
	        "FunctionExpression:exit": endChecking,

	        // Increases the count of `yield` keyword.
	        "YieldExpression": function() {
	            /* istanbul ignore else */
	            if (stack.length > 0) {
	                stack[stack.length - 1] += 1;
	            }
	        }
	    };
	};

	module.exports.schema = [];


/***/ },
/* 361 */
/***/ function(module, exports) {

	/**
	 * @fileoverview A rule to set the maximum depth block can be nested in a function.
	 * @author Ian Christian Myers
	 * @copyright 2013 Ian Christian Myers. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    //--------------------------------------------------------------------------
	    // Helpers
	    //--------------------------------------------------------------------------

	    var functionStack = [],
	        maxDepth = context.options[0] || 4;

	    function startFunction() {
	        functionStack.push(0);
	    }

	    function endFunction() {
	        functionStack.pop();
	    }

	    function pushBlock(node) {
	        var len = ++functionStack[functionStack.length - 1];

	        if (len > maxDepth) {
	            context.report(node, "Blocks are nested too deeply ({{depth}}).",
	                    { depth: len });
	        }
	    }

	    function popBlock() {
	        functionStack[functionStack.length - 1]--;
	    }

	    //--------------------------------------------------------------------------
	    // Public API
	    //--------------------------------------------------------------------------

	    return {
	        "Program": startFunction,
	        "FunctionDeclaration": startFunction,
	        "FunctionExpression": startFunction,
	        "ArrowFunctionExpression": startFunction,

	        "IfStatement": function(node) {
	            if (node.parent.type !== "IfStatement") {
	                pushBlock(node);
	            }
	        },
	        "SwitchStatement": pushBlock,
	        "TryStatement": pushBlock,
	        "DoWhileStatement": pushBlock,
	        "WhileStatement": pushBlock,
	        "WithStatement": pushBlock,
	        "ForStatement": pushBlock,
	        "ForInStatement": pushBlock,
	        "ForOfStatement": pushBlock,

	        "IfStatement:exit": popBlock,
	        "SwitchStatement:exit": popBlock,
	        "TryStatement:exit": popBlock,
	        "DoWhileStatement:exit": popBlock,
	        "WhileStatement:exit": popBlock,
	        "WithStatement:exit": popBlock,
	        "ForStatement:exit": popBlock,
	        "ForInStatement:exit": popBlock,
	        "ForOfStatement:exit": popBlock,

	        "FunctionDeclaration:exit": endFunction,
	        "FunctionExpression:exit": endFunction,
	        "ArrowFunctionExpression:exit": endFunction,
	        "Program:exit": endFunction
	    };

	};

	module.exports.schema = [
	    {
	        "type": "integer"
	    }
	];


/***/ },
/* 362 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to check for max length on a line.
	 * @author Matt DuVall <http://www.mattduvall.com>
	 * @copyright 2013 Matt DuVall. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {
	    // takes some ideas from http://tools.ietf.org/html/rfc3986#appendix-B, however:
	    // - They're matching an entire string that we know is a URI
	    // - We're matching part of a string where we think there *might* be a URL
	    // - We're only concerned about URLs, as picking out any URI would cause too many false positives
	    // - We don't care about matching the entire URL, any small segment is fine
	    var URL_REGEXP = /[^:/?#]:\/\/[^?#]/;

	    /**
	     * Creates a string that is made up of repeating a given string a certain
	     * number of times. This uses exponentiation of squares to achieve significant
	     * performance gains over the more traditional implementation of such
	     * functionality.
	     * @param {string} str The string to repeat.
	     * @param {int} num The number of times to repeat the string.
	     * @returns {string} The created string.
	     * @private
	     */
	    function stringRepeat(str, num) {
	        var result = "";
	        for (num |= 0; num > 0; num >>>= 1, str += str) {
	            if (num & 1) {
	                result += str;
	            }
	        }
	        return result;
	    }

	    var maxLength = context.options[0] || 80,
	        tabWidth = context.options[1] || 4,
	        ignoreOptions = context.options[2] || {},
	        ignorePattern = ignoreOptions.ignorePattern || null,
	        ignoreComments = ignoreOptions.ignoreComments || false,
	        ignoreUrls = ignoreOptions.ignoreUrls || false,
	        tabString = stringRepeat(" ", tabWidth);

	    if (ignorePattern) {
	        ignorePattern = new RegExp(ignorePattern);
	    }

	    //--------------------------------------------------------------------------
	    // Helpers
	    //--------------------------------------------------------------------------

	    /**
	     * Tells if a given comment is trailing: it starts on the current line and
	     * extends to or past the end of the current line.
	     * @param {string} line The source line we want to check for a trailing comment on
	     * @param {number} lineNumber The one-indexed line number for line
	     * @param {ASTNode} comment The comment to inspect
	     * @returns {boolean} If the comment is trailing on the given line
	     */
	    function isTrailingComment(line, lineNumber, comment) {
	        return comment &&
	            (comment.loc.start.line <= lineNumber && lineNumber <= comment.loc.end.line) &&
	            (comment.loc.end.line > lineNumber || comment.loc.end.column === line.length);
	    }

	    /**
	     * Gets the line after the comment and any remaining trailing whitespace is
	     * stripped.
	     * @param {string} line The source line with a trailing comment
	     * @param {number} lineNumber The one-indexed line number this is on
	     * @param {ASTNode} comment The comment to remove
	     * @returns {string} Line without comment and trailing whitepace
	     */
	    function stripTrailingComment(line, lineNumber, comment) {
	        if (comment.loc.start.line < lineNumber) {
	            // this entire line is a comment
	            return "";
	        } else {
	            // loc.column is zero-indexed
	            return line.slice(0, comment.loc.start.column).replace(/\s+$/, "");
	        }
	    }

	    function checkProgramForMaxLength(node) {
	        // split (honors line-ending)
	        var lines = context.getSourceLines(),
	            // list of comments to ignore
	            comments = ignoreComments ? context.getAllComments() : [],
	            // we iterate over comments in parallel with the lines
	            commentsIndex = 0;

	        lines.forEach(function(line, i) {
	            // i is zero-indexed, line numbers are one-indexed
	            var lineNumber = i + 1;
	            // we can short-circuit the comment checks if we're already out of comments to check
	            if (commentsIndex < comments.length) {
	                // iterate over comments until we find one past the current line
	                do {
	                    var comment = comments[++commentsIndex];
	                } while (comment && comment.loc.start.line <= lineNumber);
	                // and step back by one
	                comment = comments[--commentsIndex];
	                if (isTrailingComment(line, lineNumber, comment)) {
	                    line = stripTrailingComment(line, lineNumber, comment);
	                }
	            }
	            if (ignorePattern && ignorePattern.test(line) ||
	                ignoreUrls && URL_REGEXP.test(line)) {
	                // ignore this line
	                return;
	            }
	            // replace the tabs
	            if (line.replace(/\t/g, tabString).length > maxLength) {
	                context.report(node, { line: lineNumber, column: 0 }, "Line " + (i + 1) + " exceeds the maximum line length of " + maxLength + ".");
	            }
	        });
	    }


	    //--------------------------------------------------------------------------
	    // Public API
	    //--------------------------------------------------------------------------

	    return {
	        "Program": checkProgramForMaxLength
	    };

	};

	module.exports.schema = [
	    {
	        "type": "integer",
	        "minimum": 0
	    },
	    {
	        "type": "integer",
	        "minimum": 0
	    },
	    {
	        "type": "object",
	        "properties": {
	            "ignorePattern": {
	                "type": "string"
	            },
	            "ignoreComments": {
	                "type": "boolean"
	            },
	            "ignoreUrls": {
	                "type": "boolean"
	            }
	        },
	        "additionalProperties": false
	    }
	];


/***/ },
/* 363 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag when a function has too many parameters
	 * @author Ilya Volodin
	 * @copyright 2014 Nicholas C. Zakas. All rights reserved.
	 * @copyright 2013 Ilya Volodin. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var numParams = context.options[0] || 3;

	    /**
	     * Checks a function to see if it has too many parameters.
	     * @param {ASTNode} node The node to check.
	     * @returns {void}
	     * @private
	     */
	    function checkFunction(node) {
	        if (node.params.length > numParams) {
	            context.report(node, "This function has too many parameters ({{count}}). Maximum allowed is {{max}}.", {
	                count: node.params.length,
	                max: numParams
	            });
	        }
	    }

	    return {
	        "FunctionDeclaration": checkFunction,
	        "ArrowFunctionExpression": checkFunction,
	        "FunctionExpression": checkFunction
	    };

	};

	module.exports.schema = [
	    {
	        "type": "integer"
	    }
	];


/***/ },
/* 364 */
/***/ function(module, exports) {

	/**
	 * @fileoverview A rule to set the maximum number of statements in a function.
	 * @author Ian Christian Myers
	 * @copyright 2013 Ian Christian Myers. All rights reserved.
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    //--------------------------------------------------------------------------
	    // Helpers
	    //--------------------------------------------------------------------------

	    var functionStack = [],
	        maxStatements = context.options[0] || 10;

	    function startFunction() {
	        functionStack.push(0);
	    }

	    function endFunction(node) {
	        var count = functionStack.pop();

	        if (count > maxStatements) {
	            context.report(node, "This function has too many statements ({{count}}). Maximum allowed is {{max}}.",
	                    { count: count, max: maxStatements });
	        }
	    }

	    function countStatements(node) {
	        functionStack[functionStack.length - 1] += node.body.length;
	    }

	    //--------------------------------------------------------------------------
	    // Public API
	    //--------------------------------------------------------------------------

	    return {
	        "FunctionDeclaration": startFunction,
	        "FunctionExpression": startFunction,
	        "ArrowFunctionExpression": startFunction,

	        "BlockStatement": countStatements,

	        "FunctionDeclaration:exit": endFunction,
	        "FunctionExpression:exit": endFunction,
	        "ArrowFunctionExpression:exit": endFunction
	    };

	};

	module.exports.schema = [
	    {
	        "type": "integer"
	    }
	];


/***/ },
/* 365 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag bitwise identifiers
	 * @author Nicholas C. Zakas
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    var BITWISE_OPERATORS = [
	        "^", "|", "&", "<<", ">>", ">>>",
	        "^=", "|=", "&=", "<<=", ">>=", ">>>=",
	        "~"
	    ];

	    /**
	     * Reports an unexpected use of a bitwise operator.
	     * @param   {ASTNode} node Node which contains the bitwise operator.
	     * @returns {void}
	     */
	    function report(node) {
	        context.report(node, "Unexpected use of '{{operator}}'.", { operator: node.operator });
	    }

	    /**
	     * Checks if the given node has a bitwise operator.
	     * @param   {ASTNode} node The node to check.
	     * @returns {boolean} Whether or not the node has a bitwise operator.
	     */
	    function hasBitwiseOperator(node) {
	        return BITWISE_OPERATORS.indexOf(node.operator) !== -1;
	    }

	    /**
	     * Report if the given node contains a bitwise operator.
	     * @param {ASTNode} node The node to check.
	     * @returns {void}
	     */
	    function checkNodeForBitwiseOperator(node) {
	        if (hasBitwiseOperator(node)) {
	            report(node);
	        }
	    }

	    return {
	        "AssignmentExpression": checkNodeForBitwiseOperator,
	        "BinaryExpression": checkNodeForBitwiseOperator,
	        "UnaryExpression": checkNodeForBitwiseOperator
	    };

	};

	module.exports.schema = [];


/***/ },
/* 366 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag use of unary increment and decrement operators.
	 * @author Ian Christian Myers
	 */

	"use strict";

	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------

	module.exports = function(context) {

	    return {

	        "UpdateExpression": function(node) {
	            context.report(node, "Unary operator '" + node.operator + "' used.");
	        }

	    };

	};

	module.exports.schema = [];


/***/ }
]);